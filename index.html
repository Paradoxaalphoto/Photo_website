<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>YorN • 1.17.3‑alpha</title>
<style>
  :root { --bg:#0b0d10; --fg:#e6e9ef; --muted:#aab3c0; --ink:#121418; --accent:#7cd2ff; --ok:#20c997; --warn:#ffd166; --err:#ff6b6b; --card:#14171c; --line:#262a31; }
  html,body {margin:0; height:100%; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  .wrap {max-width:980px; margin:0 auto; padding:16px; display:flex; flex-direction:column; gap:12px;}
  header{display:flex; align-items:center; gap:10px; position:sticky; top:0; background:linear-gradient(180deg, rgba(11,13,16,.95), rgba(11,13,16,.75) 70%, transparent); padding:8px 0; z-index:10; backdrop-filter:saturate(120%) blur(6px)}
  h1{font-size:16px; margin:0; letter-spacing:.2px; font-weight:600}
  .rev{margin-left:auto; font-size:12px; color:var(--muted); opacity:.8; padding:2px 8px; border:1px solid var(--line); border-radius:999px}
  .grid{display:grid; gap:12px}
  @media(min-width:900px){ .grid{ grid-template-columns: 1.2fr .8fr; align-items:start } }
  .card{background:var(--card); border:1px solid var(--line); border-radius:12px; padding:12px}
  .row{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
  button, .btn { background:#1b2027; color:var(--fg); border:1px solid var(--line); border-radius:10px; padding:8px 10px; cursor:pointer }
  button.primary { background:#1d2a33; border-color:#254254 }
  button:disabled{ opacity:.5; cursor:not-allowed }
  label.small{font-size:12px; color:var(--muted)}
  input[type="file"]{ display:block; }
  canvas{ max-width:100%; height:auto; background:#0f1216; border-radius:10px; border:1px solid var(--line)}
  .controls{display:flex; flex-wrap:wrap; gap:8px}
  .kv{display:flex; gap:6px; align-items:center}
  .meter{height:8px; background:#0e1116; border:1px solid var(--line); border-radius:6px; width:120px; overflow:hidden}
  .meter > i{display:block; height:100%; width:0; background:linear-gradient(90deg, var(--accent), #83ffa1)}
  pre{white-space:pre-wrap; word-break:break-word; background:#0f1318; border:1px solid var(--line); border-radius:10px; padding:10px; max-height:320px; overflow:auto}
  .toast{position:fixed; left:50%; bottom:18px; transform:translateX(-50%); background:#11161c; color:#d9e2ee; border:1px solid var(--line); border-radius:10px; padding:8px 12px; opacity:0; pointer-events:none; transition:opacity .2s ease}
  .toast.show{opacity:1}
  .pill{display:inline-block; padding:2px 8px; border:1px solid var(--line); border-radius:999px; font-size:12px; color:var(--muted)}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; font-weight:600; font-size:11px}
  .ready{ background:#0f2a1e; color:#64e6a5; border:1px solid #1f4c3a }
  .blocked{ background:#2a1010; color:#ffa7a7; border:1px solid #4c1f1f }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>YorN Prototype</h1>
    <span id="backendPill" class="pill">TF: —</span>
    <span id="readiness" class="badge blocked" style="display:none">BLOCKED</span>
    <span class="rev">rev <strong id="rev">1.17.3‑alpha</strong></span>
  </header>

  <div class="grid">
    <!-- Left: Preview & Actions -->
    <section class="card">
      <div class="row" style="justify-content:space-between">
        <div class="controls">
          <input id="file" type="file" accept="image/*" />
          <button id="sample" class="primary">Load Sample</button>
          <button id="detect" disabled>Detect</button>
          <button id="analyze" disabled>Start Analysis</button>
          <button id="reset">Reset</button>
        </div>
        <div class="kv">
          <label class="small">Progress</label>
          <div class="meter"><i id="meterBar"></i></div>
          <span id="progressTxt" class="small">idle</span>
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <div class="kv"><label class="small">Zoom</label><input id="zoom" type="range" min="0.8" max="2" step="0.05" value="1.2" /></div>
        <div class="kv"><label class="small">Brightness</label><input id="bri" type="range" min="0.8" max="1.4" step="0.02" value="1.1" /></div>
        <div class="kv"><label class="small">Contrast</label><input id="con" type="range" min="0.8" max="1.6" step="0.02" value="1.15" /></div>
        <button id="enhance">Enhance & Retry</button>
      </div>

      <div style="margin-top:10px">
        <canvas id="preview" width="0" height="0"></canvas>
      </div>
    </section>

    <!-- Right: Logs & AutoTest -->
    <aside class="card">
      <div class="row" style="justify-content:space-between; align-items:center">
        <strong>Diagnostics</strong>
        <div class="controls">
          <button id="autoTest" class="primary">Auto‑Test</button>
          <button id="copyDiag">Copy Diagnostics</button>
          <button id="clearDiag">Clear</button>
        </div>
      </div>
      <pre id="diag">No diagnostics yet.</pre>
    </aside>
  </div>

  <section id="analysisCard" class="card" style="display:none">
    <div class="row" style="justify-content:space-between; align-items:center">
      <strong>Analysis</strong>
      <div class="controls">
        <button id="copyJson">Copy JSON</button>
        <button id="saveJson">Download JSON</button>
      </div>
    </div>
    <pre id="analysisBox">—</pre>
  </section>
</div>

<div id="toast" class="toast">Copied ✓</div>

<!-- Frameworks (pinned) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@3.21.0/dist/tf-backend-wasm.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>

<script>
(() => {
  const REV = "1.17.3-alpha";
  const el = id => document.getElementById(id);
  const $diag = el('diag');
  const $meter = el('meterBar');
  const $progress = el('progressTxt');
  const $preview = el('preview');
  const $analysisCard = el('analysisCard');
  const $analysisBox = el('analysisBox');
  const $backendPill = el('backendPill');
  const $readiness = el('readiness');

  let model = null;
  let baseBitmap = null;     // createImageBitmap of the original
  let workW = 0, workH = 0;  // preview canvas dims
  let lastBox = null;
  let lastAnalysis = null;

  /* ---------- utils ---------- */
  function nowISO(){ return new Date().toISOString(); }
  function log(type, obj){
    const line = JSON.stringify({ time: nowISO(), type, ...obj });
    if ($diag.textContent === 'No diagnostics yet.') $diag.textContent = '';
    $diag.textContent += ( ($diag.textContent && !$diag.textContent.endsWith('\n'))?'\n':'') + line + '\n';
    // keep scrolled to bottom for convenience
    $diag.scrollTop = $diag.scrollHeight;
  }
  function setProgress(pct, txt){
    $meter.style.width = Math.max(0, Math.min(100, pct)) + '%';
    if (txt) $progress.textContent = txt;
  }
  function toast(msg='Copied ✓'){
    const t = el('toast');
    t.textContent = msg;
    t.classList.add('show');
    setTimeout(()=>t.classList.remove('show'), 1200);
  }
  function drawPreview(bitmap, zoom=+el('zoom').value, bri=+el('bri').value, con=+el('con').value){
    const pw = Math.min(1024, bitmap.width);
    const ph = Math.round(bitmap.height * (pw/bitmap.width));
    $preview.width = pw;
    $preview.height = ph;
    const ctx = $preview.getContext('2d');
    ctx.filter = `brightness(${bri}) contrast(${con})`;
    const zw = Math.round(pw / zoom);
    const zh = Math.round(ph / zoom);
    const sx = Math.max(0, Math.round((pw-zw)/2));
    const sy = Math.max(0, Math.round((ph-zh)/2));
    // draw to a temp canvas so filters work predictably
    const t = document.createElement('canvas');
    t.width = pw; t.height = ph;
    t.getContext('2d').drawImage(bitmap, 0,0,pw,ph);
    ctx.drawImage(t, sx, sy, zw, zh, 0, 0, pw, ph);
    workW = pw; workH = ph;
    // overlay previous box if present
    if (lastBox){
      ctx.save();
      ctx.strokeStyle = '#7cd2ff';
      ctx.lineWidth = 2;
      ctx.globalAlpha = .9;
      ctx.strokeRect(lastBox.x, lastBox.y, lastBox.width, lastBox.height);
      ctx.restore();
    }
  }

  /* ---------- TF backend & warm-up ---------- */
  async function setupTF(){
    const ua = navigator.userAgent || '';
    const preferWasm = /Android|Mobile/i.test(ua);
    let backendTried = [];
    try {
      if (preferWasm){
        await tf.setBackend('wasm'); await tf.ready();
        backendTried.push('wasm');
      } else {
        await tf.setBackend('webgl'); await tf.ready();
        backendTried.push('webgl');
      }
    } catch(e){
      log('error', { backend_error: e.message || String(e) });
    }
    // verify & fallback chain
    let b = tf.getBackend();
    if (!b){
      try { await tf.setBackend(preferWasm ? 'webgl' : 'wasm'); await tf.ready(); } catch(_) {}
      b = tf.getBackend();
    }
    if (!b){ try { await tf.setBackend('cpu'); await tf.ready(); b = tf.getBackend(); } catch(_) {} }
    $backendPill.textContent = `TF: ${b || '—'}`;
    log('config', { tf_ready: !!b, backend: b || 'none', tf_version: tf?.version_core || 'unknown' });

    // load model
    setProgress(8, 'Loading detector…');
    model = await blazeface.load({ maxFaces: 1 });
    log('detect', { blazefaceReady: true });

    // warm-up with a 128×128 dummy once
    const warm = document.createElement('canvas');
    warm.width = 128; warm.height = 128;
    const wctx = warm.getContext('2d');
    wctx.fillStyle = '#222'; wctx.fillRect(0,0,128,128);
    const t0 = performance.now();
    await model.estimateFaces(warm, false);
    const dt = Math.round(performance.now() - t0);
    log('config', { warmup: 'ok', backend: tf.getBackend(), ms: dt });
  }

  /* ---------- decode & sample ---------- */
  async function decodeToBitmap(fileOrBlob){
    const blob = fileOrBlob instanceof Blob ? fileOrBlob : new Blob([fileOrBlob]);
    const bmp = await createImageBitmap(blob);
    return bmp;
  }
  async function handleFile(file){
    setProgress(12, 'Decoding photo…');
    baseBitmap = await decodeToBitmap(file);
    drawPreview(baseBitmap);
    el('detect').disabled = false;
    el('analyze').disabled = false;
    log('detect', { file: file.name || 'blob', w: baseBitmap.width, h: baseBitmap.height });
  }
  async function loadSample(){
    setProgress(10, 'Fetching sample…');
    // primary Unsplash
    const u1 = 'https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1024&auto=format&fit=crop';
    // backup face (different image)
    const u2 = 'https://images.unsplash.com/photo-1544005313-94ddf0286df2?q=80&w=1024&auto=format&fit=crop';
    try{
      const res = await fetch(u1, { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP '+res.status);
      const blob = await res.blob();
      baseBitmap = await decodeToBitmap(blob);
      log('detect', { sampleImage: u1 });
    }catch(_){
      const res2 = await fetch(u2, { cache: 'no-store' });
      const blob2 = await res2.blob();
      baseBitmap = await decodeToBitmap(blob2);
      log('detect', { sampleImage: u2, fallback:true });
    }
    drawPreview(baseBitmap);
    el('detect').disabled = false;
    el('analyze').disabled = false;
    setProgress(18, 'Sample ready');
  }

  /* ---------- fast detect (128×128 path) ---------- */
  async function fastDetect(){
    if (!baseBitmap) throw new Error('no_image');
    if (!model) throw new Error('no_model');

    // render current preview first (respects zoom/filters)
    drawPreview(baseBitmap);

    // downscale to model-native 128×128 to speed up
    const s = document.createElement('canvas');
    s.width = 128; s.height = 128;
    const sctx = s.getContext('2d');
    sctx.imageSmoothingEnabled = true;
    sctx.drawImage($preview, 0,0,128,128);

    const t0 = performance.now();
    const faces = await model.estimateFaces(s, false);
    const roughMs = Math.round(performance.now() - t0);

    if (!faces || !faces.length){
      log('error', { detect: 'no_face' });
      return null;
    }
    // Map the box from 128 canvas -> preview canvas
    const f = faces[0].topLeft && faces[0].bottomRight ? faces[0] : null;
    // blazeface returns topLeft & bottomRight as [x,y]
    const [x0,y0] = f.topLeft;
    const [x1,y1] = f.bottomRight;
    const scaleX = workW / 128;
    const scaleY = workH / 128;
    const box = {
      x: x0 * scaleX,
      y: y0 * scaleY,
      width: (x1 - x0) * scaleX,
      height: (y1 - y0) * scaleY
    };
    lastBox = box;
    // redraw overlay
    drawPreview(baseBitmap);
    // log timings (simulate “finalDetect_ms” as same path)
    log('detect', { roughLocate_ms: roughMs, finalDetect_ms: roughMs, box });
    return box;
  }

  /* ---------- lightweight analysis (no extra models) ---------- */
  function analyzeBox(){
    if (!lastBox || !$preview.width) return null;
    const ctx = $preview.getContext('2d');
    const {x,y,width,height} = lastBox;
    const crop = ctx.getImageData(Math.max(0,Math.floor(x)), Math.max(0,Math.floor(y)), Math.max(1,Math.floor(width)), Math.max(1,Math.floor(height)));
    const data = crop.data;
    // brightness mean & contrast stdev
    let sum=0, sum2=0, n = data.length/4;
    for (let i=0;i<data.length;i+=4){
      const l = 0.2126*data[i] + 0.7152*data[i+1] + 0.0722*data[i+2];
      sum += l; sum2 += l*l;
    }
    const mean = sum/n;
    const variance = Math.max(0, sum2/n - mean*mean);
    const stdev = Math.sqrt(variance);

    // quick Laplacian variance (very lightweight approx)
    // sample every 4th pixel to keep UI snappy
    const w = crop.width, h = crop.height;
    let lapVar = 0, cnt=0;
    for (let yy=1; yy<h-1; yy+=2){
      for (let xx=1; xx<w-1; xx+=2){
        const idx = (yy*w+xx)*4;
        const L = 0.2126*data[idx] + 0.7152*data[idx+1] + 0.0722*data[idx+2];
        const N = 0.2126*data[idx-4*w] + 0.7152*data[idx-4*w+1] + 0.0722*data[idx-4*w+2];
        const S = 0.2126*data[idx+4*w] + 0.7152*data[idx+4*w+1] + 0.0722*data[idx+4*w+2];
        const W = 0.2126*data[idx-4] + 0.7152*data[idx-3] + 0.0722*data[idx-2];
        const E = 0.2126*data[idx+4] + 0.7152*data[idx+5] + 0.0722*data[idx+6];
        const lap = (4*L) - (N+S+W+E);
        lapVar += lap*lap;
        cnt++;
      }
    }
    lapVar = cnt ? lapVar/cnt : 0;

    const imgW = $preview.width, imgH = $preview.height;
    const cx = x + width/2, cy = y + height/2;
    const analysis = {
      revision: REV,
      timestamp: nowISO(),
      image: { width: imgW, height: imgH },
      box: {
        x: +x.toFixed(2), y: +y.toFixed(2),
        width: +width.toFixed(2), height:+height.toFixed(2),
        area_pct: +((width*height)/(imgW*imgH)*100).toFixed(4),
        center: { x:+cx.toFixed(2), y:+cy.toFixed(2) },
        center_offset_pct: {
          x: +(((cx - imgW/2) / (imgW/2))*100).toFixed(2),
          y: +(((cy - imgH/2) / (imgH/2))*100).toFixed(2)
        }
      },
      lighting: {
        brightness_mean: +mean.toFixed(3),
        contrast_stdev: +stdev.toFixed(3)
      },
      sharpness: { laplacian_variance: +lapVar.toFixed(3) },
      orientation: imgW >= imgH ? 'landscape' : 'portrait',
      refine: {}
    };
    lastAnalysis = analysis;
    $analysisCard.style.display = '';
    $analysisBox.textContent = JSON.stringify(analysis, null, 2);
    log('analysis', { analysis });
    // readiness badge
    const ok = !!(lastBox && lastAnalysis);
    $readiness.style.display = 'inline-block';
    $readiness.className = ok ? 'badge ready' : 'badge blocked';
    $readiness.textContent = ok ? 'READY' : 'BLOCKED';
    return analysis;
  }

  /* ---------- Auto‑Test ---------- */
  async function autoTest(){
    el('autoTest').disabled = true;
    log('test', { step:'begin', rev: REV });
    try{
      // ensure frameworks & model are up
      if (!tf?.getBackend()) await setupTF();
      log('test', { step:'tf_present', ok: !!tf?.getBackend() });

      await loadSample();
      log('test', { step:'sample', ok: !!baseBitmap });

      const box = await fastDetect();
      log('test', { step:'detect', ok: !!box });

      const a = analyzeBox();
      log('test', { step:'analysis', ok: !!a });

      const ok = !!(box && a);
      log('test', { step:'summary', ok });
    }catch(e){
      log('error', { autoTest: e.message || String(e) });
      log('test', { step:'summary', ok:false });
    }
    el('autoTest').disabled = false;
  }

  /* ---------- UI binds ---------- */
  el('file').addEventListener('change', async () => {
    const f = el('file').files?.[0];
    if (!f) return;
    try{
      await handleFile(f);
      setProgress(20, 'Photo ready');
    }catch(e){
      log('error', { decode_failed: e.message || String(e) });
    }
  });
  el('sample').addEventListener('click', loadSample);
  el('detect').addEventListener('click', async () => {
    setProgress(28, 'Detecting…');
    const b = await fastDetect();
    setProgress(b ? 48 : 28, b ? 'Face found' : 'No face');
  });
  el('enhance').addEventListener('click', () => {
    // nudge sliders up (once) for tougher images
    const z = el('zoom'); z.value = Math.max(+z.value, 1.5);
    const br = el('bri'); br.value = Math.max(+br.value, 1.18);
    const co = el('con'); co.value = Math.max(+co.value, 1.25);
    drawPreview(baseBitmap || $preview);
    log('config', { enhance:'applied', zoom:+z.value, bri:+br.value, con:+co.value });
  });
  ['zoom','bri','con'].forEach(id => {
    el(id).addEventListener('input', () => {
      if (baseBitmap) drawPreview(baseBitmap);
    });
  });
  el('analyze').addEventListener('click', () => {
    setProgress(62, 'Analyzing…');
    const a = analyzeBox();
    setProgress(a ? 85 : 62, a ? 'Analysis ready' : 'Analysis failed');
  });
  el('reset').addEventListener('click', () => {
    baseBitmap = null; lastBox = null; lastAnalysis = null;
    $preview.width = 0; $preview.height = 0;
    $analysisCard.style.display = 'none';
    setProgress(0, 'idle');
    el('detect').disabled = true;
    el('analyze').disabled = true;
    log('config', { reset:true });
  });
  el('autoTest').addEventListener('click', autoTest);

  el('copyDiag').addEventListener('click', async () => {
    try{
      const txt = $diag.textContent || '';
      // robust copy (Clipboard API + fallback)
      let ok = false;
      if (navigator.clipboard && window.isSecureContext){
        await navigator.clipboard.writeText(txt);
        ok = true;
      } else {
        const ta = document.createElement('textarea');
        ta.value = txt;
        ta.setAttribute('readonly','');
        ta.style.position='fixed'; ta.style.opacity='0'; ta.style.left='-9999px';
        document.body.appendChild(ta); ta.select();
        ok = document.execCommand('copy');
        ta.remove();
      }
      toast(ok ? 'Diagnostics copied ✓' : 'Copy failed');
      log('config', { copyDiagnostics: ok });
    }catch(e){
      log('error', { copyDiagnostics: e.message || String(e) });
      toast('Copy failed');
    }
  });
  el('clearDiag').addEventListener('click', () => {
    $diag.textContent = 'No diagnostics yet.';
  });
  el('copyJson').addEventListener('click', async () => {
    if (!lastAnalysis) return;
    const str = JSON.stringify(lastAnalysis, null, 2);
    try{
      if (navigator.clipboard && window.isSecureContext){
        await navigator.clipboard.writeText(str);
      }else{
        const ta = document.createElement('textarea'); ta.value = str;
        ta.style.position='fixed'; ta.style.opacity='0'; ta.style.left='-9999px';
        document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove();
      }
      toast('Analysis JSON copied ✓');
    }catch(_){ toast('Copy failed'); }
  });
  el('saveJson').addEventListener('click', () => {
    if (!lastAnalysis) return;
    const blob = new Blob([JSON.stringify(lastAnalysis, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `yorn-analysis-${Date.now()}.json`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  /* ---------- Boot ---------- */
  window.addEventListener('load', async () => {
    log('config', { boot:'dom-ready', rev: REV });
    try{
      await setupTF();
      log('config', { boot:'complete' });
    }catch(e){
      log('error', { boot_error: e.message || String(e) });
    }
  });
})();
</script>
</body>
</html>