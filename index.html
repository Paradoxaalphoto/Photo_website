<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>YorN — 1.14.1-alpha</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:; img-src * data: blob:; connect-src * data: blob:; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'self'; frame-ancestors 'self'; upgrade-insecure-requests">

<style>
  :root{color-scheme:light dark}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,sans-serif;background:#0b1220;color:#e6eaf2;overflow-x:hidden}
  .container{max-width:980px;margin:0 auto;padding:16px}
  .card{background:#0f172a;border:1px solid #233046;border-radius:12px;padding:12px;margin-top:12px}
  .row{display:grid;grid-template-columns:1fr auto auto auto auto auto auto auto auto auto;gap:8px;align-items:end}
  .controls{display:grid;grid-template-columns:repeat(8,1fr);gap:8px;margin-top:8px}
  @media (max-width:720px){
    .row{grid-template-columns:1fr;gap:10px}
    .controls{grid-template-columns:1fr 1fr;gap:10px}
    .two-col{grid-template-columns:1fr;gap:12px}
    .research-grid{grid-template-columns:1fr}
  }
  label{font-size:12px;color:#A9B4C8}
  input[type="range"],input[type="number"],select,textarea{width:100%;padding:6px;border:1px solid #233046;border-radius:8px;background:#0b1220;color:#E6EAF2}
  textarea{min-height:72px;resize:vertical}
  .btn{padding:10px 14px;border-radius:8px;border:1px solid #233046;background:#1f2937;color:#E6EAF2;cursor:pointer}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .btn-primary{background:#2563eb}

  #progressContainer{height:8px;background:#1e293b;border-radius:6px;overflow:hidden;margin-top:8px}
  #progressBar{height:100%;width:0;background:#38bdf8;transition:width .25s}
  .two-col{display:grid;grid-template-columns:1fr 1fr;gap:12px}

  .previewWrap{position:relative;overflow:hidden}
  .previewSurface{width:100%;height:auto;display:block}

  #diagnostics{white-space:pre-wrap;overflow-wrap:anywhere;word-break:break-word;font:12px ui-monospace,Menlo,Consolas,monospace;background:#0b1220;border:1px solid #233046;border-radius:8px;padding:8px;height:220px;max-height:40vh;overflow:auto}
  .diag-tools{display:flex;gap:8px;align-items:center;margin:6px 0;flex-wrap:wrap}
  .filter-chip{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border:1px solid #233046;border-radius:999px;background:#0b1220;font-size:12px}

  .analysis-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .kv{display:flex;justify-content:space-between;gap:8px;font-size:13px;padding:6px 8px;background:#0b1220;border:1px solid #233046;border-radius:8px}
  .kv b{color:#c7d2fe}
  .badge{font:12px ui-monospace,monospace;padding:1px 6px;border-radius:999px;border:1px solid #233046;margin-left:6px}
  .ok{background:rgba(16,185,129,.15);color:#a7f3d0;border-color:rgba(16,185,129,.55)}
  .warn{background:rgba(245,158,11,.15);color:#fde68a;border-color:rgba(245,158,11,.55)}

  /* Tiny corner badges */
  #revBadge{position:fixed;top:8px;right:10px;z-index:9999;background:#0008;color:#fff;font:12px ui-monospace,monospace;padding:3px 8px;border:1px solid #fff3;border-radius:999px}
  #readyBadge{position:fixed;top:36px;right:10px;z-index:9999;display:none;background:#10b98126;color:#a7f3d0;font:12px ui-monospace,monospace;padding:3px 8px;border:1px solid #10b9818c;border-radius:999px}
  #readyDot{display:inline-block;width:8px;height:8px;border-radius:999px;background:#10b981;margin-right:6px}

  /* Readiness badge */
  #readinessBadge{position:fixed;top:64px;right:10px;z-index:9999;display:none;font:12px ui-monospace,monospace;padding:3px 8px;border-radius:999px;border:1px solid #233046}
  #readinessBadge.ready{background:#052e1b; color:#a7f3d0; border-color:#0a5a33}
  #readinessBadge.blocked{background:#3a0b0b; color:#fecaca; border-color:#7f1d1d}

  #veil{position:fixed;inset:0;background:#0b1220;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;z-index:10000}
  #veil .spin{width:28px;height:28px;border-radius:999px;border:3px solid #334155;border-top-color:#38bdf8;animation:sp 0.9s linear infinite}
  #veil .msg{color:#A9B4C8;font:13px ui-monospace,monospace}
  @keyframes sp{to{transform:rotate(360deg)}}

  footer{opacity:.8;font:12px ui-monospace,monospace;margin-top:10px;display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap}

  .research-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .hint{font-size:12px;color:#A9B4C8}
  #swPill{font:11px ui-monospace,monospace;padding:4px 8px;border-radius:999px;border:1px solid #233046;background:#0b1220;opacity:.9}
</style>

<!-- libs -->
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@3.21.0/dist/tf-backend-wasm.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js" crossorigin="anonymous"></script>
</head>
<body>
<div id="revBadge">YorN Rev <span id="revText"></span></div>
<div id="readyBadge"><span id="readyDot"></span><span id="readyText">Ready for Analysis</span></div>
<div id="readinessBadge" title="Auto‑test readiness badge">READY</div>
<div id="veil"><div class="spin"></div><div class="msg" id="veilMsg">Frameworks loading…</div></div>

<div class="container">
  <h2>YorN — Face Detection & Research Mode</h2>

  <div class="card">
    <div class="row">
      <input id="fileInput" type="file" accept="image/*" />
      <button id="sampleBtn" class="btn">Load Sample</button>
      <button id="enhanceBtn" class="btn" disabled>Enhance & Retry</button>
      <button id="detectBtn" class="btn" disabled>Detect</button>
      <button id="startAnalysisBtn" class="btn btn-primary" disabled>Start Analysis</button>
      <button id="autoTestBtn" class="btn">Auto Test</button>
      <button id="autoTestReportBtn" class="btn" disabled>Copy Auto‑Test Report</button>
      <button id="resetBtn" class="btn">Reset</button>
      <button id="clearLogsBtn" class="btn">Clear Logs</button>
      <button id="copyDiagBtn" class="btn" disabled>Copy Diagnostics</button>
    </div>

    <div class="controls">
      <div><label>Rotate (°)</label><input id="rotDeg" type="number" step="90" value="0" /></div>
      <div><label>Zoom (0.8–2.0): <span id="zoomLabel">1.20</span></label><input id="zoom" type="range" min="0.8" max="2.0" step="0.05" value="1.2" /></div>
      <div><label>Brightness: <span id="briLabel">1.10</span></label><input id="bri" type="range" min="0.8" max="1.4" step="0.02" value="1.10" /></div>
      <div><label>Contrast: <span id="conLabel">1.15</span></label><input id="con" type="range" min="0.8" max="1.6" step="0.02" value="1.15" /></div>

      <div>
        <label>Fix mode</label>
        <select id="fixMode">
          <option value="blazeonly" selected>BlazeFace only</option>
          <option value="cdn">face‑api refine</option>
          <option value="native">Native → Blaze fallback</option>
        </select>
      </div>
      <div>
        <label>Weights Source</label>
        <select id="weightsSrc">
          <option value="https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights" selected>jsDelivr (justadude)</option>
          <option value="https://rawcdn.githack.com/justadudewhohacks/face-api.js/0.22.2/weights">githack mirror</option>
          <option value="https://cdn.jsdelivr.net/gh/vladmandic/face-api/model">jsDelivr (vladmandic)</option>
          <option value="https://unpkg.com/face-api.js@0.22.2/weights">unpkg</option>
          <option value="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights">jsDelivr (npm)</option>
        </select>
      </div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <button id="precacheBtn" class="btn">Precache Weights (Offline)</button>
        <span id="swPill" title="Service Worker status">SW: —</span>
      </div>
      <label style="display:flex;gap:8px;align-items:center"><input id="showOverlays" type="checkbox" /> Show overlays</label>
      <label style="display:flex;gap:8px;align-items:center"><input id="showHUD" type="checkbox" /> Show HUD</label>
      <label style="display:flex;gap:8px;align-items:center"><input id="autoAnalyze" type="checkbox" /> Auto‑analyze</label>
    </div>

    <div id="progressContainer"><div id="progressBar"></div></div>
    <p id="progressText" style="font-size:12px;color:#A9B4C8;margin:6px 2px 0"></p>
  </div>

  <div class="card">
    <div class="two-col">
      <div class="previewWrap">
        <strong style="font-size:13px">Preview</strong>
        <img id="base" class="hidden previewSurface" alt="Preview base"/>
        <canvas id="overlayRough" class="hidden previewSurface"></canvas>
        <canvas id="overlay" class="hidden previewSurface"></canvas>
      </div>
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
          <strong style="font-size:13px">Diagnostics</strong>
          <div class="diag-tools">
            <input id="diagSearch" placeholder="filter…" style="padding:6px;border:1px solid #233046;border-radius:8px;background:#0b1220;color:#E6EAF2" />
            <label class="filter-chip"><input type="checkbox" class="diagType" value="detect" checked> detect</label>
            <label class="filter-chip"><input type="checkbox" class="diagType" value="overlay" checked> overlay</label>
            <label class="filter-chip"><input type="checkbox" class="diagType" value="analysis" checked> analysis</label>
            <label class="filter-chip"><input type="checkbox" class="diagType" value="config" checked> config</label>
            <label class="filter-chip"><input type="checkbox" class="diagType" value="error" checked> error</label>
            <label class="filter-chip"><input type="checkbox" class="diagType" value="test" checked> test</label>
          </div>
        </div>
        <div id="diagnostics">No diagnostics yet.</div>
        <div style="display:flex;gap:8px;margin-top:6px;flex-wrap:wrap">
          <button id="copyAllBtn" class="btn">Copy All Logs</button>
        </div>
      </div>
    </div>
  </div>

  <div class="card" id="analysisCard" style="display:none">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
      <strong>Analysis <span id="tsBadge" class="badge" title="timestamp"></span></strong>
      <div class="actions" style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="copyJsonBtn" class="btn" disabled>Copy JSON</button>
        <button id="exportJsonBtn" class="btn" disabled>Download JSON</button>
        <button id="sharePngBtn" class="btn" disabled>Share Snapshot</button>
      </div>
    </div>
    <div class="analysis-grid" style="margin-top:8px">
      <div class="kv"><span>Face area</span><span><b id="kv_area">—</b><span id="bdg_area" class="badge"></span></span></div>
      <div class="kv"><span>Aspect ratio</span><span><b id="kv_ar">—</b><span id="bdg_ar" class="badge"></span></span></div>
      <div class="kv"><span>Orientation</span><span><b id="kv_orient">—</b></span></div>
      <div class="kv"><span>Brightness (mean)</span><span><b id="kv_bri">—</b><span id="bdg_bri" class="badge"></span></span></div>
      <div class="kv"><span>Contrast (stdev)</span><span><b id="kv_contrast">—</b><span id="bdg_con" class="badge"></span></span></div>
      <div class="kv"><span>Sharpness (Laplacian var)</span><span><b id="kv_sharp">—</b><span id="bdg_sharp" class="badge"></span></span></div>
      <div class="kv"><span>Center offset X</span><span><b id="kv_offx">—</b><span id="bdg_offx" class="badge"></span></span></div>
      <div class="kv"><span>Center offset Y</span><span><b id="kv_offy">—</b><span id="bdg_offy" class="badge"></span></span></div>
    </div>
    <div class="hints" id="analysisHints"></div>
  </div>

  <div class="card" id="researchCard" style="display:none">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
      <strong>Research Mode</strong>
      <span class="hint">Opt‑in; saved locally only</span>
    </div>
    <div class="research-grid" style="margin-top:8px">
      <div>
        <label>Consent <span style="color:#fb7185">*</span></label>
        <select id="consent">
          <option value="">— Select —</option>
          <option value="yes">I consent to store this rating locally</option>
          <option value="no">No (don’t store)</option>
        </select>
      </div>
      <div>
        <label>Rater age group <span style="color:#fb7185">*</span></label>
        <select id="ageGroup">
          <option value="">— Select —</option>
          <option>20–24</option><option>25–29</option><option>30–34</option><option>35–39</option>
          <option>40–44</option><option>45–49</option><option>50–54</option><option>55–59</option>
          <option>60–64</option><option>65–69</option><option>70–74</option><option>75–80</option>
        </select>
      </div>
      <div>
        <label>Rater gender (optional)</label>
        <select id="raterGender">
          <option value="">Prefer not to say</option>
          <option>Female</option><option>Male</option><option>Nonbinary/Other</option>
        </select>
      </div>
      <div>
        <label>Attractiveness (1–10)</label>
        <input id="rating" type="range" min="1" max="10" step="1" value="5" />
      </div>
      <div>
        <label>Confidence (0–100%)</label>
        <input id="confidence" type="range" min="0" max="100" step="5" value="70" />
      </div>
      <div>
        <label>Notes (optional)</label>
        <textarea id="notes" placeholder="lighting, angle, makeup, beard, etc."></textarea>
      </div>
    </div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
      <button id="saveRowBtn" class="btn btn-primary" disabled>Save to Dataset</button>
      <button id="exportCSVBtn" class="btn" disabled>Export CSV</button>
      <button id="exportDSJsonBtn" class="btn" disabled>Export JSON</button>
      <span class="hint">Rows: <span id="dsCount">0</span></span>
    </div>
  </div>

  <footer>
    <div>Session: <span id="sessDet">0 detects</span> • <span id="sessAna">0 analyses</span> • avg detect <span id="sessAvg">—</span> ms</div>
    <div>Common hint: <span id="sessHint">—</span></div>
  </footer>
</div>

<script>
const REVISION="1.14.1-alpha"; document.getElementById("revText").textContent=REVISION;
const $=id=>document.getElementById(id);
const diagnostics=$("diagnostics");
function appendTop(s){ diagnostics.textContent = s + diagnostics.textContent; toggleCopyBtns() }
function logEvt(type,payload){ appendTop(`[${new Date().toISOString()}] ${JSON.stringify({type,...(payload||{})})}\n`) }

/*** Robust copy helpers ***/
async function copyTextRobust(text){
  if(text==null) text='';
  try{
    if(navigator.clipboard && window.isSecureContext){
      await navigator.clipboard.writeText(text);
      return {ok:true,via:'clipboard'};
    }
  }catch(_){}
  try{
    const ta=document.createElement('textarea');
    ta.value=text; ta.setAttribute('readonly',''); ta.style.position='fixed'; ta.style.opacity='0'; ta.style.left='-9999px';
    document.body.appendChild(ta); ta.select();
    const ok=document.execCommand('copy');
    document.body.removeChild(ta);
    if(ok) return {ok:true,via:'execCommand'};
  }catch(e){ return {ok:false,via:'fallback',err:e.message||String(e)} }
  return {ok:false,via:'none',err:'No clipboard available'};
}
function toggleCopyBtns(){
  const has = diagnostics && diagnostics.textContent && diagnostics.textContent.trim().length>0 && !diagnostics.textContent.includes('No diagnostics yet.');
  $("copyDiagBtn").disabled = !has;
  $("copyAllBtn").disabled = !has;
  $("autoTestReportBtn").disabled = !has || !__autoTestRunId;
}

/*** Global error hooks ***/
window.addEventListener('error', e=>logEvt('error',{global:e.message,at:(e.filename||'')+':'+(e.lineno||'')}));
window.addEventListener('unhandledrejection', e=>{ const r=e&&e.reason; logEvt('error',{unhandled:(r&&(r.message||r))||String(r)}) });

/*** UI refs ***/
const progressBar=$("progressBar"), progressText=$("progressText");
const imgBase=$("base"), cvRough=$("overlayRough"), cvOverlay=$("overlay");
const fileInput=$("fileInput"), sampleBtn=$("sampleBtn"), detectBtn=$("detectBtn"), startAnalysisBtn=$("startAnalysisBtn");
const enhanceBtn=$("enhanceBtn"), clearLogsBtn=$("clearLogsBtn"), resetBtn=$("resetBtn"), sharePngBtn=$("sharePngBtn");
const copyAllBtn=$("copyAllBtn"), copyDiagBtn=$("copyDiagBtn");
const rotDeg=$("rotDeg"), zoom=$("zoom"), zoomLabel=$("zoomLabel"), bri=$("bri"), briLabel=$("briLabel"), con=$("con"), conLabel=$("conLabel");
const fixModeSel=$("fixMode"), weightsSrc=$("weightsSrc"), precacheBtn=$("precacheBtn"), autoTestBtn=$("autoTestBtn"), autoTestReportBtn=$("autoTestReportBtn");
const swPill=$("swPill"); const veil=$("veil"), veilMsg=$("veilMsg");
const readinessBadge=$("readinessBadge");

/*** Research refs ***/
const researchCard=$("researchCard"), consentSel=$("consent"), ageGroupSel=$("ageGroup"), raterGenderSel=$("raterGender");
const ratingRange=$("rating"), confRange=$("confidence"), notesArea=$("notes");
const saveRowBtn=$("saveRowBtn"), exportCSVBtn=$("exportCSVBtn"), exportDSJsonBtn=$("exportDSJsonBtn"), dsCountEl=$("dsCount");

/*** Progress + badges ***/
function setProgress(p,t){progressBar.style.width=(p||0)+'%';progressText.textContent=t||''}
function showVeil(msg){ veilMsg.textContent=msg||'Frameworks loading…'; veil.style.display='flex' }
function hideVeil(){ veil.style.display='none' }
const waitFor=(cond,label,timeout=8000,int=100)=>new Promise((res,rej)=>{const t0=performance.now();const iv=setInterval(()=>{try{if(cond()){clearInterval(iv);res(true)}else if(performance.now()-t0>timeout){clearInterval(iv);rej(new Error(label+' timeout'))}}catch(e){clearInterval(iv);rej(e)}},int)});

/*** Session metrics ***/
let detTimes=[], anaCount=0, detCount=0, hintCounts={};
function updateFooter(){
  const avg = detTimes.length ? Math.round(detTimes.reduce((a,b)=>a+b,0)/detTimes.length) : '—';
  const common = Object.entries(hintCounts).sort((a,b)=>b[1]-a[1])[0]?.[0] || '—';
  $("sessDet").textContent=`${detCount} detects`; $("sessAna").textContent=`${anaCount} analyses`; $("sessAvg").textContent=avg; $("sessHint").textContent=common;
}

/*** TFJS/Models boot ***/
async function initFrameworks(){
  showVeil('Loading TensorFlow…');
  await waitFor(()=>window.tf,'tf presence',10000).catch(e=>{ logEvt('error',{tf_presence:e.message}); throw e });
  try{
    if (tf && tf.wasm) tf.wasm.setWasmPaths("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@3.21.0/dist/");
    await tf.setBackend('wasm'); await tf.ready();
    logEvt('config',{tf:'ready',backend:tf.getBackend()});
  }catch(e){
    logEvt('error',{tf_init:e.message||String(e)});
    try{ await tf.setBackend('webgl'); await tf.ready(); logEvt('config',{tf:'ready',backend:tf.getBackend(),fallback:'webgl'});}catch(e2){ logEvt('error',{tf_fallback:e2.message||String(e2)}); throw e2; }
  }
  showVeil('Loading BlazeFace…');
  await waitFor(()=>window.blazeface,'blazeface presence',8000).catch(e=>{ logEvt('error',{blaze_presence:e.message}); throw e });
  try{ window.__blazeModel=await window.blazeface.load(); logEvt("detect",{blazefaceReady:true}); }catch(e){ logEvt('error',{blazeface_load:e.message||String(e)}); throw e }
  await waitFor(()=>window.faceapi,'faceapi presence',8000).catch(e=>logEvt('error',{faceapi_presence:e.message}));
  hideVeil(); logEvt('config',{boot:'frameworks-ready'});
  detectBtn.disabled=false; enhanceBtn.disabled=false;
}

/*** SW helpers (precache UX) ***/
async function getSWReg(){ if(!('serviceWorker' in navigator)){ logEvt('error',{sw:'unsupported'}); return null } try{ const reg=await navigator.serviceWorker.register('./sw.js',{scope:'./'}); logEvt('config',{sw:'registered',scope:reg.scope||'n/a'}); return reg }catch(e){ logEvt('error',{sw_reg:String(e.message||e)}); return null } }
function setPrecacheLabel(txt, disabled=false){ $("precacheBtn").textContent = txt; $("precacheBtn").disabled = !!disabled }
async function getSWControllerStatus(){ try{ const reg=await navigator.serviceWorker.getRegistration(); return {supported:'serviceWorker' in navigator, registered:!!reg, controlling:!!navigator.serviceWorker.controller} }catch{ return {supported:false,registered:false,controlling:false} } }
function updateSWPillText(st){ $("swPill").textContent = !st.supported ? 'SW: unsupported' : !st.registered ? 'SW: none' : !st.controlling ? 'SW: registered (reload needed)' : 'SW: controlling' }
async function refreshSWPill(){ const st=await getSWControllerStatus(); updateSWPillText(st) }

/*** Images ***/
async function blobToCanvasViaImg(blob){ const url=URL.createObjectURL(blob); try{ const img=new Image(); img.decoding="sync"; img.loading="eager"; await new Promise((res,rej)=>{img.onload=res;img.onerror=rej;img.src=url}); const c=document.createElement("canvas"); c.width=img.naturalWidth; c.height=img.naturalHeight; c.getContext("2d").drawImage(img,0,0); return c } finally{ URL.revokeObjectURL(url) } }
async function decodeOriginal(fileOrBlob){
  try{ if('createImageBitmap' in window){ const bmp=await createImageBitmap(fileOrBlob); logEvt('detect',{decode:'createImageBitmap',w:bmp.width,h:bmp.height}); return {bitmap:bmp,width:bmp.width,height:bmp.height}; } }
  catch(e){ logEvt('error',{decode_createImageBitmap:e.message||String(e)}) }
  const can=await blobToCanvasViaImg(fileOrBlob); logEvt('detect',{decode:'blob->img',size_bytes:fileOrBlob.size||0}); return {canvas:can,width:can.width,height:can.height};
}

/*** Preview & overlay ***/
let baseSource=null, workCanvas=null, lastCanvas=null, lastBox=null, lastLandmarks=null, lastAnalysis=null;
function ensureWork(){ if(!workCanvas) workCanvas=document.createElement('canvas'); return workCanvas }
function syncOverlaySize(){ const w=imgBase.clientWidth,h=imgBase.clientHeight; if(!w||!h) return; [cvRough,cvOverlay].forEach(c=>{c.style.width=w+'px'; c.style.height=h+'px'}) }
let __rsTO=null; function onViewportResize(){ clearTimeout(__rsTO); __rsTO=setTimeout(syncOverlaySize,120) }
window.addEventListener('resize', onViewportResize); window.addEventListener('orientationchange', onViewportResize);
function paintBaseCanvas(canvas){ imgBase.src=canvas.toDataURL('image/png'); imgBase.classList.remove('hidden'); [cvRough,cvOverlay].forEach(c=>{c.width=canvas.width;c.height=canvas.height;c.classList.remove('hidden')}); syncOverlaySize(); logEvt('overlay',{painted:{w:canvas.width,h:canvas.height}}) }
function renderWorkingCanvas(maxSide=1024,centerBox=null){
  if(!baseSource){ logEvt('error',{render:'no baseSource'}); return null }
  const srcW0=baseSource.width, srcH0=baseSource.height;
  const angle=(parseInt(rotDeg.value,10)||0)%360; let z=parseFloat(zoom.value)||1.0;
  const br=parseFloat(bri.value)||1.0, cr=parseFloat(con.value)||1.0;
  const scale0=Math.min(1, maxSide/Math.max(srcW0,srcH0));
  const w0=Math.max(1,Math.round(srcW0*scale0)), h0=Math.max(1,Math.round(srcH0*scale0));
  let cx=srcW0/2, cy=srcH0/2;
  if(centerBox){
    cx=centerBox.x+centerBox.width/2; cy=centerBox.y+centerBox.height/2;
    const zx=(w0/(centerBox.width*scale0))*0.9, zy=(h0/(centerBox.height*scale0))*0.9; z=Math.max(z,Math.min(zx,zy,1.8));
    logEvt("overlay",{autoZoomApplied:+z.toFixed(2)});
  }
  const dstW=w0, dstH=h0, cropW=Math.round(dstW/(scale0*z)), cropH=Math.round(dstH/(scale0*z));
  const sx=Math.max(0,Math.round(cx-cropW/2)), sy=Math.max(0,Math.round(cy-cropH/2));
  const c=ensureWork(); if((angle%180)===0){c.width=dstW;c.height=dstH}else{c.width=dstH;c.height=dstW}
  const ctx=c.getContext('2d'); ctx.save(); ctx.clearRect(0,0,c.width,c.height);
  ctx.translate(c.width/2,c.height/2); ctx.rotate(angle*Math.PI/180);
  ctx.filter=`brightness(${br}) contrast(${cr})`;
  const src = baseSource.bitmap || baseSource.canvas;
  ctx.drawImage(src, sx,sy, Math.max(1,cropW),Math.max(1,cropH), -dstW/2,-dstH/2, dstW,dstH);
  ctx.restore();
  return c;
}

/*** Drawing ***/
function drawBox(ctx,box,color,label){ctx.strokeStyle=color;ctx.lineWidth=3;ctx.strokeRect(box.x,box.y,box.width,box.height);ctx.fillStyle=color;ctx.font="12px ui-monospace,monospace";ctx.fillText(label,box.x,Math.max(12,box.y-4))}
function drawCross(ctx,cx,cy,offX,offY){ctx.strokeStyle="#60a5fa";ctx.beginPath();ctx.moveTo(cx-8,cy);ctx.lineTo(cx+8,cy);ctx.moveTo(cx,cy-8);ctx.lineTo(cx,cy+8);ctx.stroke();ctx.fillStyle="#60a5fa";ctx.font="12px ui-monospace,monospace";const text=`(${Math.round(cx)},${Math.round(cy)}) | offX ${offX.toFixed(1)}% • offY ${offY.toFixed(1)}%`;const tx=Math.min(cx+10,cvOverlay.width-260),ty=Math.min(cy+14,cvOverlay.height-4);ctx.fillText(text,tx,ty)}
function drawLandmarks(ctx,landmarks){ try{ const pts=landmarks.positions||landmarks; ctx.fillStyle="#f472b6"; for(const p of pts){ ctx.fillRect(p.x-1,p.y-1,2,2) } }catch(_){} }

/*** Models ***/
let blazeModel=null; async function ensureBlaze(){ if(blazeModel) return; blazeModel=window.__blazeModel; }
async function headOK(url, max=2){ for(let i=0;i<max;i++){ try{ const r=await fetch(url,{method:'HEAD',cache:'no-store'}); return r.ok }catch(e){ await new Promise(r=>setTimeout(r,200)) } } return false }

/*** Face‑API loader with TF engine guard ***/
let faceApiReady=false, FA_BASE=null;
async function ensureFaceApi(){
  if(faceApiReady) return true;
  if(!window.faceapi){ logEvt('error',{faceapi_presence:'missing'}); return false }

  // Hard bind TF and verify engine availability
  try { faceapi.tf = tf } catch (_) {}
  let engineOk=false;
  try { engineOk = (faceapi.tf && typeof faceapi.tf.engine === "function" && !!faceapi.tf.engine()); }
  catch(e){ logEvt('error',{faceapi_engine:e.message||String(e)}) }
  if(!engineOk){ logEvt('error',{weightsBase:'tf-engine-missing'}); return false }

  const base=(weightsSrc.value||"").replace(/\/$/,"");
  FA_BASE=base;
  const mani1 = base+"/tiny_face_detector_model-weights_manifest.json";
  const mani2 = base+"/face_landmark_68_model-weights_manifest.json";
  const ok1 = await headOK(mani1); const ok2 = await headOK(mani2);
  logEvt('detect',{weightsHealth:{mani1:ok1,mani2:ok2,base}});
  if(!ok1 || !ok2){ logEvt('error',{weightsBase:'health-check-failed',base}); return false }

  try{
    await faceapi.nets.tinyFaceDetector.loadFromUri(base);
    await faceapi.nets.faceLandmark68Net.loadFromUri(base);
    faceApiReady=true; logEvt("detect",{faceapiReady:true,usingWeightsFrom:base});
    return true;
  }catch(e){
    logEvt('error',{faceapi_load:e.message||String(e)});
    return false;
  }
}

/*** Util ***/
function downsample(canvas,w,mirror=false){const h=Math.round(w*(canvas.height/canvas.width));const tmp=Object.assign(document.createElement("canvas"),{width:w,height:h});const ctx=tmp.getContext("2d");if(mirror){ctx.translate(w,0);ctx.scale(-1,1)}ctx.drawImage(canvas,0,0,w,h);return tmp}

/*** Detection flow ***/
async function detectFlow(){
  try{
    lastBox=null; lastCanvas=null; lastLandmarks=null; $("analysisCard").style.display="none"; researchCard.style.display="none";
    setProgress(10,"Analyzing…"); await ensureBlaze();
    let canvas=renderWorkingCanvas(1024); if(!canvas){ logEvt("error",{render:"failed"}); return }
    lastCanvas=canvas; paintBaseCanvas(canvas);

    const tinyW=160,tinyH=Math.round(tinyW*(canvas.height/canvas.width));
    const tmp=Object.assign(document.createElement("canvas"),{width:tinyW,height:tinyH});
    tmp.getContext("2d").drawImage(canvas,0,0,tinyW,tinyH);
    const t0=performance.now(); const faces=await blazeModel.estimateFaces(tmp,false); const ms=Math.round(performance.now()-t0);
    let rough=null;
    if(faces&&faces.length){
      const f=faces[0]; const tl=Array.isArray(f.topLeft)?f.topLeft:await f.topLeft.array(); const br=Array.isArray(f.bottomRight)?f.bottomRight:await f.bottomRight.array();
      const sx=canvas.width/tinyW, sy=canvas.height/tinyH; rough={x:tl[0]*sx,y:tl[1]*sy,width:(br[0]-tl[0])*sx,height:(br[1]-tl[1])*sy}; logEvt("detect",{roughLocate_ms:ms,box:rough});
      canvas=renderWorkingCanvas(1024,rough); lastCanvas=canvas; paintBaseCanvas(canvas);
    } else { logEvt("detect",{roughLocate_ms:ms,box:null}) }

    const cfgs=[{w:256,mirror:false},{w:384,mirror:false},{w:512,mirror:false},{w:384,mirror:true},{w:512,mirror:true}];
    let det=null;
    for(const cfg of cfgs){
      const tmp=downsample(canvas,cfg.w,cfg.mirror);
      const t0=performance.now(); const faces=await blazeModel.estimateFaces(tmp,false); const ms2=Math.round(performance.now()-t0);
      if(faces&&faces.length){
        const f=faces[0];
        const tl=Array.isArray(f.topLeft)?f.topLeft:await f.topLeft.array();
        const br=Array.isArray(f.bottomRight)?f.bottomRight:await f.bottomRight.array();
        const sx=canvas.width/tmp.width, sy=canvas.height/tmp.height;
        let x=tl[0]*sx, y=tl[1]*sy, w=(br[0]-tl[0])*sx, h=(br[1]-tl[1])*sy;
        if(cfg.mirror){ x=canvas.width-(x+w) }
        det={elapsed_ms:ms2,box:{x,y,width:w,height:h},scale:cfg.w,mirror:cfg.mirror};
        detTimes.push(ms2); detCount++; updateFooter();
        break;
      }
    }

    const octx=cvOverlay.getContext("2d"); octx.clearRect(0,0,cvOverlay.width,cvOverlay.height);
    if(!det){ logEvt("error",{msg:"BlazeFace found no face"}); setProgress(0,""); return }
    lastBox=det.box; drawBox(octx,lastBox,"#22c55e",`BlazeFace • ${det.elapsed_ms}ms`);
    const cx=lastBox.x+lastBox.width/2, cy=lastBox.y+lastBox.height/2; const offX=((cx-canvas.width/2)/(canvas.width/2))*100, offY=((cy-canvas.height/2)/(canvas.height/2))*100;
    drawCross(octx,cx,cy,offX,offY);
    logEvt("detect",{finalDetect_ms:det.elapsed_ms,scale:det.scale,mirror:det.mirror,box:lastBox});

    /* Refine (safe, patched) */
    if (fixModeSel.value === "cdn") {
      try {
        setProgress(75, "Refining (face‑api)…");
        const ok = await ensureFaceApi();
        if (!ok) {
          logEvt("detect", { refine_skipped: "faceapi not ready" });
        } else {
          // HARD BIND & ENGINE GUARD
          try { faceapi.tf = tf; } catch (_) {}
          let engineOk = false;
          try {
            engineOk = (faceapi.tf && typeof faceapi.tf.engine === "function" && !!faceapi.tf.engine());
          } catch (e) {
            logEvt("error", { refine_guard: "tf.engine() failed", msg: e.message || String(e) });
          }
          if (!engineOk) {
            logEvt("detect", { refine_guard: "tf binding missing/engine not available" });
          } else if (!lastCanvas) {
            logEvt("detect", { refine_skipped: "no canvas to refine" });
          } else {
            const opts = new faceapi.TinyFaceDetectorOptions({ inputSize: 256, scoreThreshold: 0.3 });
            const tR = performance.now();
            let result = null;
            try {
              result = await faceapi.detectSingleFace(lastCanvas, opts).withFaceLandmarks();
            } catch (e) {
              logEvt("error", { refine_exception: (e && (e.stack || e.message)) || String(e) });
            }
            const msR = Math.round(performance.now() - tR);

            if (result && result.detection && result.detection.box) {
              const b = result.detection.box;
              lastBox = { x: b.x, y: b.y, width: b.width, height: b.height };
              lastLandmarks = result.landmarks || null;

              octx.clearRect(0,0,cvOverlay.width,cvOverlay.height);
              drawBox(octx,lastBox,"#f59e0b",`Refined • ${msR}ms`);
              if(lastLandmarks) drawLandmarks(octx,lastLandmarks);

              const cx2=lastBox.x+lastBox.width/2, cy2=lastBox.y+lastBox.height/2;
              const offX2=((cx2-lastCanvas.width/2)/(lastCanvas.width/2))*100, offY2=((cy2-lastCanvas.height/2)/(lastCanvas.height/2))*100;
              drawCross(octx,cx2,cy2,offX2,offY2);

              logEvt("detect",{refine_ms:msR,faceapi:true,box:lastBox,landmarks:lastLandmarks?68:0});
            } else {
              logEvt("detect",{refine_ms:msR,faceapi:false,reason:"no detection"});
            }
          }
        }
      } catch (e) {
        const msg = (e && (e.stack || e.message)) || String(e);
        logEvt("error", { refine_exception_top: msg });
      }
    }

    setProgress(100,"Done."); $("readyBadge").style.display="inline-flex";
    startAnalysisBtn.disabled=false;
    if($("autoAnalyze").checked){ startAnalysisBtn.click(); }
  }catch(e){ logEvt("error",{detectFlow:e.message||String(e)}) }
}

/*** Lightweight analysis ***/
function runLightAnalysis(){
  if(!lastCanvas||!lastBox){ logEvt("error",{analysis:"no detection"}); return }
  const imgW=lastCanvas.width,imgH=lastCanvas.height,b=lastBox;
  const areaPct=(b.width*b.height)/(imgW*imgH)*100, ar=b.width/b.height;
  const orient = ar>=1.15 ? "landscape" : (ar<=0.87 ? "portrait" : "near-square");
  const cx=b.x+b.width/2, cy=b.y+b.height/2; const offX=((cx-imgW/2)/(imgW/2))*100, offY=((cy-imgH/2)/(imgH/2))*100;
  const crop=document.createElement("canvas"); crop.width=128; crop.height=128;
  crop.getContext("2d").drawImage(lastCanvas,Math.max(0,Math.round(b.x)),Math.max(0,Math.round(b.y)),Math.max(1,Math.round(b.width)),Math.max(1,Math.round(b.height)),0,0,128,128);
  const id=crop.getContext("2d").getImageData(0,0,128,128);
  let sum=0,sum2=0; for(let i=0;i<id.data.length;i+=4){const y=0.299*id.data[i]+0.587*id.data[i+1]+0.114*id.data[i+2]; sum+=y; sum2+=y*y}
  const mean=sum/(id.data.length/4), stdev=Math.sqrt(Math.max(0,(sum2/(id.data.length/4))-mean*mean));
  const gray=new Float32Array(128*128); for(let i=0,p=0;i<id.data.length;i+=4,p++){gray[p]=0.299*id.data[i]+0.587*id.data[i+1]+0.114*id.data[i+2]}
  let lapSum=0,lapSum2=0,count=0; for(let y=1;y<127;y++){for(let x=1;x<127;x++){const i=(y*128+x);const v=gray[i-128]+gray[i-1]-4*gray[i]+gray[i+1]+gray[i+128]; lapSum+=v; lapSum2+=v*v; count++;}}
  const lapVar=Math.max(0,(lapSum2/Math.max(1,count))-(lapSum/Math.max(1,count))**2);

  const okArea=areaPct>=7&&areaPct<=15, okBri=mean>=110&&mean<=160, okCon=stdev>=30&&stdev<=65, okSharp=lapVar>=120, okOffX=Math.abs(offX)<=12, okOffY=Math.abs(offY)<=12;

  $("analysisCard").style.display="";
  $("kv_area").textContent=areaPct.toFixed(2)+" %"; $("kv_ar").textContent=ar.toFixed(3); $("kv_orient").textContent=orient;
  $("kv_bri").textContent=mean.toFixed(1); $("kv_contrast").textContent=stdev.toFixed(1);
  $("kv_sharp").textContent=lapVar.toFixed(1);
  $("kv_offx").textContent=(offX>=0?"+":"")+offX.toFixed(1)+" %"; $("kv_offy").textContent=(offY>=0?"+":"")+offY.toFixed(1)+" %";

  function setBadge(el,ok,okTxt,badTxt){ el.textContent=ok?okTxt:badTxt; el.className="badge "+(ok?"ok":"warn") }
  setBadge($("bdg_area"),okArea,"ok","adjust"); setBadge($("bdg_bri"),okBri,"ok","±light"); setBadge($("bdg_con"),okCon,"ok","±contrast"); setBadge($("bdg_sharp"),okSharp,"crisp","blurry"); setBadge($("bdg_offx"),okOffX,"centered","offset"); setBadge($("bdg_offy"),okOffY,"centered","offset");
  const hints=[]; if(!okArea)hints.push("Adjust crop to ~7–15% face area"); if(!okBri)hints.push(mean<110?"Increase lighting":"Reduce brightness"); if(!okCon)hints.push(stdev<30?"Boost contrast":"Soften contrast"); if(!okSharp)hints.push("Reduce motion/clean lens"); if(!(okOffX&&okOffY))hints.push("Center the face");
  hints.forEach(h=> hintCounts[h]=(hintCounts[h]||0)+1); anaCount++; updateFooter();

  lastAnalysis={
    revision:REVISION,
    timestamp:new Date().toISOString(),
    image:{width:imgW,height:imgH},
    box:{x:+b.x.toFixed(2),y:+b.y.toFixed(2),width:+b.width.toFixed(2),height:+b.height.toFixed(2),area_pct:+areaPct.toFixed(4),aspect:+ar.toFixed(4),center:{x:+(b.x+b.width/2).toFixed(2),y:+(b.y+b.height/2).toFixed(2)},center_offset_pct:{x:+offX.toFixed(2),y:+offY.toFixed(2)}},
    lighting:{brightness_mean:+mean.toFixed(3),contrast_stdev:+stdev.toFixed(3)},
    sharpness:{laplacian_variance:+lapVar.toFixed(3)},
    orientation:orient,
    refine:{landmarks: lastLandmarks ? 68 : 0}
  };
  try{ localStorage.setItem("yorn_last_analysis", JSON.stringify(lastAnalysis)) }catch(_){}
  $("analysisHints").textContent="Hints: "+(hints.length?hints.join(" • "):"Looks good!");
  logEvt("analysis",{analysis:lastAnalysis});
  researchCard.style.display="";
  maybeEnableSave();
  $("copyJsonBtn").disabled=false; $("exportJsonBtn").disabled=false; $("sharePngBtn").disabled=false;
}

/*** Research dataset ***/
const DS_KEY='yorn_dataset_v1';
function loadDS(){ try{ return JSON.parse(localStorage.getItem(DS_KEY)||'[]') }catch(_){ return [] } }
function saveDS(rows){ try{ localStorage.setItem(DS_KEY, JSON.stringify(rows)) }catch(_){} }
function dsCount(){ const n=loadDS().length; dsCountEl.textContent=String(n); exportCSVBtn.disabled=n===0; exportDSJsonBtn.disabled=n===0; }
function maybeEnableSave(){ saveRowBtn.disabled = !(lastAnalysis && consentSel.value==='yes' && ageGroupSel.value) }
consentSel.addEventListener('change',maybeEnableSave); ageGroupSel.addEventListener('change',maybeEnableSave);
saveRowBtn.addEventListener('click', ()=>{
  if(!(lastAnalysis && consentSel.value==='yes' && ageGroupSel.value)){ logEvt('error',{research:'missing required fields'}); return }
  const row={ session_id: crypto.randomUUID ? crypto.randomUUID() : ('sess_'+Date.now()), created_at:new Date().toISOString(),
    rater:{age_group:ageGroupSel.value, gender:raterGenderSel.value||null, confidence_pct:+confRange.value},
    rating:+ratingRange.value, notes:(notesArea.value||'').trim()||null, analysis:lastAnalysis };
  const rows=loadDS(); rows.push(row); saveDS(rows); dsCount(); logEvt('analysis',{saved:true,row});
});
function toCSV(rows){ const esc=v=>(v==null?'':String(v).replace(/"/g,'"\"'));
  const hdr=['created_at','rater_age_group','rater_gender','confidence_pct','rating','notes','img_w','img_h','box_x','box_y','box_w','box_h','box_area_pct','box_aspect','center_x','center_y','off_x_pct','off_y_pct','brightness_mean','contrast_stdev','sharpness_var','orientation','landmarks','revision'];
  const lines=[hdr.join(',')];
  for(const r of rows){ const a=r.analysis||{}; const b=a.box||{center:{},center_offset_pct:{}}; const cells=[r.created_at,r.rater?.age_group,r.rater?.gender,r.rater?.confidence_pct,r.rating,r.notes,a.image?.width,a.image?.height,b.x,b.y,b.width,b.height,a.box?.area_pct,a.box?.aspect,b.center?.x,b.center?.y,b.center_offset_pct?.x,b.center_offset_pct?.y,a.lighting?.brightness_mean,a.lighting?.contrast_stdev,a.sharpness?.laplacian_variance,a.orientation,a.refine?.landmarks,a.revision].map(esc); lines.push(cells.map(v=>`"${v}"`).join(',')); }
  return lines.join('\n');
}
$("exportCSVBtn").addEventListener('click', ()=>{ const rows=loadDS(); if(!rows.length) return;
  const blob=new Blob([toCSV(rows)],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download=`yorn-dataset-${Date.now()}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); logEvt('config',{dataset:'csv_export',rows:rows.length}) });
$("exportDSJsonBtn").addEventListener('click', ()=>{ const rows=loadDS(); if(!rows.length) return;
  const blob=new Blob([JSON.stringify(rows,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download=`yorn-dataset-${Date.now()}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); logEvt('config',{dataset:'json_export',rows:rows.length}) });
dsCount();

/*** Copy/export & basic controls ***/
$("copyDiagBtn").onclick = async ()=>{ try{ const visible = diagnostics ? diagnostics.innerText : ''; const res = await copyTextRobust(visible); if(res.ok){ logEvt('config',{copiedDiagnostics:true,via:res.via,length:visible.length}); progressText.textContent='Diagnostics copied'; setTimeout(()=>progressText.textContent='',1200);} else { logEvt('error',{copyDiagnosticsError:res.err||'unknown',via:res.via}); } }catch(e){ logEvt('error',{copyDiagnosticsException:e.message||String(e)}) } };
$("copyAllBtn").onclick = async ()=>{ try{ const allLogs = diagnostics ? diagnostics.innerText : ''; const res = await copyTextRobust(allLogs); if(res.ok){ logEvt('config',{copiedAll:true,via:res.via,length:allLogs.length}); progressText.textContent='All logs copied'; setTimeout(()=>progressText.textContent='',1200);} else { logEvt('error',{copyAllError:res.err||'unknown',via:res.via}); } }catch(e){ logEvt('error',{copyAllException:e.message||String(e)}) } };

$("clearLogsBtn").addEventListener('click',()=>{ diagnostics.textContent='No diagnostics yet.'; toggleCopyBtns() });
$("resetBtn").addEventListener('click',()=>{ ["base"].forEach(id=>$(id).classList.add('hidden')); baseSource=null; lastCanvas=null; lastBox=null; lastLandmarks=null; $("analysisCard").style.display="none"; researchCard.style.display="none"; logEvt('config',{reset:true}) });
$("copyJsonBtn").addEventListener('click',async()=>{ try{ if(!lastAnalysis) return; const res = await copyTextRobust(JSON.stringify(lastAnalysis,null,2)); if(res.ok){ logEvt('config',{copiedJSON:true,via:res.via}); } }catch(e){ logEvt('error',{copyJSON:e.message||String(e)}) }});
$("exportJsonBtn").addEventListener('click',()=>{ try{ if(!lastAnalysis) return; const blob=new Blob([JSON.stringify(lastAnalysis,null,2)],{type:"application/json"}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`yorn-analysis-${Date.now()}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); logEvt('config',{downloadJSON:true}); }catch(e){ logEvt('error',{downloadJSON:e.message||String(e)}) }});
$("sharePngBtn").addEventListener('click',async()=>{ try{ if(!lastCanvas) return; const out=document.createElement('canvas'); out.width=lastCanvas.width; out.height=lastCanvas.height; const ctx=out.getContext('2d'); ctx.drawImage(lastCanvas,0,0); ctx.drawImage(cvOverlay,0,0); ctx.globalAlpha=0.85; ctx.fillStyle="#000000A0"; ctx.fillRect(out.width-240-10, out.height-32-10, 240, 28); ctx.globalAlpha=1; ctx.fillStyle="#E6EAF2"; ctx.font="12px ui-monospace,monospace"; ctx.fillText(`YorN ${REVISION} • ${new Date().toISOString().slice(0,19)}`, out.width-230-10, out.height-14-10); const blob=await new Promise(r=>out.toBlob(r,'image/png',0.92)); const file=new File([blob],'yorn-snapshot.png',{type:'image/png'}); if(navigator.canShare && navigator.canShare({files:[file]})){ await navigator.share({files:[file], title:'YorN Snapshot', text:'Face detection preview'}); logEvt('config',{share:'webshare'}); } else { const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`yorn-snapshot-${Date.now()}.png`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); logEvt('config',{share:'download'}) } }catch(e){ logEvt('error',{sharePNG:e.message||String(e)}) }});
zoom.addEventListener("input",()=>{ zoomLabel.textContent=(+zoom.value).toFixed(2); if(baseSource){ const c=renderWorkingCanvas(1024); lastCanvas=c; paintBaseCanvas(c) }});
bri.addEventListener("input",()=>{ briLabel.textContent=(+bri.value).toFixed(2); if(baseSource){ const c=renderWorkingCanvas(1024); lastCanvas=c; paintBaseCanvas(c) }});
con.addEventListener("input",()=>{ conLabel.textContent=(+con.value).toFixed(2); if(baseSource){ const c=renderWorkingCanvas(1024); lastCanvas=c; paintBaseCanvas(c) }});
$("rotDeg").addEventListener("change",()=>{ if(baseSource){ const c=renderWorkingCanvas(1024); lastCanvas=c; paintBaseCanvas(c) }});

/*** Buttons: detect & analysis ***/
$("enhanceBtn").addEventListener("click",()=>{ zoom.value=Math.max(+zoom.value,1.5); zoomLabel.textContent=(+zoom.value).toFixed(2); bri.value=Math.max(+bri.value,1.18); briLabel.textContent=(+bri.value).toFixed(2); con.value=Math.max(+con.value,1.25); conLabel.textContent=(+con.value).toFixed(2); detectFlow() });
$("detectBtn").addEventListener("click",()=>detectFlow());
$("startAnalysisBtn").addEventListener("click",()=>{ logEvt("analysis",{analysisRequested:true,mode:"light"}); runLightAnalysis() });

/*** Sample & file ***/
$("fileInput").addEventListener('change', async ()=>{
  if(!fileInput.files.length) return;
  const f=fileInput.files[0]; setProgress(8,'Decoding photo…');
  try{ baseSource = await decodeOriginal(f); const canvas = renderWorkingCanvas(1024); if(canvas){ paintBaseCanvas(canvas); setProgress(12,'Photo ready'); detectBtn.disabled=false; enhanceBtn.disabled=false; } }catch(e){ logEvt('error',{decode_failed:e.message||String(e)}) }
});
$("sampleBtn").addEventListener('click', async ()=>{
  try{
    setProgress(5,'Fetching sample…');
    const u="https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1000&auto=format&fit=crop";
    const res=await fetch(u,{cache:"no-store"}); if(!res.ok) throw new Error('HTTP '+res.status);
    const blob=await res.blob();
    baseSource = await decodeOriginal(blob);
    const canvas=renderWorkingCanvas(1024);
    if(canvas){ paintBaseCanvas(canvas); setProgress(12,'Sample ready'); detectBtn.disabled=false; enhanceBtn.disabled=false; }
    logEvt('detect',{sampleImage:u});
  }catch(e){ logEvt('error',{sample_failed:e.message||String(e)}) }
});

/*** Auto‑Test report + readiness ***/
let __autoTestRunId = null;
let __autoTestStartIdx = 0;
function getAllLogsText(){ return diagnostics ? diagnostics.innerText || diagnostics.textContent || '' : '' }
function buildAutoTestReport(){
  const full = getAllLogsText();
  const chunk = full.slice(__autoTestStartIdx);
  const revMatch = full.match(/"rev":"([^"]+)"/) || [];
  const backendMatch = full.match(/"backend":"([^"]+)"/) || [];
  const weightsBase = chunk.match(/"weightsHealth":\{[^}]*"base":"([^"]+)"/) || [];
  const refined = /"refine_ms":/.test(chunk) ? "yes" : /"refine_skipped"|"refine_guard"|"refine_exception"/.test(chunk) ? "attempted (fallback)" : "no";
  const passes = (chunk.match(/"test","step":"[^"]+","ok":true/g) || []).length;
  const fails  = (chunk.match(/"type":"error"/g) || []).length + (chunk.match(/"test","step":"fail"/g) || []).length;
  const summaryLine = `YorN ${revMatch[1]||'—'} • TF backend: ${backendMatch[1]||'—'} • refine: ${refined} • passes: ${passes} • fails: ${fails}`;
  const lines = chunk.split('\n').filter(l => /"type":"test"|"type":"detect"|"type":"analysis"|"type":"config"|"type":"error"/.test(l));
  return ['=== YorN Auto‑Test Report ===', summaryLine, weightsBase[1] ? `weights: ${weightsBase[1]}` : '', '', ...lines, '=== End Report ===', ''].filter(Boolean).join('\n');
}
$("autoTestReportBtn").onclick = async () => {
  try {
    const report = buildAutoTestReport();
    const res = await copyTextRobust(report);
    if (res.ok) {
      logEvt('config', { copiedAutoTestReport: true, via: res.via, length: report.length });
      progressText.textContent = 'Auto‑Test report copied';
      setTimeout(()=>progressText.textContent='', 1200);
    } else {
      logEvt('error', { copyAutoTestReportError: res.err || 'unknown', via: res.via });
    }
  } catch (e) {
    logEvt('error', { copyAutoTestReportException: e.message || String(e) });
  }
};
function setReadinessBadge(state, tooltip){
  readinessBadge.style.display='inline-flex';
  readinessBadge.className = '';
  readinessBadge.classList.add(state==='ready' ? 'ready' : 'blocked');
  readinessBadge.textContent = state==='ready' ? 'READY' : 'BLOCKED';
  readinessBadge.title = tooltip || '';
}

/*** Auto Test (instrumented) ***/
$("autoTestBtn").addEventListener('click', runAutoTest);
async function runAutoTest(){
  $("autoTestBtn").disabled = true;
  const oldFix = fixModeSel.value;
  const oldOver = $("showOverlays").checked;

  const fullBefore = getAllLogsText();
  __autoTestStartIdx = fullBefore.length;
  __autoTestRunId = crypto.randomUUID ? crypto.randomUUID() : ('run_'+Date.now());
  logEvt('test', { step:'begin', run: __autoTestRunId });

  let passes = 0, fails = 0;
  const tStart = performance.now();
  const tlog = (step, extra) => logEvt('test', { step, ...(extra||{}) });

  try{
    setProgress(3,'Auto Test: loading sample');
    await $("sampleBtn").click();
    await new Promise(r=>setTimeout(r,400));
    if(!baseSource){ fails++; tlog('sample', { ok:false, reason:'no baseSource' }); throw new Error('sample failed') }
    passes++; tlog('sample', { ok:true, dim:{w:baseSource.width, h:baseSource.height} });

    setProgress(20,'Auto Test: blaze detect');
    fixModeSel.value = 'blazeonly';
    await detectFlow();
    await new Promise(r=>setTimeout(r,300));
    if(!lastBox){ fails++; tlog('blaze_detect', { ok:false }); throw new Error('detect failed') }
    passes++; tlog('blaze_detect', { ok:true, box:lastBox });

    setProgress(55,'Auto Test: refine check');
    const base=(weightsSrc.value||"").replace(/\/$/,"");
    const okWeights = await headOK(base+"/tiny_face_detector_model-weights_manifest.json") && await headOK(base+"/face_landmark_68_model-weights_manifest.json");
    tlog('weights_health', { base, ok: okWeights });
    if (okWeights) {
      fixModeSel.value = 'cdn';
      await detectFlow();
      await new Promise(r=>setTimeout(r,300));
      const refined = !!lastLandmarks || !!lastBox;
      tlog('refine_attempt', { ok: refined, landmarks: !!lastLandmarks });
      passes += refined ? 1 : 0;
    } else {
      tlog('refine_skipped', 'weights unhealthy');
    }

    setProgress(80,'Auto Test: analysis');
    $("startAnalysisBtn").click();
    await new Promise(r=>setTimeout(r,250));
    if(!lastAnalysis){ fails++; tlog('analysis', { ok:false }); throw new Error('analysis failed') }
    passes++; tlog('analysis', {
      ok:true,
      summary:{
        area_pct:lastAnalysis.box.area_pct,
        brightness:lastAnalysis.lighting.brightness_mean,
        contrast:lastAnalysis.lighting.contrast_stdev,
        sharp:lastAnalysis.sharpness.laplacian_variance
      }
    });

    const ms = Math.round(performance.now()-tStart);
    setProgress(100,'Auto Test: complete');
    tlog('summary', { passes, fails, ms, revision: REVISION, backend: (tf && tf.getBackend && tf.getBackend()) || 'unknown' });
    setReadinessBadge((fails===0 && passes>=3) ? 'ready' : 'blocked', `passes=${passes} fails=${fails} • ${ms}ms`);

  } catch(e){
    tlog('fail', { error: e.message || String(e) });
    setReadinessBadge('blocked', e.message || 'Auto‑test failed');
  } finally {
    fixModeSel.value = oldFix;
    $("showOverlays").checked = oldOver;
    $("autoTestBtn").disabled = false;
    $("autoTestReportBtn").disabled = false;
    tlog('end', { run: __autoTestRunId });
    toggleCopyBtns();
  }
}

/*** Precache button ***/
$("precacheBtn").addEventListener('click', async ()=>{
  setPrecacheLabel('Precaching…', true);
  const reg = await getSWReg();
  if(reg && !navigator.serviceWorker.controller){
    logEvt('config',{sw_notice:'Reload once so SW controls this page'});
  }
  const base=(weightsSrc.value||"").replace(/\/$/,"");
  const list=[ 'tiny_face_detector_model-weights_manifest.json', 'face_landmark_68_model-weights_manifest.json' ].map(f=>`${base}/${f}`);
  for(const u of list){ try{ await fetch(u,{cache:'reload'}); }catch(e){ logEvt('error',{precache_fetch:u,msg:e.message||String(e)}) } }
  setPrecacheLabel('Cached ✓', false);
  await refreshSWPill();
});

/*** Init ***/
window.addEventListener('load', async ()=>{
  document.getElementById("revText").textContent=REVISION;
  logEvt('config',{boot:'ui-ready',rev:REVISION});
  await refreshSWPill();
  try{
    await initFrameworks();
    try{
      const saved=localStorage.getItem("yorn_last_analysis");
      if(saved){ const a=JSON.parse(saved); logEvt('analysis',{restored:true,analysis:a}); researchCard.style.display=""; }
    }catch(_){}
    logEvt('config',{boot:'frameworks-ready'});
    logEvt('config',{boot:'complete'});
  }catch(e){ document.getElementById('veil').style.display='flex'; document.getElementById('veilMsg').textContent='Framework init failed'; logEvt('error',{frameworks:e.message||String(e)}) }
});
<script>
/* Mirror Diagnostics → console (dev convenience) */
(() => {
  const __orig = window.logEvt;
  window.logEvt = function(type, payload){
    try { __orig(type, payload); } finally {
      try {
        const lvl = (type === 'error') ? 'error' : (type === 'config' ? 'info' : 'log');
        console[lvl](`[YorN] ${type}`, payload || {});
      } catch (_) {}
    }
  };
})();
</script>
</script>
</body>
</html>