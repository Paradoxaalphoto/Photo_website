<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>YorN 1.17.2-alpha</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#111; --panel:#1b1b1b; --card:#2a2a2a; --ink:#eee; --ok:#4caf50; --bad:#e53935; --mut:#9aa; --btn:#333;}
    * { box-sizing: border-box }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; background:var(--bg); color:var(--ink); margin:0 }
    header { background:#222; padding:12px 16px; display:flex; align-items:center; justify-content:space-between }
    h1 { margin:0; font-size:16px; font-weight:600 }
    #rev { opacity:.7; font-size:12px }
    main { padding:12px; display:flex; flex-direction:column; gap:12px }
    section { background:var(--panel); border-radius:10px; padding:12px }
    h2 { margin:0 0 .25rem 0; font-size:14px }
    .row { display:flex; flex-wrap:wrap; gap:8px }
    .card { background:var(--card); border-radius:8px; padding:8px; flex:1 1 240px; min-width:240px }
    button { background:var(--btn); color:var(--ink); border:0; border-radius:8px; padding:8px 12px; cursor:pointer }
    button.primary { background:var(--ok) }
    button.danger { background:var(--bad) }
    button:disabled { opacity:.5; cursor:not-allowed }
    select, input[type=text], textarea, input[type=number] { width:100%; background:#000; color:var(--ink); border:1px solid #444; border-radius:8px; padding:8px }
    label { display:block; font-size:12px; color:var(--mut); margin:6px 0 2px }
    pre { margin:0; background:#000; color:#0f0; border-radius:8px; padding:8px; max-height:240px; overflow:auto; white-space:pre-wrap; word-break:break-word }
    canvas, img { max-width:100%; border-radius:8px; display:block }
    .grid { display:grid; gap:8px }
    .grid.cols-2 { grid-template-columns: repeat(2, minmax(0,1fr)); }
    .kpi { display:flex; gap:8px; flex-wrap:wrap }
    .pill { background:#333; border-radius:999px; padding:4px 8px; font-size:12px }
    .hud { font-size:12px; color:var(--mut) }
    .controls { display:flex; gap:8px; flex-wrap:wrap }
    @media (max-width:640px){ .grid.cols-2 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <header>
    <h1>YorN</h1>
    <div id="rev">1.17.2‑alpha</div>
  </header>

  <main>
    <section class="grid cols-2">
      <div class="card">
        <h2>Image</h2>
        <div class="controls">
          <input id="fileInput" type="file" accept="image/*" />
          <button id="sampleBtn">Load Sample</button>
          <button id="detectBtn" class="primary" disabled>Detect</button>
          <button id="analyzeBtn" disabled>Analyze</button>
          <button id="resetBtn">Reset</button>
        </div>
        <div class="controls">
          <label>Rotate (°)<input id="rot" type="number" value="0" step="90"></label>
          <label>Zoom (0.8–2.0)<input id="zoom" type="number" value="1.2" step="0.1" min="0.8" max="2.0"></label>
          <label>Brightness<input id="bri" type="number" value="1.10" step="0.05" min="0.5" max="2"></label>
          <label>Contrast<input id="con" type="number" value="1.15" step="0.05" min="0.5" max="2"></label>
        </div>
        <canvas id="stage" width="1024" height="683"></canvas>
        <div class="hud" id="hud"></div>
      </div>

      <div class="card">
        <h2>Diagnostics</h2>
        <div class="controls">
          <button id="autoTestBtn" class="primary">Run Auto‑Test</button>
          <button id="copyAuto">Copy Auto‑Test</button>
          <button id="copyDiag">Copy Diagnostics</button>
          <button id="clearLogsBtn">Clear Logs</button>
        </div>
        <pre id="log">(empty)</pre>
      </div>
    </section>

    <section>
      <h2>Research Mode</h2>
      <div class="row">
        <div class="card">
          <label>Age Group
            <select id="ageGroup">
              <option value="">--</option>
              <option>20-24</option><option>25-29</option><option>30-34</option>
              <option>35-39</option><option>40-44</option><option>45-49</option>
              <option>50-54</option><option>55-59</option><option>60-64</option>
              <option>65-69</option><option>70-74</option><option>75-79</option>
            </select>
          </label>
          <label>Sex
            <select id="raterSex"><option value="">--</option><option>M</option><option>F</option><option>Prefer not</option></select>
          </label>
          <label>Region
            <input id="raterRegion" type="text" placeholder="Optional">
          </label>
        </div>
        <div class="card">
          <label>Attractiveness (1–7)
            <select id="rating"><option value="">--</option><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option></select>
          </label>
          <label><input type="checkbox" id="chkFollow"> Would follow</label><br>
          <label><input type="checkbox" id="chkHire"> Would hire</label><br>
          <label><input type="checkbox" id="chkDate"> Would date</label>
        </div>
        <div class="card">
          <label>Notes
            <textarea id="notes" maxlength="280" rows="5"></textarea>
          </label>
          <div class="kpi" id="badges"></div>
        </div>
      </div>
      <div class="controls">
        <button id="submitRow" class="primary" disabled>Submit Rating</button>
        <span class="hud" id="readyState"></span>
      </div>
    </section>

    <section>
      <h2>Dataset</h2>
      <div class="controls">
        <button id="exportCSV">Export CSV</button>
        <button id="exportJSON">Export JSON</button>
        <button id="copySummary">Copy Summary</button>
        <button id="clearDS" class="danger">Clear Dataset</button>
      </div>
      <pre id="dsSummary">(no rows yet)</pre>
    </section>
  </main>

  <script>
    const REVISION = "1.17.2-alpha";
    const logEl = document.getElementById('log');
    const hud = document.getElementById('hud');
    const badges = document.getElementById('badges');
    const stage = document.getElementById('stage');
    const ctx = stage.getContext('2d');

    function log(type, obj={}) {
      const line = JSON.stringify({ time:new Date().toISOString(), type, ...obj });
      logEl.textContent += (logEl.textContent==="(empty)" ? "" : "\n") + line;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setHUD(text){ hud.textContent = text || ""; }
    function copyText(text){
      if(!text) text="";
      if(navigator.clipboard && window.isSecureContext){
        return navigator.clipboard.writeText(text).catch(()=>fallbackCopy(text));
      }
      return fallbackCopy(text);
    }
    function fallbackCopy(text){
      try{
        const ta=document.createElement('textarea');
        ta.value=text; ta.setAttribute('readonly','');
        ta.style.position='fixed'; ta.style.opacity='0'; ta.style.left='-9999px';
        document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
      }catch(_){}
    }

    // Samples: keep SVG for boot visuals ONLY; face detection prefers photo URLs
    const SAMPLE_SVG = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" width="96" height="64">
  <defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
    <stop offset="0" stop-color="#8ec5ff"/><stop offset="1" stop-color="#ffd58e"/>
  </linearGradient></defs>
  <rect width="96" height="64" fill="url(#g)"/>
</svg>`);
    // For detection/analysis we prefer real photos first:
    const FACE_SAMPLE_URLS = [
      "https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1024&auto=format&fit=crop",
      "https://upload.wikimedia.org/wikipedia/commons/7/7c/Profile_avatar_placeholder_large.png",
      SAMPLE_SVG // last resort (will likely fail detect, but preserves boot)
    ];

    let baseBitmap = null;
    let lastBox = null;
    let lastAnalysis = null;

    const fileInput = document.getElementById('fileInput');
    const sampleBtn = document.getElementById('sampleBtn');
    const detectBtn = document.getElementById('detectBtn');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const resetBtn = document.getElementById('resetBtn');
    const rotEl = document.getElementById('rot');
    const zoomEl = document.getElementById('zoom');
    const briEl = document.getElementById('bri');
    const conEl = document.getElementById('con');

    [rotEl,zoomEl,briEl,conEl].forEach(el=>el.addEventListener('input', ()=>drawBase()));

    function drawBase(rot=+rotEl.value, zoom=+zoomEl.value, bri=+briEl.value, con=+conEl.value){
      ctx.save();
      ctx.clearRect(0,0,stage.width,stage.height);
      if(!baseBitmap){ ctx.restore(); return; }
      const tw = stage.width, th = stage.height;
      const iw = baseBitmap.width, ih = baseBitmap.height;
      const scale = Math.min(tw/iw, th/ih) * zoom;
      const dw = iw*scale, dh = ih*scale;
      const dx = (tw - dw)/2, dy = (th - dh)/2;

      ctx.translate(tw/2, th/2);
      ctx.rotate((rot * Math.PI)/180);
      ctx.translate(-tw/2, -th/2);
      ctx.drawImage(baseBitmap, dx, dy, dw, dh);

      try{
        const img = ctx.getImageData(0,0,tw,th);
        const d = img.data; const b = bri; const c = con;
        for(let i=0;i<d.length;i+=4){
          let r=d[i], g=d[i+1], b0=d[i+2];
          r = Math.max(0, Math.min(255, (c*(r-128)+128)*b));
          g = Math.max(0, Math.min(255, (c*(g-128)+128)*b));
          b0= Math.max(0, Math.min(255, (c*(b0-128)+128)*b));
          d[i]=r; d[i+1]=g; d[i+2]=b0;
        }
        ctx.putImageData(img,0,0);
      }catch(_){}
      ctx.restore();
    }

    async function decodeToBitmap(blob){
      try { if('createImageBitmap' in window) return await createImageBitmap(blob); }
      catch(_){}
      return new Promise((resolve, reject)=>{
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = ()=>{ resolve(img); URL.revokeObjectURL(url); };
        img.onerror = e=>{ URL.revokeObjectURL(url); reject(e); };
        img.src = url;
      });
    }

    async function loadFromUrl(url){
      let blob;
      if(url.startsWith('data:')){
        const res = await fetch(url); blob = await res.blob();
      } else {
        const res = await fetch(url, {cache:'no-store'}); if(!res.ok) throw new Error('HTTP '+res.status);
        blob = await res.blob();
      }
      baseBitmap = await decodeToBitmap(blob);
      drawBase();
      log('detect', { sampleImage:url });
      detectBtn.disabled = false; analyzeBtn.disabled = false;
      return true;
    }

    // Used by the UI “Load Sample” — starts with SVG then upgrades to photo
    async function loadSampleUI(){
      // try SVG first (always works), then upgrade to first photo silently
      let ok = false;
      try { ok = await loadFromUrl(SAMPLE_SVG); } catch(e){ log('error',{sample_failed:e.message||String(e)}); }
      // kick off a photo load in the background to get you ready for detect
      (async ()=>{
        for(const url of FACE_SAMPLE_URLS){
          if(url===SAMPLE_SVG) continue;
          try{ await loadFromUrl(url); setHUD('Sample photo ready'); break; }catch(_){}
        }
      })();
      return ok;
    }

    // Used by auto‑test / detection — prefers real face samples first
    async function loadFacePreferred(){
      for(const url of FACE_SAMPLE_URLS){
        try{
          await loadFromUrl(url);
          // If we just loaded the SVG, note it (we’ll retry with next source on detect failure)
          return url;
        }catch(e){
          log('error',{sample_failed:e.message||String(e), url});
        }
      }
      return null;
    }

    fileInput.addEventListener('change', async ()=>{
      if(!fileInput.files.length) return;
      const f=fileInput.files[0];
      try{
        baseBitmap = await decodeToBitmap(f);
        drawBase();
        detectBtn.disabled = false;
        analyzeBtn.disabled = false;
        log('detect', { fileName:f.name, size_bytes:f.size });
      }catch(e){
        log('error', { decode_failed:e.message||String(e) });
      }
    });

    sampleBtn.addEventListener('click', async ()=>{
      const ok = await loadSampleUI();
      setHUD(ok ? 'Sample loaded' : 'Sample failed');
    });

    resetBtn.addEventListener('click', ()=>{
      baseBitmap = null; lastBox = null; lastAnalysis = null;
      detectBtn.disabled = true; analyzeBtn.disabled = true;
      document.getElementById('submitRow').disabled = true;
      ctx.clearRect(0,0,stage.width,stage.height);
      badges.innerHTML = '';
      setHUD('');
      log('config', { reset:true });
    });

    let FaceAPI = null;
    async function ensureBlazeFace(){
      if(FaceAPI) return FaceAPI;
      const tfSrc = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js";
      const bfSrc = "https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js";
      await importScript(tfSrc);
      await importScript(bfSrc);
      const model = await window.blazeface.load();
      FaceAPI = { model, type:'blazeface' };
      log('detect', { blazefaceReady:true });
      return FaceAPI;
    }
    function importScript(src){
      return new Promise((resolve, reject)=>{
        const s=document.createElement('script');
        s.src=src; s.async=true; s.onload=()=>resolve(); s.onerror=()=>reject(new Error('load '+src));
        document.head.appendChild(s);
      });
    }
    function drawBox(box, color='#00e676'){
      ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 3;
      ctx.strokeRect(box.x, box.y, box.width, box.height); ctx.restore();
    }
    function imageDataMetrics(){
      const img = ctx.getImageData(0,0,stage.width,stage.height);
      const d = img.data; const n = d.length/4;
      let sum=0,sumSq=0;
      for(let i=0;i<d.length;i+=4){ const y=(0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]); sum+=y; sumSq+=y*y; }
      const mean=sum/n; const variance=(sumSq/n)-(mean*mean); const stdev=Math.sqrt(Math.max(0,variance));
      let lapVar=0; const w=stage.width,h=stage.height, step=4; const k=[0,1,0,1,-4,1,0,1,0];
      function Y(x,y){ const idx=((y*w)+x)*4; return (0.2126*d[idx]+0.7152*d[idx+1]+0.0722*d[idx+2])|0; }
      let acc=0,accSq=0,cnt=0;
      for(let y=1;y<h-1;y+=step){ for(let x=1;x<w-1;x+=step){
        const v=k[0]*Y(x-1,y-1)+k[1]*Y(x,y-1)+k[2]*Y(x+1,y-1)+k[3]*Y(x-1,y)+k[4]*Y(x,y)+k[5]*Y(x+1,y)+k[6]*Y(x-1,y+1)+k[7]*Y(x,y+1)+k[8]*Y(x+1,y+1);
        acc+=v; accSq+=v*v; cnt++;
      }}
      if(cnt){ const m=acc/cnt; lapVar=(accSq/cnt)-m*m; }
      return { brightness_mean:+mean.toFixed(3), contrast_stdev:+stdev.toFixed(3), laplacian_variance:+lapVar.toFixed(3) };
    }
    function currentBoxToPercent(box){
      const pct=(box.width*box.height)/(stage.width*stage.height)*100;
      const cx=box.x+box.width/2, cy=box.y+box.height/2;
      const offx=((cx-stage.width/2)/(stage.width/2))*100;
      const offy=((cy-stage.height/2)/(stage.height/2))*100;
      return { area_pct:+pct.toFixed(4), center:{x:+cx.toFixed(2), y:+cy.toFixed(2)}, center_offset_pct:{x:+offx.toFixed(2), y:+offy.toFixed(2)} };
    }

    async function detect(){
      setHUD('Detecting…');
      if(!baseBitmap){ setHUD(''); return false; }
      drawBase();

      if('FaceDetector' in window){
        try{
          const fd=new window.FaceDetector({fastMode:true,maxDetectedFaces:1});
          const blob=await (stage.convertToBlob?stage.convertToBlob():new Promise(r=>stage.toBlob(r)));
          const bmp=await decodeToBitmap(blob);
          const tmp=document.createElement('canvas'); tmp.width=bmp.width; tmp.height=bmp.height;
          tmp.getContext('2d').drawImage(bmp,0,0);
          const faces=await fd.detect(tmp);
          if(faces&&faces[0]&&faces[0].boundingBox){
            const b=faces[0].boundingBox;
            lastBox={x:b.x,y:b.y,width:b.width,height:b.height};
            drawBase(); drawBox(lastBox);
            log('detect',{nativeFace:true,box:lastBox});
            analyzeBtn.disabled=false; document.getElementById('submitRow').disabled=false;
            setHUD('Face detected (native)');
            return true;
          }
        }catch(e){ log('error',{nativeFaceDetector:e.message||String(e)}); }
      }

      try{
        const { model } = await ensureBlazeFace();
        const blob=await new Promise(res=>stage.toBlob(res));
        const bmp=await decodeToBitmap(blob);
        const c=document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height;
        c.getContext('2d').drawImage(bmp,0,0);
        const preds=await model.estimateFaces(c,false);
        if(preds && preds[0] && preds[0].topLeft && preds[0].bottomRight){
          const [x1,y1]=preds[0].topLeft; const [x2,y2]=preds[0].bottomRight;
          lastBox={x:x1,y:y1,width:(x2-x1),height:(y2-y1)};
          drawBase(); drawBox(lastBox,'#00e676');
          log('detect',{blazeface:true,box:lastBox});
          analyzeBtn.disabled=false; document.getElementById('submitRow').disabled=false;
          setHUD('Face detected');
          return true;
        } else {
          log('error',{detect:'no_face'});
          setHUD('No face found');
        }
      }catch(e){ log('error',{detect:e.message||String(e)}); setHUD('Detect error'); }
      return false;
    }

    async function analyze(){
      if(!baseBitmap || !lastBox){ setHUD('Detect first'); return false; }
      drawBase(); drawBox(lastBox);
      const metrics=imageDataMetrics(); const area=currentBoxToPercent(lastBox);
      lastAnalysis={
        revision:REVISION, timestamp:new Date().toISOString(),
        image:{width:stage.width,height:stage.height},
        box:{...lastBox,...area},
        lighting:{brightness_mean:metrics.brightness_mean,contrast_stdev:metrics.contrast_stdev},
        sharpness:{laplacian_variance:metrics.laplacian_variance},
        orientation:(stage.width>=stage.height?'landscape':'portrait'),
        refine:{}
      };
      badges.innerHTML='';
      const badge=t=>{ const s=document.createElement('span'); s.className='pill'; s.textContent=t; badges.appendChild(s); };
      badge(metrics.contrast_stdev>80?'Contrast: high':metrics.contrast_stdev<35?'Contrast: low':'Contrast: ok');
      badge(metrics.brightness_mean>170?'Bright':metrics.brightness_mean<90?'Dim':'Brightness: ok');
      badge(metrics.laplacian_variance>1200?'Sharpness: crisp':metrics.laplacian_variance<350?'Soft':'Sharpness: ok');
      log('analysis',{analysis:lastAnalysis}); setHUD('Analysis ready'); return true;
    }

    document.getElementById('detectBtn').addEventListener('click', detect);
    document.getElementById('analyzeBtn').addEventListener('click', analyze);

    // ===== Dataset =====
    let dataset = JSON.parse(localStorage.getItem('yornDataset')||'[]');
    function saveDS(){ localStorage.setItem('yornDataset', JSON.stringify(dataset)); updateSummary(); }
    function updateSummary(){
      const out=document.getElementById('dsSummary');
      if(!dataset.length){ out.textContent='(no rows yet)'; return; }
      const counts={}; for(const r of dataset){ const k=(r.rater_age||'–')+'|'+(r.rater_sex||'–'); counts[k]=(counts[k]||0)+1; }
      out.textContent='Rows: '+dataset.length+'\n'+JSON.stringify(counts,null,2);
    }
    updateSummary();

    document.getElementById('submitRow').addEventListener('click', ()=>{
      const row = {
        session_id:'sess-'+Date.now(), timestamp:new Date().toISOString(),
        photo_id:'local',
        box_x:lastBox?+lastBox.x.toFixed(2):0, box_y:lastBox?+lastBox.y.toFixed(2):0,
        box_w:lastBox?+lastBox.width.toFixed(2):0, box_h:lastBox?+lastBox.height.toFixed(2):0,
        face_area_pct:lastAnalysis?lastAnalysis.box.area_pct:0,
        brightness:lastAnalysis?lastAnalysis.lighting.brightness_mean:0,
        contrast:lastAnalysis?lastAnalysis.lighting.contrast_stdev:0,
        sharpness:lastAnalysis?lastAnalysis.sharpness.laplacian_variance:0,
        rater_age:ageGroup.value, rater_sex:raterSex.value, rater_region:raterRegion.value,
        rating_1to7:rating.value,
        would_follow:chkFollow.checked, would_hire:chkHire.checked, would_date:chkDate.checked,
        notes:notes.value, app_rev:REVISION, tf_backend:(window.tf&&tf.getBackend)?tf.getBackend():'n/a'
      };
      if(!row.rater_age || !row.rater_sex || !row.rating_1to7){ alert('Age group, sex, and rating are required.'); return; }
      if(!lastBox){ alert('Detect a face first.'); return; }
      dataset.push(row); saveDS(); log('dataset_add', row); setHUD('Rating saved');
    });

    document.getElementById('exportCSV').addEventListener('click', ()=>{
      if(!dataset.length){ alert('No rows'); return; }
      const headers=Object.keys(dataset[0]); const rows=[headers.join(',')];
      for(const r of dataset){ rows.push(headers.map(h=>typeof r[h]==='string'?JSON.stringify(r[h]):(r[h]??'')).join(',')); }
      copyText(rows.join('\n')); setHUD('CSV copied');
    });
    document.getElementById('exportJSON').addEventListener('click', ()=>{ copyText(JSON.stringify(dataset,null,2)); setHUD('JSON copied'); });
    document.getElementById('clearDS').addEventListener('click', ()=>{ if(confirm('Clear dataset?')){ dataset=[]; saveDS(); } });
    document.getElementById('copySummary').addEventListener('click', ()=>{ copyText(document.getElementById('dsSummary').textContent); setHUD('Summary copied'); });

    // ===== Diagnostics copy buttons =====
    document.getElementById('copyDiag').addEventListener('click', ()=>copyText(logEl.textContent));
    document.getElementById('copyAuto').addEventListener('click', ()=>{ copyText(buildAutoTestReport()); setHUD('Auto‑test copied'); });
    document.getElementById('clearLogsBtn').addEventListener('click', ()=>{ logEl.textContent='(empty)'; });

    // ===== Auto‑Test (now prefers face samples & retries) =====
    async function autoTest(){
      log('test', { step:'begin', rev:REVISION });

      // Load a photo sample first (avoid SVG)
      const used = await loadFacePreferred();
      const sampleOK = !!used;
      log('test', { step:'sample', ok:sampleOK });
      if(!sampleOK){ setHUD('Sample failed'); return; }

      // Try detect; if no face AND we used the SVG or first photo failed, rotate to next source
      let detOK = false, detMs = 0;
      for(let attempt=0; attempt<FACE_SAMPLE_URLS.length && !detOK; attempt++){
        const t0 = performance.now();
        detOK = await detect();
        detMs = Math.round(performance.now()-t0);
        if(!detOK){
          // try next sample source
          const current = FACE_SAMPLE_URLS.indexOf(used);
          const next = FACE_SAMPLE_URLS[current+1];
          if(next){ try{ await loadFromUrl(next); }catch(_){/*continue*/} }
        }
      }
      log('test', { step:'detect', ok:!!detOK, ms:detMs });

      const anOK = detOK ? await analyze() : false;
      log('test', { step:'analysis', ok:!!anOK });

      // dataset roundtrip (fake row)
      const before = dataset.length;
      dataset.push({
        session_id:'auto-'+Date.now(), timestamp:new Date().toISOString(),
        photo_id:'auto', box_x:1, box_y:2, box_w:3, box_h:4, face_area_pct:5,
        brightness:6, contrast:7, sharpness:8,
        rater_age:'25-29', rater_sex:'M', rater_region:'', rating_1to7:'4',
        would_follow:false, would_hire:false, would_date:false, notes:'',
        app_rev:REVISION, tf_backend:(window.tf && tf.getBackend)?tf.getBackend():'n/a'
      }); saveDS();
      const dsOK = dataset.length === before+1;
      log('test', { step:'dataset_write', ok:dsOK, rows:dataset.length });

      log('test', { step:'summary', ok: !!(sampleOK && detOK && anOK && dsOK) });
      setHUD('Auto‑test done');
    }
    function buildAutoTestReport(){
      const full = logEl.textContent || '';
      const passes = (full.match(/"step":"[^"]+","ok":true/g) || []).length;
      const errors = (full.match(/"type":"error"/g) || []).length;
      const detectMs = (full.match(/"step":"detect","ok":true,"ms":(\d+)/) || [])[1] || '—';
      return `=== YorN Auto‑Test Report ===
YorN ${REVISION} • TF backend: ${(window.tf&&tf.getBackend&&tf.getBackend())||'—'} • passes: ${passes} • errors: ${errors} • detect: ${detectMs} ms

` + full + `

=== End Report ===`;
    }
    document.getElementById('autoTestBtn').addEventListener('click', autoTest);

    // boot
    log('config', { boot:'dom-ready', rev:REVISION });
    log('config', { boot:'complete' });
  </script>
</body>
</html>