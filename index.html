<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>YorN — 1.12.6-alpha</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- CSP permits TFJS; WASM backend preferred -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:; img-src * data: blob:; connect-src * data: blob:; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'self'; frame-ancestors 'self'; upgrade-insecure-requests">
<meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">

<!-- ultra-early boot logger -->
<script>
(function(){
  window.__yornLogs = [];
  function push(type, payload){
    try{ window.__yornLogs.unshift(`[${new Date().toISOString()}] ${JSON.stringify({type, ...(payload||{})})}\n`) }catch(_){}
  }
  window.__yornBootLog = push;
  window.addEventListener('error', e=>push('error',{global:e.message,at:(e.filename||'')+':'+(e.lineno||'')}));
  window.addEventListener('unhandledrejection', e=>{const r=e&&e.reason; push('error',{unhandled:(r&&(r.message||r))||String(r)})});
  push('config',{boot:'starting', ua:navigator.userAgent});
})();
</script>

<style>
  :root{color-scheme:light dark}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,sans-serif;background:#0b1220;color:#e6eaf2;overflow-x:hidden}
  .container{max-width:980px;margin:0 auto;padding:16px}
  .card{background:#0f172a;border:1px solid #233046;border-radius:12px;padding:12px;margin-top:12px}
  .row{display:grid;grid-template-columns:1fr auto auto auto auto auto auto auto;gap:8px;align-items:end}
  .controls{display:grid;grid-template-columns:repeat(8,1fr);gap:8px;margin-top:8px}
  @media (max-width:720px){ .row{grid-template-columns:1fr;gap:10px} .controls{grid-template-columns:1fr 1fr;gap:10px} .two-col{grid-template-columns:1fr;gap:12px} }
  label{font-size:12px;color:#A9B4C8}
  input[type="range"],input[type="number"],select{width:100%;padding:6px;border:1px solid #233046;border-radius:8px;background:#0b1220;color:#E6EAF2}
  .btn{padding:10px 14px;border-radius:8px;border:1px solid #233046;background:#1f2937;color:#E6EAF2;cursor:pointer}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .btn-primary{background:#2563eb}
  #progressContainer{height:8px;background:#1e293b;border-radius:6px;overflow:hidden;margin-top:8px}
  #progressBar{height:100%;width:0;background:#38bdf8;transition:width .25s}
  .two-col{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .previewWrap{position:relative}
  #base,#overlayRough,#overlay{display:block;width:100%;height:auto;margin-top:10px;background:#0b1220;border:1px solid #233046;border-radius:8px}
  #overlayRough,#overlay{position:absolute;left:0;top:0}
  #diagnostics{white-space:pre-wrap;overflow-wrap:anywhere;word-break:break-word;font:12px ui-monospace,Menlo,Consolas,monospace;background:#0b1220;border:1px solid #233046;border-radius:8px;padding:8px;height:220px;max-height:40vh;overflow:auto}
  .diag-tools{display:flex;gap:8px;align-items:center;margin:6px 0;flex-wrap:wrap}
  .filter-chip{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border:1px solid #233046;border-radius:999px;background:#0b1220;font-size:12px}
  .analysis-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .kv{display:flex;justify-content:space-between;gap:8px;font-size:13px;padding:6px 8px;background:#0b1220;border:1px solid #233046;border-radius:8px}
  .kv b{color:#c7d2fe}
  .badge{font:12px ui-monospace,monospace;padding:1px 6px;border-radius:999px;border:1px solid #233046;margin-left:6px}
  .ok{background:rgba(16,185,129,.15);color:#a7f3d0;border-color:rgba(16,185,129,.55)}
  .warn{background:rgba(245,158,11,.15);color:#fde68a;border-color:rgba(245,158,11,.55)}
  #revBadge{position:fixed;top:8px;right:10px;z-index:9999;background:#0008;color:#fff;font:12px ui-monospace,monospace;padding:3px 8px;border:1px solid #fff3;border-radius:999px}
  #readyBadge{position:fixed;top:36px;right:10px;z-index:9999;display:none;background:#10b98126;color:#a7f3d0;font:12px ui-monospace,monospace;padding:3px 8px;border:1px solid #10b9818c;border-radius:999px}
  #readyDot{display:inline-block;width:8px;height:8px;border-radius:999px;background:#10b981;margin-right:6px}
  /* Loading veil */
  #veil{position:fixed;inset:0;background:#0b1220;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;z-index:10000}
  #veil .spin{width:28px;height:28px;border-radius:999px;border:3px solid #334155;border-top-color:#38bdf8;animation:sp 0.9s linear infinite}
  #veil .msg{color:#A9B4C8;font:13px ui-monospace,monospace}
  @keyframes sp{to{transform:rotate(360deg)}}
  footer{opacity:.8;font:12px ui-monospace,monospace;margin-top:10px;display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap}
</style>

<!-- libs (deferred) -->
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@3.21.0/dist/tf-backend-wasm.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js" crossorigin="anonymous"></script>
</head>
<body>
<div id="revBadge">YorN Rev <span id="revText"></span></div>
<div id="readyBadge"><span id="readyDot"></span><span id="readyText">Ready for Analysis</span></div>
<div id="veil"><div class="spin"></div><div class="msg" id="veilMsg">Frameworks loading…</div></div>

<div class="container">
  <h2>YorN — Face Detection & Lightweight Analysis</h2>

  <div class="card">
    <div class="row">
      <input id="fileInput" type="file" accept="image/*" />
      <button id="sampleBtn" class="btn">Load Sample</button>
      <button id="enhanceBtn" class="btn" disabled>Enhance & Retry</button>
      <button id="detectBtn" class="btn" disabled>Detect</button>
      <button id="startAnalysisBtn" class="btn btn-primary" disabled>Start Analysis</button>
      <button id="resetBtn" class="btn">Reset</button>
      <button id="clearLogsBtn" class="btn">Clear Logs</button>
      <button id="copyDiagBtn" class="btn" disabled>Copy Diagnostics</button>
    </div>

    <div class="controls">
      <div><label>Rotate (°)</label><input id="rotDeg" type="number" step="90" value="0" /></div>
      <div><label>Zoom (0.8–2.0): <span id="zoomLabel">1.20</span></label><input id="zoom" type="range" min="0.8" max="2.0" step="0.05" value="1.2" /></div>
      <div><label>Brightness: <span id="briLabel">1.10</span></label><input id="bri" type="range" min="0.8" max="1.4" step="0.02" value="1.10" /></div>
      <div><label>Contrast: <span id="conLabel">1.15</span></label><input id="con" type="range" min="0.8" max="1.6" step="0.02" value="1.15" /></div>

      <div>
        <label>Fix mode</label>
        <select id="fixMode">
          <option value="blazeonly" selected>BlazeFace only</option>
          <option value="cdn">face‑api refine</option>
          <option value="native">Native → Blaze fallback</option>
        </select>
      </div>
      <div>
        <label>Weights Source</label>
        <select id="weightsSrc">
          <option value="https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights" selected>jsDelivr (justadude)</option>
          <option value="https://rawcdn.githack.com/justadudewhohacks/face-api.js/0.22.2/weights">githack mirror</option>
          <option value="https://cdn.jsdelivr.net/gh/vladmandic/face-api/model">jsDelivr (vladmandic)</option>
          <option value="https://unpkg.com/face-api.js@0.22.2/weights">unpkg</option>
          <option value="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights">jsDelivr (npm)</option>
        </select>
      </div>
      <button id="precacheBtn" class="btn">Precache Weights (Offline)</button>
      <label style="display:flex;gap:8px;align-items:center"><input id="showOverlays" type="checkbox" /> Show overlays</label>
      <label style="display:flex;gap:8px;align-items:center"><input id="showHUD" type="checkbox" /> Show HUD</label>
      <label style="display:flex;gap:8px;align-items:center"><input id="autoAnalyze" type="checkbox" /> Auto‑analyze</label>
    </div>

    <div id="progressContainer"><div id="progressBar"></div></div>
    <p id="progressText" style="font-size:12px;color:#A9B4C8;margin:6px 2px 0"></p>
  </div>

  <div class="card">
    <div class="two-col">
      <div class="previewWrap">
        <strong style="font-size:13px">Preview</strong>
        <img id="base" class="hidden" alt="Preview base"/>
        <canvas id="overlayRough" class="hidden"></canvas>
        <canvas id="overlay" class="hidden"></canvas>
      </div>
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
          <strong style="font-size:13px">Diagnostics</strong>
          <div class="diag-tools">
            <input id="diagSearch" placeholder="filter…" style="padding:6px;border:1px solid #233046;border-radius:8px;background:#0b1220;color:#E6EAF2" />
            <label class="filter-chip"><input type="checkbox" class="diagType" value="detect" checked> detect</label>
            <label class="filter-chip"><input type="checkbox" class="diagType" value="overlay" checked> overlay</label>
            <label class="filter-chip"><input type="checkbox" class="diagType" value="analysis" checked> analysis</label>
            <label class="filter-chip"><input type="checkbox" class="diagType" value="config" checked> config</label>
            <label class="filter-chip"><input type="checkbox" class="diagType" value="error" checked> error</label>
          </div>
        </div>
        <div id="diagnostics">No diagnostics yet.</div>
        <div style="display:flex;gap:8px;margin-top:6px;flex-wrap:wrap">
          <button id="copyAllBtn" class="btn">Copy All Logs</button>
        </div>
      </div>
    </div>
  </div>

  <div class="card" id="analysisCard" style="display:none">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
      <strong>Analysis <span id="tsBadge" class="badge" title="timestamp"></span></strong>
      <div class="actions" style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="copyJsonBtn" class="btn" disabled>Copy JSON</button>
        <button id="exportJsonBtn" class="btn" disabled>Download JSON</button>
        <button id="sharePngBtn" class="btn" disabled>Share Snapshot</button>
      </div>
    </div>
    <div class="analysis-grid" style="margin-top:8px">
      <div class="kv"><span>Face area</span><span><b id="kv_area">—</b><span id="bdg_area" class="badge"></span></span></div>
      <div class="kv"><span>Aspect ratio</span><span><b id="kv_ar">—</b><span id="bdg_ar" class="badge"></span></span></div>
      <div class="kv"><span>Orientation</span><span><b id="kv_orient">—</b></span></div>
      <div class="kv"><span>Brightness (mean)</span><span><b id="kv_bri">—</b><span id="bdg_bri" class="badge"></span></span></div>
      <div class="kv"><span>Contrast (stdev)</span><span><b id="kv_contrast">—</b><span id="bdg_con" class="badge"></span></span></div>
      <div class="kv"><span>Sharpness (Laplacian var)</span><span><b id="kv_sharp">—</b><span id="bdg_sharp" class="badge"></span></span></div>
      <div class="kv"><span>Center offset X</span><span><b id="kv_offx">—</b><span id="bdg_offx" class="badge"></span></span></div>
      <div class="kv"><span>Center offset Y</span><span><b id="kv_offy">—</b><span id="bdg_offy" class="badge"></span></span></div>
    </div>
    <div class="hints" id="analysisHints"></div>
  </div>

  <footer>
    <div>Session: <span id="sessDet">0 detects</span> • <span id="sessAna">0 analyses</span> • avg detect <span id="sessAvg">—</span> ms</div>
    <div>Common hint: <span id="sessHint">—</span></div>
  </footer>
</div>

<script>
const REVISION="1.12.6-alpha"; document.getElementById("revText").textContent=REVISION;
const $=id=>document.getElementById(id);
const diagnostics=$("diagnostics"), copyDiagBtn=$("copyDiagBtn");
function appendTop(s){ diagnostics.textContent = s + diagnostics.textContent; toggleCopyBtns() }
function logEvt(type,payload){ appendTop(`[${new Date().toISOString()}] ${JSON.stringify({type,...(payload||{})})}\n`) }
function toggleCopyBtns(){ const empty = diagnostics.textContent.trim().length===0 || diagnostics.textContent.includes("No diagnostics yet."); $("copyDiagBtn").disabled=empty; $("copyAllBtn").disabled=empty }
;(function flushBoot(){ try{ if(Array.isArray(window.__yornLogs)&&window.__yornLogs.length){ appendTop(window.__yornLogs.join("")); window.__yornLogs.length=0 } logEvt('config',{boot:'ui-ready',rev:REVISION}); }catch(_){}})();
window.addEventListener('error', e=>logEvt('error',{global:e.message,at:(e.filename||'')+':'+(e.lineno||'')}));
window.addEventListener('unhandledrejection', e=>{ const r=e&&e.reason; logEvt('error',{unhandled:(r&&(r.message||r))||String(r)}) });

/* UI refs */
const progressBar=$("progressBar"), progressText=$("progressText");
const imgBase=$("base"), cvRough=$("overlayRough"), cvOverlay=$("overlay");
const fileInput=$("fileInput"), sampleBtn=$("sampleBtn"), detectBtn=$("detectBtn"), startAnalysisBtn=$("startAnalysisBtn");
const enhanceBtn=$("enhanceBtn"), clearLogsBtn=$("clearLogsBtn"), resetBtn=$("resetBtn"), sharePngBtn=$("sharePngBtn");
const copyAllBtn=$("copyAllBtn");
const rotDeg=$("rotDeg"), zoom=$("zoom"), zoomLabel=$("zoomLabel"), bri=$("bri"), briLabel=$("briLabel"), con=$("con"), conLabel=$("conLabel");
const fixModeSel=$("fixMode"), weightsSrc=$("weightsSrc"), precacheBtn=$("precacheBtn");
const showOverlaysChk=$("showOverlays"), showHUDChk=$("showHUD"), autoAnalyzeChk=$("autoAnalyze");
const veil=$("veil"), veilMsg=$("veilMsg");

/* helpers */
function setProgress(p,t){progressBar.style.width=(p||0)+'%';progressText.textContent=t||''}
function showVeil(msg){ veilMsg.textContent=msg||'Frameworks loading…'; veil.style.display='flex' }
function hideVeil(){ veil.style.display='none' }
const waitFor=(cond,label,timeout=8000,int=100)=>new Promise((res,rej)=>{const t0=performance.now();const iv=setInterval(()=>{try{if(cond()){clearInterval(iv);res(true)}else if(performance.now()-t0>timeout){clearInterval(iv);rej(new Error(label+' timeout'))}}catch(e){clearInterval(iv);rej(e)}},int)});

/* session metrics */
let detTimes=[], anaCount=0, detCount=0, hintCounts={};
function updateFooter(){
  const avg = detTimes.length ? Math.round(detTimes.reduce((a,b)=>a+b,0)/detTimes.length) : '—';
  const common = Object.entries(hintCounts).sort((a,b)=>b[1]-a[1])[0]?.[0] || '—';
  $("sessDet").textContent=`${detCount} detects`; $("sessAna").textContent=`${anaCount} analyses`; $("sessAvg").textContent=avg; $("sessHint").textContent=common;
}

/* TFJS/Models boot */
async function initFrameworks(){
  showVeil('Loading TensorFlow…');
  await waitFor(()=>window.tf,'tf presence',10000).catch(e=>{ logEvt('error',{tf_presence:e.message}); throw e });
  try{
    if (tf && tf.wasm) tf.wasm.setWasmPaths("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@3.21.0/dist/");
    await tf.setBackend('wasm'); await tf.ready();
    logEvt('config',{tf:'ready',backend:tf.getBackend()});
  }catch(e){
    logEvt('error',{tf_init:e.message||String(e)});
    try{ await tf.setBackend('webgl'); await tf.ready(); logEvt('config',{tf:'ready',backend:tf.getBackend(),fallback:'webgl'});}catch(e2){ logEvt('error',{tf_fallback:e2.message||String(e2)}); throw e2; }
  }
  showVeil('Loading BlazeFace…');
  await waitFor(()=>window.blazeface,'blazeface presence',8000).catch(e=>{ logEvt('error',{blaze_presence:e.message}); throw e });
  try{ window.__blazeModel=await window.blazeface.load(); logEvt("detect",{blazefaceReady:true}); }catch(e){ logEvt('error',{blazeface_load:e.message||String(e)}); throw e }
  await waitFor(()=>window.faceapi,'faceapi presence',8000).catch(e=>logEvt('error',{faceapi_presence:e.message}));
  hideVeil(); logEvt('config',{boot:'frameworks-ready'});
  detectBtn.disabled=false; enhanceBtn.disabled=false;
}

/* robust fetch */
async function fetchJsonRetry(url, max=3){
  let err; for(let i=0;i<max;i++){ try{ const r=await fetch(url,{cache:"no-store"}); if(!r.ok) throw new Error('HTTP '+r.status); return await r.json() }catch(e){ err=e; logEvt('error',{fetch:url,attempt:i+1,msg:e.message}); await new Promise(r=>setTimeout(r, 300*Math.pow(2,i))) } }
  throw err;
}
async function headOK(url, max=2){
  for(let i=0;i<max;i++){ try{ const r=await fetch(url,{method:'HEAD',cache:'no-store'}); return r.ok }catch(e){ await new Promise(r=>setTimeout(r,200)) } }
  return false;
}

/* face-api weights handling */
let faceApiReady=false, FA_BASE=null;
async function ensureFaceApi(){
  if(faceApiReady) return;
  const base=(weightsSrc.value||"").replace(/\/$/,"");
  FA_BASE=base;
  // health check manifests
  const mani1 = base+"/tiny_face_detector_model-weights_manifest.json";
  const mani2 = base+"/face_landmark_68_model-weights_manifest.json";
  const ok1 = await headOK(mani1); const ok2 = await headOK(mani2);
  logEvt('detect',{weightsHealth:{mani1:ok1,mani2:ok2,base}});
  if(!ok1 || !ok2) logEvt('error',{weightsBase:'health-check-failed',base});
  // load nets with retry
  await faceapi.nets.tinyFaceDetector.loadFromUri(base);
  await faceapi.nets.faceLandmark68Net.loadFromUri(base);
  faceApiReady=true; logEvt("detect",{faceapiReady:true,usingWeightsFrom:base});
}

/* Offline mode via Service Worker */
async function registerSW(){
  if(!('serviceWorker' in navigator)) { logEvt('error',{sw:'unsupported'}); return null }
  const swCode = `
    const CACHE='yorn-weights-v1';
    let cacheFirst=false;
    self.addEventListener('install',e=>{ self.skipWaiting() });
    self.addEventListener('activate',e=>{ e.waitUntil(clients.claim()) });
    async function addAll(urls){ const c=await caches.open(CACHE); await c.addAll(urls) }
    self.addEventListener('message', async e=>{
      const {type,urls,mode}=e.data||{};
      if(type==='PRECACHE' && Array.isArray(urls)){ try{ await addAll(urls); e.source.postMessage({type:'PRECACHE_OK',count:urls.length}) }catch(err){ e.source.postMessage({type:'PRECACHE_ERR',msg:String(err)}) } }
      if(type==='MODE'){ cacheFirst = (mode==='cache-first'); e.source.postMessage({type:'MODE_SET',mode}) }
    });
    self.addEventListener('fetch', e=>{
      const u=new URL(e.request.url);
      // only intercept model assets (CDNs allowed)
      const match = /face-api|tfjs-backend-wasm|\/weights\//.test(u.href);
      if(!match || e.request.method!=='GET'){ return }
      if(cacheFirst){
        e.respondWith( (async()=>{ const c=await caches.open(CACHE); const hit=await c.match(e.request); if(hit) return hit; const resp=await fetch(e.request); if(resp.ok) c.put(e.request, resp.clone()); return resp })() );
      }
    });
  `;
  const blob=new Blob([swCode],{type:'text/javascript'});
  const url=URL.createObjectURL(blob);
  try{
    const reg = await navigator.serviceWorker.register(url, {scope: './'});
    logEvt('config',{sw:'registered'});
    // set mode to cache-first once we precache
    return reg;
  }catch(e){ logEvt('error',{sw_reg:e.message||String(e)}); return null }
}
async function precacheWeights(){
  try{
    const base=(weightsSrc.value||"").replace(/\/$/,"");
    const mani1 = base+"/tiny_face_detector_model-weights_manifest.json";
    const mani2 = base+"/face_landmark_68_model-weights_manifest.json";
    const m1 = await fetchJsonRetry(mani1); const m2 = await fetchJsonRetry(mani2);
    const urls=[mani1, mani2];
    for(const m of [m1,m2]) (m.weights||[]).forEach(w=> (w.paths||[]).forEach(p=> urls.push(base+'/'+p)));
    let reg = await navigator.serviceWorker.getRegistration();
    if(!reg) reg = await registerSW();
    if(!reg || !navigator.serviceWorker.controller){ logEvt('error',{sw:'no-controller'}); return }
    const ch = new MessageChannel();
    ch.port1.onmessage = ev => {
      logEvt('config',ev.data||{});
    };
    reg.active.postMessage({type:'PRECACHE',urls}, [ch.port2]);
    // enable cache-first mode
    const ch2 = new MessageChannel();
    ch2.port1.onmessage = ev => logEvt('config',ev.data||{});
    reg.active.postMessage({type:'MODE',mode:'cache-first'}, [ch2.port2]);
    logEvt('config',{sw_precache:'sent',count:urls.length,base});
  }catch(e){ logEvt('error',{precache:e.message||String(e)}) }
}

/* decode */
async function blobToCanvasViaImg(blob){ const url=URL.createObjectURL(blob); try{ const img=new Image(); img.decoding="sync"; img.loading="eager"; await new Promise((res,rej)=>{img.onload=res;img.onerror=rej;img.src=url}); const c=document.createElement("canvas"); c.width=img.naturalWidth; c.height=img.naturalHeight; c.getContext("2d").drawImage(img,0,0); return c } finally{ URL.revokeObjectURL(url) } }
async function decodeOriginal(fileOrBlob){
  try{ if('createImageBitmap' in window){ const bmp=await createImageBitmap(fileOrBlob); logEvt('detect',{decode:'createImageBitmap',w:bmp.width,h:bmp.height}); return {bitmap:bmp,width:bmp.width,height:bmp.height}; } }
  catch(e){ logEvt('error',{decode_createImageBitmap:e.message||String(e)}) }
  const can=await blobToCanvasViaImg(fileOrBlob); logEvt('detect',{decode:'img→canvas',w:can.width,h:can.height}); return {canvas:can,width:can.width,height:can.height};
}

/* render */
let baseSource=null, workCanvas=null, lastCanvas=null, lastBox=null, lastLandmarks=null, lastAnalysis=null;
function ensureWork(){ if(!workCanvas) workCanvas=document.createElement('canvas'); return workCanvas }
function paintBaseCanvas(canvas){ imgBase.src=canvas.toDataURL('image/png'); imgBase.classList.remove('hidden'); [cvRough,cvOverlay].forEach(c=>{c.width=canvas.width;c.height=canvas.height;c.classList.remove('hidden')}); logEvt('overlay',{painted:{w:canvas.width,h:canvas.height}}) }
function renderWorkingCanvas(maxSide=1024,centerBox=null){
  if(!baseSource){ logEvt('error',{render:'no baseSource'}); return null; }
  const srcW0=baseSource.width, srcH0=baseSource.height;
  const angle=(parseInt(rotDeg.value,10)||0)%360; let z=parseFloat(zoom.value)||1.0;
  const br=parseFloat(bri.value)||1.0, cr=parseFloat(con.value)||1.0;
  const scale0=Math.min(1, maxSide/Math.max(srcW0,srcH0));
  const w0=Math.max(1,Math.round(srcW0*scale0)), h0=Math.max(1,Math.round(srcH0*scale0));
  let cx=srcW0/2, cy=srcH0/2;
  if(centerBox){
    cx=centerBox.x+centerBox.width/2; cy=centerBox.y+centerBox.height/2;
    const zx=(w0/(centerBox.width*scale0))*0.9, zy=(h0/(centerBox.height*scale0))*0.9; z=Math.max(z,Math.min(zx,zy,1.8));
    logEvt("overlay",{autoZoomApplied:+z.toFixed(2)});
  }
  const dstW=w0, dstH=h0, cropW=Math.round(dstW/(scale0*z)), cropH=Math.round(dstH/(scale0*z));
  const sx=Math.max(0,Math.round(cx-cropW/2)), sy=Math.max(0,Math.round(cy-cropH/2));
  const c=ensureWork(); if((angle%180)===0){c.width=dstW;c.height=dstH}else{c.width=dstH;c.height=dstW}
  const ctx=c.getContext('2d'); ctx.save(); ctx.clearRect(0,0,c.width,c.height);
  ctx.translate(c.width/2,c.height/2); ctx.rotate(angle*Math.PI/180);
  ctx.filter=`brightness(${br}) contrast(${cr})`;
  const src = baseSource.bitmap || baseSource.canvas;
  ctx.drawImage(src, sx,sy, Math.max(1,cropW),Math.max(1,cropH), -dstW/2,-dstH/2, dstW,dstH);
  ctx.restore();
  return c;
}

/* detection helpers */
let blazeModel=null;
async function ensureBlaze(){ if(blazeModel) return; blazeModel=window.__blazeModel; }
function downsample(canvas,w,mirror=false){const h=Math.round(w*(canvas.height/canvas.width));const tmp=Object.assign(document.createElement("canvas"),{width:w,height:h});const ctx=tmp.getContext("2d");if(mirror){ctx.translate(w,0);ctx.scale(-1,1)}ctx.drawImage(canvas,0,0,w,h);return tmp}

/* overlays */
function drawBox(ctx,box,color,label){ctx.strokeStyle=color;ctx.lineWidth=3;ctx.strokeRect(box.x,box.y,box.width,box.height);ctx.fillStyle=color;ctx.font="12px ui-monospace,monospace";ctx.fillText(label,box.x,Math.max(12,box.y-4))}
function drawCross(ctx,cx,cy,offX,offY){ctx.strokeStyle="#60a5fa";ctx.beginPath();ctx.moveTo(cx-8,cy);ctx.lineTo(cx+8,cy);ctx.moveTo(cx,cy-8);ctx.lineTo(cx,cy+8);ctx.stroke();ctx.fillStyle="#60a5fa";ctx.font="12px ui-monospace,monospace";const text=`(${Math.round(cx)},${Math.round(cy)}) | offX ${offX.toFixed(1)}% • offY ${offY.toFixed(1)}%`;const tx=Math.min(cx+10,cvOverlay.width-260),ty=Math.min(cy+14,cvOverlay.height-4);ctx.fillText(text,tx,ty)}
function drawLandmarks(ctx,landmarks){ try{ const pts=landmarks.positions||landmarks; ctx.fillStyle="#f472b6"; for(const p of pts){ ctx.fillRect(p.x-1,p.y-1,2,2) } }catch(_){} }

/* main detect flow */
async function detectFlow(){
  try{
    lastBox=null; lastCanvas=null; lastLandmarks=null; $("analysisCard").style.display="none";
    setProgress(10,"Analyzing…"); await ensureBlaze();
    let canvas=renderWorkingCanvas(1024); if(!canvas){ logEvt("error",{render:"failed"}); return }
    lastCanvas=canvas; paintBaseCanvas(canvas);

    // rough locate via BlazeFace
    const tinyW=160,tinyH=Math.round(tinyW*(canvas.height/canvas.width));
    const tmp=Object.assign(document.createElement("canvas"),{width:tinyW,height:tinyH});
    tmp.getContext("2d").drawImage(canvas,0,0,tinyW,tinyH);
    const t0=performance.now(); const faces=await blazeModel.estimateFaces(tmp,false); const ms=Math.round(performance.now()-t0);
    let rough=null;
    if(faces&&faces.length){
      const f=faces[0]; const tl=Array.isArray(f.topLeft)?f.topLeft:await f.topLeft.array(); const br=Array.isArray(f.bottomRight)?f.bottomRight:await f.bottomRight.array();
      const sx=canvas.width/tinyW, sy=canvas.height/tinyH; rough={x:tl[0]*sx,y:tl[1]*sy,width:(br[0]-tl[0])*sx,height:(br[1]-tl[1])*sy}; logEvt("detect",{roughLocate_ms:ms,box:rough});
      canvas=renderWorkingCanvas(1024,rough); lastCanvas=canvas; paintBaseCanvas(canvas);
    } else { logEvt("detect",{roughLocate_ms:ms,box:null}) }

    // final multiscale Blaze
    const cfgs=[{w:256,mirror:false},{w:384,mirror:false},{w:512,mirror:false},{w:384,mirror:true},{w:512,mirror:true}];
    let det=null;
    for(const cfg of cfgs){
      const tmp=downsample(canvas,cfg.w,cfg.mirror);
      const t0=performance.now(); const faces=await blazeModel.estimateFaces(tmp,false); const ms2=Math.round(performance.now()-t0);
      if(faces&&faces.length){
        const f=faces[0];
        const tl=Array.isArray(f.topLeft)?f.topLeft:await f.topLeft.array();
        const br=Array.isArray(f.bottomRight)?f.bottomRight:await f.bottomRight.array();
        const sx=canvas.width/tmp.width, sy=canvas.height/tmp.height;
        let x=tl[0]*sx, y=tl[1]*sy, w=(br[0]-tl[0])*sx, h=(br[1]-tl[1])*sy;
        if(cfg.mirror){ x=canvas.width-(x+w) }
        det={elapsed_ms:ms2,box:{x,y,width:w,height:h},scale:cfg.w,mirror:cfg.mirror};
        detTimes.push(ms2); detCount++; updateFooter();
        break;
      }
    }

    const octx=cvOverlay.getContext("2d"); octx.clearRect(0,0,cvOverlay.width,cvOverlay.height);
    if(!det){ logEvt("error",{msg:"BlazeFace found no face"}); setProgress(0,""); return }
    lastBox=det.box; drawBox(octx,lastBox,"#22c55e",`BlazeFace • ${det.elapsed_ms}ms`);
    const cx=lastBox.x+lastBox.width/2, cy=lastBox.y+lastBox.height/2; const offX=((cx-canvas.width/2)/(canvas.width/2))*100, offY=((cy-canvas.height/2)/(canvas.height/2))*100;
    drawCross(octx,cx,cy,offX,offY);
    logEvt("detect",{finalDetect_ms:det.elapsed_ms,scale:det.scale,mirror:det.mirror,box:lastBox});

    // Optional refine with face-api
    if(fixModeSel.value==="cdn"){
      try{
        setProgress(75,"Refining (face‑api)…");
        await ensureFaceApi();
        const opts=new faceapi.TinyFaceDetectorOptions({ inputSize:256, scoreThreshold:0.3 });
        const tR=performance.now();
        const result=await faceapi.detectSingleFace(lastCanvas, opts).withFaceLandmarks();
        const msR=Math.round(performance.now()-tR);
        if(result){
          const b=result.detection.box;
          lastBox={x:b.x,y:b.y,width:b.width,height:b.height};
          lastLandmarks=result.landmarks;
          octx.clearRect(0,0,cvOverlay.width,cvOverlay.height);
          drawBox(octx,lastBox,"#f59e0b",`Refined • ${msR}ms`);
          drawLandmarks(octx,lastLandmarks);
          const cx2=lastBox.x+lastBox.width/2, cy2=lastBox.y+lastBox.height/2;
          const offX2=((cx2-canvas.width/2)/(canvas.width/2))*100, offY2=((cy2-canvas.height/2)/(canvas.height/2))*100;
          drawCross(octx,cx2,cy2,offX2,offY2);
          logEvt("detect",{refine_ms:msR,faceapi:true,box:lastBox,landmarks:68});
        }else{
          logEvt("detect",{refine_ms:msR,faceapi:false,reason:"no detection"});
        }
      }catch(e){ logEvt("error",{refine:e.message||String(e)}) }
    }

    setProgress(100,"Done."); startAnalysisBtn.disabled=false; document.getElementById("readyBadge").style.display="inline-flex";
    if(autoAnalyzeChk.checked){ startAnalysisBtn.click(); }
  }catch(e){ logEvt("error",{detectFlow:e.message||String(e)}) }
}

/* lightweight analysis */
function runLightAnalysis(){
  if(!lastCanvas||!lastBox){ logEvt("error",{analysis:"no detection"}); return }
  const imgW=lastCanvas.width,imgH=lastCanvas.height,b=lastBox;
  const areaPct=(b.width*b.height)/(imgW*imgH)*100, ar=b.width/b.height;
  const orient = ar>=1.15 ? "landscape" : (ar<=0.87 ? "portrait" : "near-square");
  const cx=b.x+b.width/2, cy=b.y+b.height/2; const offX=((cx-imgW/2)/(imgW/2))*100, offY=((cy-imgH/2)/(imgH/2))*100;
  const crop=document.createElement("canvas"); crop.width=128; crop.height=128;
  crop.getContext("2d").drawImage(lastCanvas,Math.max(0,Math.round(b.x)),Math.max(0,Math.round(b.y)),Math.max(1,Math.round(b.width)),Math.max(1,Math.round(b.height)),0,0,128,128);
  const id=crop.getContext("2d").getImageData(0,0,128,128);
  let sum=0,sum2=0; for(let i=0;i<id.data.length;i+=4){const y=0.299*id.data[i]+0.587*id.data[i+1]+0.114*id.data[i+2]; sum+=y; sum2+=y*y}
  const mean=sum/(id.data.length/4), stdev=Math.sqrt(Math.max(0,(sum2/(id.data.length/4))-mean*mean));
  const gray=new Float32Array(128*128); for(let i=0,p=0;i<id.data.length;i+=4,p++){gray[p]=0.299*id.data[i]+0.587*id.data[i+1]+0.114*id.data[i+2]}
  let lapSum=0,lapSum2=0,count=0; for(let y=1;y<127;y++){for(let x=1;x<127;x++){const i=(y*128+x);const v=gray[i-128]+gray[i-1]-4*gray[i]+gray[i+1]+gray[i+128]; lapSum+=v; lapSum2+=v*v; count++;}}
  const lapVar=Math.max(0,(lapSum2/Math.max(1,count))-(lapSum/Math.max(1,count))**2);

  const okArea=areaPct>=7&&areaPct<=15, okBri=mean>=110&&mean<=160, okCon=stdev>=30&&stdev<=65, okSharp=lapVar>=120, okOffX=Math.abs(offX)<=12, okOffY=Math.abs(offY)<=12;

  $("analysisCard").style.display="";
  $("kv_area").textContent=areaPct.toFixed(2)+" %"; $("kv_ar").textContent=ar.toFixed(3); $("kv_orient").textContent=orient;
  $("kv_bri").textContent=mean.toFixed(1); $("kv_contrast").textContent=stdev.toFixed(1); $("kv_sharp").textContent=lapVar.toFixed(1);
  $("kv_offx").textContent=(offX>=0?"+":"")+offX.toFixed(1)+" %"; $("kv_offy").textContent=(offY>=0?"+":"")+offY.toFixed(1)+" %";

  function setBadge(el,ok,okTxt,badTxt){ el.textContent=ok?okTxt:badTxt; el.className="badge "+(ok?"ok":"warn") }
  setBadge($("bdg_area"),okArea,"ok","adjust"); setBadge($("bdg_bri"),okBri,"ok","±light"); setBadge($("bdg_con"),okCon,"ok","±contrast"); setBadge($("bdg_sharp"),okSharp,"crisp","blurry"); setBadge($("bdg_offx"),okOffX,"centered","offset"); setBadge($("bdg_offy"),okOffY,"centered","offset");
  const hints=[]; if(!okArea)hints.push("Adjust crop to ~7–15% face area"); if(!okBri)hints.push(mean<110?"Increase lighting":"Reduce brightness"); if(!okCon)hints.push(stdev<30?"Boost contrast":"Soften contrast"); if(!okSharp)hints.push("Reduce motion/clean lens"); if(!(okOffX&&okOffY))hints.push("Center the face");
  hints.forEach(h=> hintCounts[h]=(hintCounts[h]||0)+1); anaCount++; updateFooter();

  lastAnalysis={
    revision:REVISION,
    timestamp:new Date().toISOString(),
    image:{width:imgW,height:imgH},
    box:{x:+b.x.toFixed(2),y:+b.y.toFixed(2),width:+b.width.toFixed(2),height:+b.height.toFixed(2),area_pct:+areaPct.toFixed(4),aspect:+ar.toFixed(4),center:{x:+(b.x+b.width/2).toFixed(2),y:+(b.y+b.height/2).toFixed(2)},center_offset_pct:{x:+offX.toFixed(2),y:+offY.toFixed(2)}},
    lighting:{brightness_mean:+mean.toFixed(3),contrast_stdev:+stdev.toFixed(3)},
    sharpness:{laplacian_variance:+lapVar.toFixed(3)},
    orientation:orient,
    refine:{landmarks: lastLandmarks ? 68 : 0}
  };
  // auto-save
  try{ localStorage.setItem("yorn_last_analysis", JSON.stringify(lastAnalysis)) }catch(_){}
  $("analysisHints").textContent="Hints: "+(hints.length?hints.join(" • "):"Looks good!");
  logEvt("analysis",{analysis:lastAnalysis});
  $("copyJsonBtn").disabled=false; $("exportJsonBtn").disabled=false; $("sharePngBtn").disabled=false;
}

/* export + copy */
$("copyDiagBtn").addEventListener('click',async()=>{ try{ await navigator.clipboard.writeText(diagnostics.textContent); logEvt('config',{copiedDiagnostics:true}) }catch(e){ logEvt('error',{copyDiagnosticsError:e.message||String(e)}) }});
copyAllBtn.addEventListener('click',async()=>{ try{ await navigator.clipboard.writeText(diagnostics.textContent); logEvt('config',{copiedAll:true}) }catch(e){ logEvt('error',{copyAll:e.message||String(e)}) }});
$("clearLogsBtn").addEventListener('click',()=>{ diagnostics.textContent='No diagnostics yet.'; toggleCopyBtns() });
$("resetBtn").addEventListener('click',()=>{ baseSource=null; imgBase.classList.add('hidden'); lastCanvas=null; lastBox=null; lastLandmarks=null; $("analysisCard").style.display="none"; logEvt('config',{reset:true}) });

$("copyJsonBtn").addEventListener('click',async()=>{
  try{ if(!lastAnalysis) return; await navigator.clipboard.writeText(JSON.stringify(lastAnalysis,null,2)); logEvt('config',{copiedJSON:true}); }catch(e){ logEvt('error',{copyJSON:e.message||String(e)}) }
});
$("exportJsonBtn").addEventListener('click',()=>{
  try{ if(!lastAnalysis) return; const blob=new Blob([JSON.stringify(lastAnalysis,null,2)],{type:"application/json"}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`yorn-analysis-${Date.now()}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); logEvt('config',{downloadJSON:true}); }catch(e){ logEvt('error',{downloadJSON:e.message||String(e)}) }
});
$("sharePngBtn").addEventListener('click',async()=>{
  try{
    if(!lastCanvas) return;
    const out=document.createElement('canvas'); out.width=lastCanvas.width; out.height=lastCanvas.height;
    const ctx=out.getContext('2d'); ctx.drawImage(lastCanvas,0,0); ctx.drawImage(cvOverlay,0,0);
    ctx.globalAlpha=0.85; ctx.fillStyle="#000000A0"; ctx.fillRect(out.width-240-10, out.height-32-10, 240, 28);
    ctx.globalAlpha=1; ctx.fillStyle="#E6EAF2"; ctx.font="12px ui-monospace,monospace";
    ctx.fillText(`YorN ${REVISION} • ${new Date().toISOString().slice(0,19)}`, out.width-230-10, out.height-14-10);
    const blob=await new Promise(r=>out.toBlob(r,'image/png',0.92));
    const file=new File([blob],'yorn-snapshot.png',{type:'image/png'});
    if(navigator.canShare && navigator.canShare({files:[file]})){ await navigator.share({files:[file], title:'YorN Snapshot', text:'Face detection preview'}); logEvt('config',{share:'webshare'}); }
    else { const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`yorn-snapshot-${Date.now()}.png`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); logEvt('config',{share:'download'}); }
  }catch(e){ logEvt('error',{sharePNG:e.message||String(e)}) }
});

/* tweak handlers */
function onTweak(){ if(baseSource){ const c=renderWorkingCanvas(1024); lastCanvas=c; paintBaseCanvas(c) } }
zoom.addEventListener("input",()=>{zoomLabel.textContent=(+zoom.value).toFixed(2);onTweak()});
bri.addEventListener("input",()=>{briLabel.textContent=(+bri.value).toFixed(2);onTweak()});
con.addEventListener("input",()=>{conLabel.textContent=(+con.value).toFixed(2);onTweak()});
rotDeg.addEventListener("change",onTweak);

/* buttons */
enhanceBtn.addEventListener("click",()=>{ zoom.value=Math.max(+zoom.value,1.5); zoomLabel.textContent=(+zoom.value).toFixed(2); bri.value=Math.max(+bri.value,1.18); briLabel.textContent=(+bri.value).toFixed(2); con.value=Math.max(+con.value,1.25); conLabel.textContent=(+con.value).toFixed(2); detectFlow() });
detectBtn.addEventListener("click",()=>detectFlow());
startAnalysisBtn.addEventListener("click",()=>{ logEvt("analysis",{analysisRequested:true,mode:"light"}); runLightAnalysis() });

/* file/sample */
fileInput.addEventListener('change', async ()=>{
  if(!fileInput.files.length) return;
  const f=fileInput.files[0]; setProgress(8,'Decoding photo…');
  try{ baseSource = await decodeOriginal(f); const canvas = renderWorkingCanvas(1024); if(canvas){ paintBaseCanvas(canvas); setProgress(12,'Photo ready'); detectBtn.disabled=false; enhanceBtn.disabled=false; } }catch(e){ logEvt('error',{decode_failed:e.message||String(e)}) }
});
sampleBtn.addEventListener('click', async ()=>{
  try{
    setProgress(5,'Fetching sample…');
    const u="https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1000&auto=format&fit=crop";
    const res=await fetch(u,{cache:"no-store"}); if(!res.ok) throw new Error('HTTP '+res.status);
    const blob=await res.blob();
    baseSource = await decodeOriginal(blob);
    const canvas=renderWorkingCanvas(1024);
    if(canvas){ paintBaseCanvas(canvas); setProgress(12,'Sample ready'); detectBtn.disabled=false; enhanceBtn.disabled=false; }
    logEvt('detect',{sampleImage:u});
  }catch(e){ logEvt('error',{sample_failed:e.message||String(e)}) }
});

/* precache */
precacheBtn.addEventListener('click',()=>precacheWeights());

/* init */
window.addEventListener('load', async ()=>{
  logEvt('config',{boot:'ui-ready',rev:REVISION});
  try{
    await initFrameworks();
    // restore last analysis
    try{
      const saved = localStorage.getItem("yorn_last_analysis");
      if(saved){ const a=JSON.parse(saved); logEvt('analysis',{restored:true,analysis:a}); }
    }catch(_){}
    logEvt('config',{boot:'complete'});
  }catch(e){ showVeil('Framework init failed'); logEvt('error',{frameworks:e.message||String(e)}) }
});
</script>
</body>
</html>