<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>YorN 1.16.16‑alpha</title>
<style>
  :root {
    --bg: #0c0f14;
    --card: #141a22;
    --text: #e9eef5;
    --muted: #a8b3c0;
    --accent: #63b3ff;
    --ok: #19c37d;
    --warn: #fabb2d;
    --bad: #ff5d5d;
    --line: #222a35;
  }
  * { box-sizing: border-box; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--text); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
  header { position:sticky; top:0; z-index:10; background:linear-gradient(180deg, rgba(12,15,20,.95), rgba(12,15,20,.65)); backdrop-filter: blur(6px); border-bottom:1px solid var(--line); }
  header .row { max-width: 980px; margin:0 auto; padding:10px 16px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .pill { background:var(--card); border:1px solid var(--line); padding:6px 10px; border-radius:999px; color:var(--muted); }
  .rev { position:fixed; right:8px; top:6px; font-size:11px; color:#93a1b1; opacity:.9; background:rgba(0,0,0,.35); padding:3px 8px; border-radius:10px; border:1px solid #2a3442;}
  .wrap { max-width:980px; margin:18px auto; padding:0 16px 36px; display:grid; grid-template-columns:1fr; gap:16px; }
  .card { background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px; }
  h2 { margin:0 0 10px; font-size:16px; letter-spacing:.2px; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  input[type="file"] { display:none; }
  .btn { appearance:none; border:1px solid var(--line); background:#0f1520; color:var(--text); padding:8px 12px; border-radius:10px; cursor:pointer; transition:.15s transform, .15s opacity; }
  .btn:hover { transform: translateY(-1px); }
  .btn:disabled { opacity:.45; cursor:not-allowed; transform:none; }
  .btn.ok { border-color: #1f2d24; background:#0f1b16; color:#b3f7d3; }
  .btn.accent { border-color:#1d3346; background:#102130; color:#cfe9ff; }
  .btn.warn { border-color:#3a2b0d; background:#1d1406; color:#ffd98a; }
  .select, .num { background:#0f1520; color:var(--text); border:1px solid var(--line); border-radius:10px; padding:8px 10px; }
  .grid { display:grid; grid-template-columns:1fr; gap:16px; }
  @media (min-width: 900px){ .grid { grid-template-columns: 1fr 1fr; } }
  canvas, img { max-width:100%; height:auto; display:block; border-radius:10px; border:1px solid var(--line); background:#0a0f15; }
  .pane { display:grid; gap:10px; }
  .kvs { display:grid; grid-template-columns: max-content 1fr; gap:6px 10px; }
  .kv k { color:var(--muted); }
  .bar { height:8px; background:#0f1520; border:1px solid var(--line); border-radius:999px; overflow:hidden; }
  .bar > i { display:block; height:100%; width:0%; background:linear-gradient(90deg, #63b3ff,#19c37d); }
  .diag { font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; background:#0a0e14; border:1px solid var(--line); border-radius:10px; padding:10px; max-height:260px; overflow:auto; white-space:pre-wrap; word-break:break-word; }
  .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--line); color:var(--muted); }
  .badge.ready { color:#0c2; background:#0a1a12; border-color:#163; }
  .muted { color:var(--muted); }
  .tiny { font-size:12px; color:var(--muted); }
</style>
</head>
<body>
<div class="rev">YorN <strong>1.16.16‑alpha</strong></div>

<header>
  <div class="row">
    <label class="btn">
      <input id="fileInput" type="file" accept="image/*" />
      Choose Photo
    </label>
    <button id="sampleBtn" class="btn">Load Sample</button>
    <button id="enhanceBtn" class="btn">Enhance &amp; Retry</button>
    <button id="detectBtn" class="btn accent" disabled>Detect</button>
    <button id="startAnalysisBtn" class="btn ok" disabled>Start Analysis</button>
    <button id="autoTestBtn" class="btn warn">Auto‑Test</button>
    <button id="copyTestBtn" class="btn" disabled>Copy Test Report</button>
    <span class="pill">Backend
      <select id="backendSel" class="select">
        <option value="wasm">WASM</option>
        <option value="webgl">WebGL</option>
        <option value="cpu">CPU</option>
      </select>
    </span>
    <span id="readyBadge" class="badge" style="display:none;">READY</span>
  </div>
</header>

<main class="wrap">

  <section class="grid">
    <div class="card pane">
      <h2>Preview</h2>
      <canvas id="preview" width="1024" height="683"></canvas>
      <div class="row">
        <label>Zoom <input id="zoom" type="range" min="0.8" max="2.0" step="0.01" value="1.20" class="num" style="width:160px;"></label>
        <label>Brightness <input id="bri" type="range" min="0.6" max="1.6" step="0.01" value="1.10" class="num" style="width:160px;"></label>
        <label>Contrast <input id="con" type="range" min="0.6" max="1.6" step="0.01" value="1.15" class="num" style="width:160px;"></label>
        <label>Rotate (°) <input id="rot" type="number" class="num" value="0" step="1" style="width:84px;"></label>
      </div>
      <div class="bar"><i id="bar"></i></div>
      <div id="progressText" class="tiny"></div>
    </div>

    <div class="card pane">
      <h2>Diagnostics</h2>
      <div class="row">
        <button id="copyDiagBtn" class="btn">Copy Diagnostics</button>
        <button id="clearLogsBtn" class="btn">Clear Logs</button>
        <button id="resetBtn" class="btn">Reset</button>
      </div>
      <div id="diagnostics" class="diag">No diagnostics yet.</div>
    </div>
  </section>

  <section id="analysisCard" class="card pane" style="display:none">
    <h2>Analysis</h2>
    <div class="kvs">
      <k>Face area</k><v id="kv_area">—</v>
      <k>Aspect ratio</k><v id="kv_aspect">—</v>
      <k>Center offset X</k><v id="kv_offx">—</v>
      <k>Center offset Y</k><v id="kv_offy">—</v>
      <k>Brightness</k><v id="kv_bri">—</v>
      <k>Contrast</k><v id="kv_con">—</v>
      <k>Sharpness</k><v id="kv_sharp">—</v>
      <k>Backend</k><v id="kv_backend">—</v>
    </div>
    <div class="row">
      <button id="copyJsonBtn" class="btn">Copy JSON</button>
      <button id="exportJsonBtn" class="btn">Download JSON</button>
    </div>
  </section>

</main>

<!-- Frameworks -->
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>

<script>
(() => {
  const REVISION = '1.16.16-alpha';

  /* ---------- tiny helpers ---------- */
  const $ = id => document.getElementById(id);
  const sleep = ms => new Promise(r=>setTimeout(r,ms));

  function logEvt(type, obj) {
    const line = `[${new Date().toISOString()}] ${JSON.stringify({ type, ...obj })}`;
    const box = $('diagnostics');
    if (box.textContent.trim() === 'No diagnostics yet.') box.textContent = '';
    box.textContent += (box.textContent ? '\n' : '') + line;
    box.scrollTop = box.scrollHeight;
  }

  function setProgress(pct, text) {
    $('bar').style.width = Math.max(0, Math.min(100, pct)) + '%';
    $('progressText').textContent = text || '';
  }

  /* ---------- canvas pipeline ---------- */
  let baseSource = null;       // ImageBitmap or HTMLImageElement
  let model = null;            // BlazeFace model
  let lastBox = null;          // final face box
  let lastAnalysis = null;

  function get2d(w, h) {
    const c = $('preview');
    c.width = w; c.height = h;
    return c.getContext('2d', { alpha:false, desynchronized:true });
  }

  function composePreview() {
    if (!baseSource) return null;
    const z = +$('zoom').value || 1;
    const rot = (+$('rot').value || 0) * Math.PI/180;
    const bri = +$('bri').value || 1;
    const con = +$('con').value || 1;

    const srcW = baseSource.width;
    const srcH = baseSource.height;
    const dstW = Math.round(Math.min(1024, srcW * z));
    const dstH = Math.round(dstW * (srcH/srcW));

    const ctx = get2d(dstW, dstH);
    ctx.save();
    ctx.filter = `brightness(${bri}) contrast(${con})`;
    if (rot !== 0) {
      ctx.translate(dstW/2, dstH/2);
      ctx.rotate(rot);
      const scaleFit = Math.min(dstW/srcW, dstH/srcH);
      const drawW = srcW * scaleFit;
      const drawH = srcH * scaleFit;
      ctx.drawImage(baseSource, -drawW/2, -drawH/2, drawW, drawH);
    } else {
      ctx.drawImage(baseSource, 0, 0, dstW, dstH);
    }
    ctx.restore();
    return ctx.canvas;
  }

  function drawBoxOn(canvas, box, color='#63b3ff') {
    const ctx = canvas.getContext('2d');
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(2, canvas.width/256);
    ctx.shadowColor = 'rgba(0,0,0,.7)';
    ctx.shadowBlur = 6;
    ctx.strokeRect(box.x, box.y, box.width, box.height);
    ctx.restore();
  }

  /* ---------- tf backend & warmup ---------- */
  async function setBackendPreferred() {
    const sel = $('backendSel');
    const wanted = localStorage.getItem('yorn_backend') || sel.value || 'wasm';
    try {
      await tf.setBackend(wanted);
      await tf.ready();
      localStorage.setItem('yorn_backend', wanted);
      sel.value = wanted;
      logEvt('config', { tf:'ready', backend: tf.getBackend(), tf_version: tf.version_core || tf.version_core });
      await warmupKernels();
    } catch (e) {
      logEvt('error', { backend_set_failed: e.message || String(e) });
      // fallback chain
      for (const b of ['wasm','webgl','cpu']) {
        if (b === wanted) continue;
        try {
          await tf.setBackend(b);
          await tf.ready();
          sel.value = b;
          localStorage.setItem('yorn_backend', b);
          logEvt('config', { tf:'ready', backend: tf.getBackend(), tf_version: tf.version_core || tf.version_core, fallback_from: wanted });
          await warmupKernels();
          break;
        } catch(_) {}
      }
    }
  }

  async function warmupKernels() {
    try {
      // light but diversified warmup
      await tf.tidy(() => {
        const a = tf.randomUniform([1,32,32,3]);
        const k = tf.ones([3,3,3,8]);
        const c = tf.conv2d(a, k, 1, 'same');
        const r = tf.image.resizeBilinear(c, [16,16]);
        return r.mean().dataSync();
      });
      logEvt('config', { warmup:'ok', backend: tf.getBackend() });
    } catch (e) {
      logEvt('error', { warmup: e.message || String(e) });
    }
  }

  $('backendSel').addEventListener('change', async () => {
    localStorage.setItem('yorn_backend', $('backendSel').value);
    await setBackendPreferred();
  });

  /* ---------- model load ---------- */
  async function ensureModel() {
    if (model) return model;
    if (!window.blazeface) {
      logEvt('error', { model:'blazeface UMD missing' });
      throw new Error('BlazeFace not available');
    }
    model = await blazeface.load({ maxFaces: 1, inputWidth: 256, inputHeight: 256 });
    logEvt('detect', { blazefaceReady: true });
    return model;
  }

  /* ---------- detection ---------- */
  function extractCanvasData(srcCanvas, maxW) {
    const scale = Math.min(1, (maxW||384)/srcCanvas.width);
    if (scale === 1) return srcCanvas;
    const w = Math.round(srcCanvas.width * scale);
    const h = Math.round(srcCanvas.height * scale);
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.getContext('2d').drawImage(srcCanvas, 0, 0, w, h);
    return c;
  }

  function upscaleBox(box, srcCanvas, downCanvas) {
    if (downCanvas === srcCanvas) return box;
    const s = srcCanvas.width / downCanvas.width;
    return {
      x: box.x * s,
      y: box.y * s,
      width: box.width * s,
      height: box.height * s
    };
  }

  async function quickDetect() {
    await ensureModel();
    const src = composePreview();
    if (!src) return null;
    setProgress(35, 'Scanning…');
    const down = extractCanvasData(src, 384); // quick path
    const preds = await model.estimateFaces(down, false);
    if (!preds || preds.length === 0) return null;
    // convert normalized landmarks box -> xywh
    const p = preds[0];
    // BlazeFace returns topLeft & bottomRight
    const [x0,y0] = p.topLeft;
    const [x1,y1] = p.bottomRight;
    const box = { x:x0, y:y0, width: (x1-x0), height:(y1-y0) };
    const up = upscaleBox(box, src, down);
    return { box: up, canvas: src };
  }

  async function detectFlow() {
    try {
      setProgress(10, 'Preparing…');
      const src = composePreview();
      if (!src) return;
      // rough locate
      const t0 = performance.now();
      const res = await quickDetect();
      if (!res) {
        setProgress(100, 'No face found');
        logEvt('analysis', { finalDetect_ms: 0, box: null });
        return;
      }
      const roughMs = Math.round(performance.now() - t0);
      const box = res.box;
      lastBox = box;
      drawBoxOn(src, box, '#63b3ff');
      setProgress(65, 'Face found');
      logEvt('detect', { roughLocate_ms: roughMs, box });

      // final (same as rough for now; refine disabled)
      const t1 = performance.now();
      drawBoxOn(src, box, '#19c37d');
      const finalMs = Math.round(performance.now() - t1);
      logEvt('detect', { finalDetect_ms: finalMs, scale: 256, mirror: false, box });
      $('startAnalysisBtn').disabled = false;
      return box;
    } catch (e) {
      logEvt('error', { detect: e.message || String(e) });
    } finally {
      setProgress(100, '');
      setTimeout(()=>setProgress(0,''), 400);
    }
  }

  /* ---------- analysis ---------- */
  function varianceLaplacian(gray, w, h) {
    // simple, fast laplacian var using 3x3 kernel on downscaled image
    const K = [[0,1,0],[1,-4,1],[0,1,0]];
    const out = [];
    let sum = 0, sum2 = 0, n = 0;
    for (let y=1; y<h-1; y++) {
      for (let x=1; x<w-1; x++) {
        let v = 0;
        for (let ky=-1; ky<=1; ky++) {
          for (let kx=-1; kx<=1; kx++) {
            v += K[ky+1][kx+1] * gray[(y+ky)*w + (x+kx)];
          }
        }
        out.push(v);
        sum += v; sum2 += v*v; n++;
      }
    }
    const mean = sum/n;
    return Math.max(0, (sum2/n) - mean*mean);
  }

  function computeStats(canvas, box) {
    const ctx = canvas.getContext('2d');
    const { x,y,width:W,height:H } = box;
    const sx = Math.max(0, Math.floor(x));
    const sy = Math.max(0, Math.floor(y));
    const sw = Math.min(canvas.width - sx, Math.floor(W));
    const sh = Math.min(canvas.height - sy, Math.floor(H));
    const img = ctx.getImageData(sx, sy, sw, sh);
    let briSum=0, briCnt=0;
    const gray = new Uint8Array(sw*sh);
    let i=0;
    for (let p=0; p<img.data.length; p+=4) {
      const r = img.data[p], g=img.data[p+1], b=img.data[p+2];
      const l = 0.299*r + 0.587*g + 0.114*b;
      gray[i++] = l;
      briSum += l; briCnt++;
    }
    const mean = briSum / Math.max(1,briCnt);

    // contrast ~ stdev of luminance
    let dev=0;
    i=0;
    for (let p=0; p<img.data.length; p+=4) {
      const l = gray[i++];
      dev += (l-mean)*(l-mean);
    }
    const stdev = Math.sqrt(dev/Math.max(1,briCnt));

    // sharpness via Laplacian on small map
    // downscale to ~128px wide region for speed
    const scale = Math.min(1, 128/sw);
    const dw = Math.max(8, Math.round(sw*scale));
    const dh = Math.max(8, Math.round(sh*scale));
    const tmp = document.createElement('canvas');
    tmp.width=dw; tmp.height=dh;
    tmp.getContext('2d').drawImage(canvas, sx, sy, sw, sh, 0, 0, dw, dh);
    const d = tmp.getContext('2d').getImageData(0,0,dw,dh).data;
    const g2 = new Uint8Array(dw*dh);
    for (let y=0, idx=0; y<dh; y++) {
      for (let x=0; x<dw; x++, idx+=4) {
        g2[y*dw+x] = 0.299*d[idx] + 0.587*d[idx+1] + 0.114*d[idx+2];
      }
    }
    const lapVar = varianceLaplacian(g2, dw, dh);

    return { brightness_mean: +mean.toFixed(3), contrast_stdev: +stdev.toFixed(3), laplacian_variance: +lapVar.toFixed(3) };
  }

  async function runLightAnalysis() {
    try {
      if (!lastBox) { await detectFlow(); if (!lastBox) return; }
      const canvas = composePreview();
      const A = computeStats(canvas, lastBox);
      const area = (lastBox.width * lastBox.height) / (canvas.width * canvas.height) * 100;
      const aspect = lastBox.width / lastBox.height;
      const cx = lastBox.x + lastBox.width/2;
      const cy = lastBox.y + lastBox.height/2;
      const offx = (cx - canvas.width/2) / canvas.width * 100;
      const offy = (cy - canvas.height/2) / canvas.height * 100;

      lastAnalysis = {
        revision: REVISION,
        timestamp: new Date().toISOString(),
        image: { width: canvas.width, height: canvas.height },
        box: {
          x: +lastBox.x.toFixed(2), y: +lastBox.y.toFixed(2),
          width: +lastBox.width.toFixed(2), height: +lastBox.height.toFixed(2),
          area_pct: +area.toFixed(4),
          aspect: +aspect.toFixed(4),
          center: { x:+cx.toFixed(2), y:+cy.toFixed(2) },
          center_offset_pct: { x:+offx.toFixed(2), y:+offy.toFixed(2) }
        },
        lighting: A,
        orientation: canvas.width >= canvas.height ? 'landscape' : 'portrait',
        refine: {}
      };

      $('kv_area').textContent  = area.toFixed(2) + ' %';
      $('kv_aspect').textContent= aspect.toFixed(4);
      $('kv_offx').textContent  = (offx>=0?'+':'') + offx.toFixed(2) + ' %';
      $('kv_offy').textContent  = (offy>=0?'+':'') + offy.toFixed(2) + ' %';
      $('kv_bri').textContent   = A.brightness_mean;
      $('kv_con').textContent   = A.contrast_stdev;
      $('kv_sharp').textContent = A.laplacian_variance;
      $('kv_backend').textContent = (tf.getBackend() || '—') + ' (tf ' + (tf?.version_core || tf?.version?.tfjs || '—') + ')';

      $('analysisCard').style.display = '';
      localStorage.setItem('yorn_last_analysis', JSON.stringify(lastAnalysis));
      logEvt('analysis', { analysis: lastAnalysis });
    } catch (e) {
      logEvt('error', { analysis: e.message || String(e) });
    }
  }

  /* ---------- copy helpers ---------- */
  async function copyTextRobust(text) {
    if (text == null) text = '';
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return { ok:true, via:'clipboard' };
      }
    } catch(_) {}
    try {
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.setAttribute('readonly','');
      ta.style.position = 'fixed';
      ta.style.opacity = '0';
      ta.style.left = '-9999px';
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand('copy');
      document.body.removeChild(ta);
      if (ok) return { ok:true, via:'execCommand' };
    } catch (e) {
      return { ok:false, via:'fallback', err:e.message || String(e) };
    }
    return { ok:false, via:'none', err:'No clipboard available' };
  }

  function getAllLogsText() {
    const el = $('diagnostics');
    return el ? (el.innerText || el.textContent || '') : '';
  }

  function buildAutoTestReport() {
    const full = getAllLogsText();
    // pull last run summary-ish
    const backendMatch = full.match(/"backend":"([^"]+)"/) || [];
    const tfVerMatch = full.match(/"tf_version":"([^"]+)"/) || [];
    const refine = /"refine":\{/.test(full) ? 'yes' : 'no';
    const rough = (full.match(/"roughLocate_ms":(\d+)/) || [])[1] || '—';
    const final = (full.match(/"finalDetect_ms":(\d+)/) || [])[1] || '—';
    const errors = (full.match(/"type":"error"/g) || []).length;
    const passes = (full.match(/"type":"test","step":"[^"]+","ok":true/g) || []).length;
    const summary = `YorN ${REVISION} • TF backend: ${backendMatch[1]||'—'} • refine: ${refine} • passes: ${passes} • errors: ${errors} • rough: ${rough} ms • final: ${final} ms`;
    const lines = full.split('\n').filter(l => /"type":"(test|detect|analysis|config|error)"/.test(l));
    return ['=== YorN Auto‑Test Report ===', summary, '', ...lines, '=== End Report ===', ''].join('\n');
  }

  /* ---------- UI binds ---------- */
  $('enhanceBtn').addEventListener('click', () => {
    const z=$('zoom'); z.value = Math.max(+z.value, 1.5);
    const b=$('bri');  b.value = Math.max(+b.value, 1.18);
    const c=$('con');  c.value = Math.max(+c.value, 1.25);
    detectFlow();
  });

  $('detectBtn').addEventListener('click', detectFlow);
  $('startAnalysisBtn').addEventListener('click', () => {
    logEvt('analysis', { analysisRequested: true, mode: 'light' });
    runLightAnalysis();
  });

  $('clearLogsBtn').addEventListener('click', () => {
    $('diagnostics').textContent = 'No diagnostics yet.';
  });

  $('resetBtn').addEventListener('click', () => {
    baseSource = null; lastBox = null; lastAnalysis = null;
    $('analysisCard').style.display = 'none';
    const ctx = get2d(1024, 683); ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    $('detectBtn').disabled = true; $('startAnalysisBtn').disabled = true;
    logEvt('config', { reset:true });
  });

  $('fileInput').addEventListener('change', async () => {
    if (!$('fileInput').files.length) return;
    const f = $('fileInput').files[0];
    setProgress(10, 'Decoding photo…');
    try {
      baseSource = await createImageBitmap(f);
      composePreview(); setProgress(20, 'Photo ready');
      $('detectBtn').disabled = false;
      logEvt('detect', { fileName:f.name, size_bytes:f.size, w:baseSource.width, h:baseSource.height });
    } catch (e) {
      logEvt('error', { decode_failed: e.message || String(e) });
    }
  });

  $('sampleBtn').addEventListener('click', async () => {
    try {
      setProgress(6, 'Fetching sample…');
      const u = "https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1000&auto=format&fit=crop";
      const res = await fetch(u, { cache:'no-store' });
      if (!res.ok) throw new Error('HTTP '+res.status);
      const blob = await res.blob();
      baseSource = await createImageBitmap(blob);
      composePreview(); setProgress(12, 'Sample ready');
      $('detectBtn').disabled = false;
      logEvt('detect', { sampleImage: u });
    } catch (e) {
      logEvt('error', { sample_failed: e.message || String(e) });
    }
  });

  $('copyDiagBtn').addEventListener('click', async () => {
    const report = getAllLogsText();
    const res = await copyTextRobust(report);
    if (res.ok) {
      logEvt('config', { copiedDiagnostics:true, via:res.via, length: report.length });
      $('progressText').textContent = 'Diagnostics copied';
      setTimeout(()=> $('progressText').textContent = '', 1200);
    } else {
      logEvt('error', { copyDiagnosticsError: res.err || 'unknown', via: res.via });
    }
  });

  $('copyTestBtn').addEventListener('click', async () => {
    const report = buildAutoTestReport();
    const res = await copyTextRobust(report);
    if (res.ok) {
      logEvt('config', { copiedAutoTestReport:true, via:res.via, length: report.length });
      $('progressText').textContent = 'Test report copied';
      setTimeout(()=> $('progressText').textContent = '', 1200);
    } else {
      logEvt('error', { copyAutoTestReportError: res.err || 'unknown', via: res.via });
    }
  });

  $('autoTestBtn').addEventListener('click', async () => {
    $('autoTestBtn').disabled = true;
    $('copyTestBtn').disabled = true;
    try {
      logEvt('test', { step:'begin', rev: REVISION });
      logEvt('test', { step:'tf_present', ok: !!window.tf });
      await setBackendPreferred(); // sets backend + warmup
      // sample
      await $('sampleBtn').click();
      await sleep(150);
      logEvt('test', { step:'sample', ok: !!baseSource });
      // detect
      const t0 = performance.now();
      const b = await detectFlow();
      const ms = Math.round(performance.now() - t0);
      logEvt('test', { step:'detect_blazeonly', ok: !!b, ms });
      logEvt('test', { step:'refine_guard', ok: true });
      // analysis
      $('startAnalysisBtn').click();
      await sleep(120);
      logEvt('test', { step:'analysis_blazeonly', ok: !!lastAnalysis });
      // summary
      const ok = !!(baseSource && lastBox && lastAnalysis);
      const badge = $('readyBadge');
      badge.style.display = 'inline-block';
      badge.className = ok ? 'badge ready' : 'badge';
      badge.textContent = ok ? 'READY' : 'BLOCKED';
      logEvt('test', { step:'summary', ok });
      $('copyTestBtn').disabled = false;
    } catch (e) {
      logEvt('error', { autoTest: e.message || String(e) });
    }
    $('autoTestBtn').disabled = false;
  });

  // live controls
  for (const id of ['zoom','bri','con','rot']) {
    $(id).addEventListener('input', () => {
      composePreview();
      if (lastBox) {
        const c = $('preview');
        drawBoxOn(c, lastBox, '#63b3ff');
      }
    });
  }

  /* ---------- boot ---------- */
  window.addEventListener('DOMContentLoaded', async () => {
    logEvt('config', { boot:'dom-ready', rev: REVISION });
    // restore backend preference
    const pref = localStorage.getItem('yorn_backend');
    if (pref) $('backendSel').value = pref;
    await setBackendPreferred();
    // restore last analysis if present
    try {
      const saved = localStorage.getItem('yorn_last_analysis');
      if (saved) {
        const a = JSON.parse(saved);
        logEvt('analysis', { restored:true, analysis:a });
        $('analysisCard').style.display = '';
      }
    } catch(_) {}
    logEvt('config', { boot:'complete' });
  });

})();
</script>
</body>
</html>