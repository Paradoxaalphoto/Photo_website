<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>YorN Alpha — Ready Indicator + Mobile Stable</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{color-scheme:light dark}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
    margin:0; background:#0b1220; color:#E6EAF2; overflow-x:hidden;
  }
  .container{max-width:980px; margin:0 auto; padding:16px}
  h2{margin:8px 0 0 0}
  .card{background:#0f172a; border:1px solid #233046; border-radius:12px; padding:12px; margin-top:12px}
  .row{display:grid; grid-template-columns:1fr auto auto auto auto auto; gap:8px; align-items:end}
  .controls{display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-top:8px}
  @media (max-width: 720px){
    .row{grid-template-columns:1fr; gap:10px}
    .controls{grid-template-columns:1fr 1fr; gap:10px}
    .two-col{grid-template-columns:1fr; gap:12px}
  }
  label{font-size:12px; color:#A9B4C8}
  input[type="range"], input[type="number"], select{width:100%}
  input[type="number"], input[type="range"], select{
    padding:6px; border:1px solid #233046; border-radius:8px; background:#0b1220; color:#E6EAF2
  }
  button{cursor:pointer}
  .btn{padding:10px 14px; border-radius:8px; border:1px solid #233046; background:#1f2937; color:#E6EAF2}
  .btn[disabled]{opacity:.5; cursor:not-allowed}
  .btn-secondary{background:#0b1220}
  #progressContainer{height:8px; background:#1e293b; border-radius:6px; overflow:hidden; margin-top:8px}
  #progressBar{height:100%; width:0; background:#38bdf8; transition:width .25s}
  #thumb, #overlay{display:block; width:100%; height:auto; margin-top:10px; background:#0b1220; border:1px solid #233046; border-radius:8px}
  .two-col{display:grid; grid-template-columns:1fr 1fr; gap:12px}
  .two-col > div{min-width:0}
  #diagnostics{
    white-space:pre-wrap; overflow-wrap:anywhere; word-break:break-word;
    font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px;
    background:#0b1220; border:1px solid #233046; border-radius:8px; padding:8px;
    height:220px; max-height:40vh; overflow:auto;
  }
  /* Badges (fixed, do not affect layout) */
  #revBadge{
    position:fixed; top:8px; right:10px; z-index:9999;
    background:rgba(0,0,0,.6); color:#fff; font:12px ui-monospace,monospace;
    padding:3px 8px; border:1px solid rgba(255,255,255,.18); border-radius:999px;
    backdrop-filter:saturate(120%) blur(4px)
  }
  #readyBadge{
    position:fixed; top:36px; right:10px; z-index:9999; display:none;
    background:rgba(16,185,129,.15); color:#a7f3d0; font:12px ui-monospace,monospace;
    padding:3px 8px; border:1px solid rgba(16,185,129,.55); border-radius:999px;
    backdrop-filter:saturate(120%) blur(4px)
  }
  #readyDot{
    display:inline-block; width:8px; height:8px; border-radius:999px; background:#10b981; margin-right:6px
  }
</style>

<!-- Scripts: TFJS → BlazeFace → face-api (only for Fix 1) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
</head>
<body>
<div id="revBadge">YorN Rev <span id="revText"></span></div>
<div id="readyBadge"><span id="readyDot"></span><span id="readyText">Ready for Analysis</span></div>

<div class="container">
  <h2>YorN Alpha — Face Analysis</h2>

  <div class="card">
    <div class="row">
      <input id="fileInput" type="file" accept="image/*" />
      <button id="sampleBtn" class="btn btn-secondary">Load Sample Image</button>
      <button id="enhanceBtn" class="btn btn-secondary" disabled>Auto‑Enhance & Retry</button>
      <button id="analyzeBtn" class="btn" disabled>Analyze</button>
      <button id="savePngBtn" class="btn btn-secondary" disabled>Save Debug Snapshot</button>
      <button id="clearLogsBtn" class="btn btn-secondary">Clear Logs</button>
    </div>

    <div class="controls">
      <div>
        <label>Rotate (°)</label>
        <input id="rotDeg" type="number" step="90" value="0" />
      </div>
      <div>
        <label>Zoom (0.8–2.0): <span id="zoomLabel">1.2</span></label>
        <input id="zoom" type="range" min="0.8" max="2.0" step="0.05" value="1.2" />
      </div>
      <div>
        <label>Brightness: <span id="briLabel">1.10</span></label>
        <input id="bri" type="range" min="0.8" max="1.4" step="0.02" value="1.10" />
      </div>
      <div>
        <label>Contrast: <span id="conLabel">1.15</span></label>
        <input id="con" type="range" min="0.8" max="1.6" step="0.02" value="1.15" />
      </div>
      <div>
        <label>Fix mode</label>
        <select id="fixMode">
          <option value="cdn">Fix 1 — Multi‑CDN face‑api</option>
          <option value="blazeonly" selected>Fix 2 — BlazeFace only</option>
          <option value="native">Fix 3 — Native FaceDetector → BlazeFace</option>
        </select>
      </div>
    </div>

    <div id="progressContainer"><div id="progressBar"></div></div>
    <p id="progressText" style="font-size:12px;color:#A9B4C8;margin:6px 2px 0 2px;"></p>
  </div>

  <div class="card">
    <div class="two-col">
      <div>
        <strong style="font-size:13px">Preview</strong>
        <img id="thumb" class="hidden" alt="Preview" />
        <canvas id="overlay" class="hidden"></canvas>
      </div>
      <div>
        <strong style="font-size:13px">Diagnostics</strong>
        <div id="diagnostics">No diagnostics yet.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ==== Revision: change this per build ==== */
const REVISION = "1.6.0-alpha";
document.getElementById("revText").textContent = REVISION;

/* ---------- Helpers ---------- */
const $ = id => document.getElementById(id);
const fileInput = $("fileInput"), sampleBtn = $("sampleBtn"), analyzeBtn = $("analyzeBtn"), enhanceBtn = $("enhanceBtn"), savePngBtn = $("savePngBtn"), clearLogsBtn = $("clearLogsBtn");
const fixModeSel = $("fixMode");
const overlay = $("overlay"), thumb = $("thumb");
const progressBar = $("progressBar"), progressText = $("progressText");
const diagnostics = $("diagnostics");
const rotDeg = $("rotDeg"), zoom = $("zoom"), zoomLabel = $("zoomLabel"), bri = $("bri"), briLabel = $("briLabel"), con = $("con"), conLabel = $("conLabel");
const readyBadge = $("readyBadge");

let baseBitmap = null, workCanvas = null, blazeModel = null, faceApiReady = false;
let readyTimeout = null;

/* Diagnostics trimming (~20KB) */
function trimDiag(){ const MAX=20000, CUT=15000; if(diagnostics.textContent.length>MAX){ diagnostics.textContent = diagnostics.textContent.slice(0,CUT); } }
function setProgress(p,t){ progressBar.style.width=(p||0)+'%'; progressText.textContent=t||''; }
function logDiag(obj){ const now=new Date().toISOString(); const txt=typeof obj==='string'?obj:JSON.stringify(obj); diagnostics.textContent = `[${now}] ${txt}\n` + diagnostics.textContent; trimDiag(); }
function setError(msg){ setProgress(0,""); logDiag({ error: msg }); hideReady(); }
function ensureWorkCanvas(){ if(!workCanvas){ workCanvas = document.createElement("canvas"); } return workCanvas; }

/* Ready-for-analysis indicator */
function showReady(){
  readyBadge.style.display = "inline-flex";
  logDiag({ readyForAnalysis: true, revision: REVISION });
  if(readyTimeout) clearTimeout(readyTimeout);
  readyTimeout = setTimeout(()=>{ readyBadge.style.display="none"; }, 4000);
}
function hideReady(){ if(readyTimeout) clearTimeout(readyTimeout); readyBadge.style.display="none"; }

/* Drawing */
function paintBase(canvas){
  const ctx = overlay.getContext("2d");
  overlay.width = canvas.width; overlay.height = canvas.height;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  ctx.drawImage(canvas, 0, 0, overlay.width, overlay.height);
  overlay.classList.remove("hidden");
}
function drawBox(box, color, label){
  const ctx = overlay.getContext("2d");
  ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.strokeRect(box.x, box.y, box.width, box.height);
  ctx.fillStyle = color; ctx.font = "12px ui-monospace,monospace";
  ctx.fillText(label, box.x, Math.max(12, box.y-4));
}

/* Decode */
async function decodeOriginal(fileOrBlob){
  const bmp = await createImageBitmap(fileOrBlob).catch(async ()=>{
    const url = URL.createObjectURL(fileOrBlob);
    const img = new Image(); await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=url; });
    const c = document.createElement("canvas"); c.width=img.naturalWidth; c.height=img.naturalHeight; c.getContext("2d").drawImage(img,0,0);
    URL.revokeObjectURL(url); return createImageBitmap(c);
  });
  return bmp;
}

/* Render with controls */
function renderWorkingCanvas(targetMax=1024, centerBox=null){
  if(!baseBitmap) return null;
  const angle=(parseInt(rotDeg.value,10)||0)%360;
  let z=parseFloat(zoom.value)||1.0;
  const br=parseFloat(bri.value)||1.0, cr=parseFloat(con.value)||1.0;

  const maxSide=Math.max(baseBitmap.width, baseBitmap.height);
  const scale0=Math.min(1, targetMax/maxSide);
  const w0=Math.max(1, Math.round(baseBitmap.width*scale0));
  const h0=Math.max(1, Math.round(baseBitmap.height*scale0));

  let cx=baseBitmap.width/2, cy=baseBitmap.height/2;
  if(centerBox){
    cx=centerBox.x+centerBox.width/2; cy=centerBox.y+centerBox.height/2;
    const zx=(w0/(centerBox.width*scale0))*0.9, zy=(h0/(centerBox.height*scale0))*0.9;
    z=Math.max(z, Math.min(zx, zy, 1.8));
    logDiag({ autoZoomApplied: z.toFixed(2) });
  }

  const dstW=w0, dstH=h0;
  const srcW=Math.round(dstW/(scale0*z));
  const srcH=Math.round(dstH/(scale0*z));
  const sx=Math.max(0, Math.round(cx-srcW/2));
  const sy=Math.max(0, Math.round(cy-srcH/2));

  const c=ensureWorkCanvas();
  if((angle%180)===0){ c.width=dstW; c.height=dstH; } else { c.width=dstH; c.height=dstW; }

  const ctx=c.getContext("2d");
  ctx.save();
  ctx.clearRect(0,0,c.width,c.height);
  ctx.translate(c.width/2, c.height/2);
  ctx.rotate(angle*Math.PI/180);
  ctx.filter=`brightness(${br}) contrast(${cr})`;
  ctx.drawImage(baseBitmap, sx, sy, srcW, srcH, -dstW/2, -dstH/2, dstW, dstH);
  ctx.restore();

  return c;
}

/* BlazeFace */
async function ensureBlaze(){
  if(blazeModel) return;
  if(!window.blazeface) throw new Error("BlazeFace script not loaded");
  blazeModel = await window.blazeface.load();
  logDiag({ blazefaceReady:true });
}
function downsample(canvas, w, mirror=false){
  const h = Math.round(w * (canvas.height/canvas.width));
  const tmp = Object.assign(document.createElement("canvas"), { width:w, height:h });
  const ctx = tmp.getContext("2d");
  if(mirror){ ctx.translate(w,0); ctx.scale(-1,1); }
  ctx.drawImage(canvas,0,0,w,h);
  return tmp;
}
async function detectBlazeMulti(canvas){
  const configs = [
    {w:256, mirror:false},
    {w:384, mirror:false},
    {w:512, mirror:false},
    {w:384, mirror:true},
    {w:512, mirror:true}
  ];
  for(const cfg of configs){
    const tmp = downsample(canvas, cfg.w, cfg.mirror);
    const t0 = performance.now();
    const faces = await blazeModel.estimateFaces(tmp, false);
    const ms = Math.round(performance.now()-t0);
    if(faces && faces.length){
      const f = faces[0];
      const tl = Array.isArray(f.topLeft) ? f.topLeft : await f.topLeft.array();
      const br = Array.isArray(f.bottomRight) ? f.bottomRight : await f.bottomRight.array();
      const sx = canvas.width / tmp.width, sy = canvas.height / tmp.height;
      let x = tl[0]*sx, y = tl[1]*sy, width=(br[0]-tl[0])*sx, height=(br[1]-tl[1])*sy;
      if(cfg.mirror){ x = canvas.width - (x + width); }
      const box = { x, y, width, height };
      logDiag({ finalDetect_ms: ms, scale: cfg.w, mirror: cfg.mirror, box });
      return { elapsed_ms: ms, box };
    }
  }
  logDiag({ finalDetect: "no face" });
  return null;
}
async function roughLocate(canvas){
  const tinyW=160, tinyH=Math.round(tinyW*(canvas.height/canvas.width));
  const tmp=Object.assign(document.createElement("canvas"),{width:tinyW,height:tinyH});
  tmp.getContext("2d").drawImage(canvas,0,0,tinyW,tinyH);
  const t0=performance.now();
  const faces=await blazeModel.estimateFaces(tmp,false);
  const ms=Math.round(performance.now()-t0);
  if(faces && faces.length){
    const f=faces[0];
    const tl=Array.isArray(f.topLeft)?f.topLeft:await f.topLeft.array();
    const br=Array.isArray(f.bottomRight)?f.bottomRight:await f.bottomRight.array();
    const sx=canvas.width/tinyW, sy=canvas.height/tinyH;
    const box={x:tl[0]*sx, y:tl[1]*sy, width:(br[0]-tl[0])*sx, height:(br[1]-tl[1])/*sy*/ * sy};
    logDiag({ roughLocate_ms:ms, box });
    return box;
  }
  logDiag({ roughLocate_ms:ms, box:null });
  return null;
}

/* face-api (Fix 1) */
let FA_WEIGHTS=null;
async function fetchJson(url){ const r=await fetch(url,{cache:"no-store"}); if(!r.ok) throw new Error("status "+r.status); return r.json(); }
async function verifyManifestAndShards(base, name){
  const mani = await fetchJson(`${base}/${name}`);
  const shards = (mani.weights||[]).flatMap(w=>w.paths||[]).map(p=>`${base}/${p}`);
  for(const u of shards){ const r=await fetch(u,{cache:"no-store"}); if(!r.ok) throw new Error("shard 404"); }
}
async function pickWeights(){
  if(FA_WEIGHTS) return FA_WEIGHTS;
  const bases=[
    "https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights",
    "https://rawcdn.githack.com/justadudewhohacks/face-api.js/0.22.2/weights",
    "https://cdn.jsdelivr.net/gh/vladmandic/face-api/model",
    "https://unpkg.com/face-api.js@0.22.2/weights",
    "https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights"
  ];
  for(const b of bases){
    try{
      await verifyManifestAndShards(b, "tiny_face_detector_model-weights_manifest.json");
      await verifyManifestAndShards(b, "face_landmark_68_model-weights_manifest.json");
      FA_WEIGHTS = b.replace(/\/$/,"");
      logDiag({ usingWeightsFrom: FA_WEIGHTS });
      return FA_WEIGHTS;
    }catch(e){ logDiag({ weightsAttempt: b, fail: e.message }); }
  }
  throw new Error("All weights CDNs failed");
}
async function ensureFaceApi(){
  if(faceApiReady) return;
  const base = await pickWeights();
  await faceapi.nets.tinyFaceDetector.loadFromUri(base);
  await faceapi.nets.faceLandmark68Net.loadFromUri(base);
  faceApiReady = true; logDiag({ faceapiReady:true });
}

/* Native FaceDetector (Fix 3) */
async function detectWithFaceDetector(canvas){
  if(!("FaceDetector" in window)) throw new Error("FaceDetector API not available");
  const d = new FaceDetector({ fastMode:true, maxDetectedFaces:1 });
  const t0 = performance.now();
  const faces = await d.detect(canvas);
  const ms = Math.round(performance.now()-t0);
  if(faces && faces.length){ const b=faces[0].boundingBox; return { elapsed_ms:ms, box:{x:b.x,y:b.y,width:b.width,height:b.height} }; }
  return null;
}

/* Flow */
async function analyzeFlow(auto=false){
  try{
    hideReady();
    if(!baseBitmap){ setError("No image decoded."); return; }
    const mode = fixModeSel.value; // 'cdn' | 'blazeonly' | 'native'
    setProgress(10, `Analyzing… (${mode})`);
    await ensureBlaze();

    let canvas = renderWorkingCanvas(1024);
    paintBase(canvas);

    const rough = await roughLocate(canvas);
    if(rough){
      drawBox(rough, "#06b6d4", "rough");
      canvas = renderWorkingCanvas(1024, rough);
      paintBase(canvas);
      drawBox(rough, "#06b6d4", "rough");
    }

    if(mode === "native"){
      try{
        const rFD = await detectWithFaceDetector(canvas);
        if(rFD){ drawBox(rFD.box, "#93c5fd", `FaceDetector • ${rFD.elapsed_ms}ms`); setProgress(70,"FaceDetector ok; confirming…"); }
      }catch(e){ logDiag({ nativeFaceDetector: e.message }); }
      const detN = await detectBlazeMulti(canvas);
      if(detN){ drawBox(detN.box, "#22c55e", `BlazeFace • ${detN.elapsed_ms}ms`); setProgress(100,"Done (native mode)."); showReady(); return; }
      setError("Native mode: no face. Try more zoom/brightness."); return;
    }

    const det = await detectBlazeMulti(canvas);
    if(det){
      drawBox(det.box, "#22c55e", `BlazeFace • ${det.elapsed_ms}ms`);
      setProgress(90, "BlazeFace OK.");
      if(mode === "blazeonly"){ setProgress(100,"Done (Blaze only)."); showReady(); return; }
    } else if(mode === "blazeonly"){
      setError("Blaze-only mode: no face. Adjust zoom/lighting."); return;
    }

    try{
      await ensureFaceApi();
      const sizes=[256,192,160,128];
      for(const s of sizes){
        const opts=new faceapi.TinyFaceDetectorOptions({ inputSize:s, scoreThreshold:0.2 });
        const r=await faceapi.detectSingleFace(canvas, opts).withFaceLandmarks();
        if(r){
          const rr=faceapi.resizeResults(r,{width:canvas.width,height:canvas.height});
          drawBox(rr.detection.box, "#f59e0b", `face-api • ${s}`);
          logDiag({ faceapi_success: { inputSize:s, box: rr.detection.box } });
          setProgress(100, "Done (face-api).");
          showReady();
          return;
        }
      }
      logDiag({ faceapi: "no detection" });
      if(det){ setProgress(100,"Done (BlazeFace only; face‑api none)."); showReady(); }
      else { setError("No face after face‑api."); }
    }catch(e){
      logDiag({ faceapiFallbackFail: e && e.message });
      if(det){ setProgress(100,"Done (BlazeFace only; face‑api unavailable)."); showReady(); }
      else { setError("face‑api unavailable and BlazeFace failed."); }
    }

  }catch(e){ setError(e.message || String(e)); }
}

/* Events & UX */
const onTweak = ()=>{ if(baseBitmap){ const c = renderWorkingCanvas(1024); paintBase(c); } };
zoom.addEventListener("input", ()=>{ zoomLabel.textContent=(+zoom.value).toFixed(2); onTweak(); });
bri.addEventListener("input", ()=>{ briLabel.textContent=(+bri.value).toFixed(2); onTweak(); });
con.addEventListener("input", ()=>{ conLabel.textContent=(+con.value).toFixed(2); onTweak(); });
rotDeg.addEventListener("change", onTweak);

function setModeFromStorage(){
  const saved = localStorage.getItem("yorn_fixMode");
  if(saved && [...fixModeSel.options].some(o=>o.value===saved)){ fixModeSel.value = saved; }
}
fixModeSel.addEventListener("change", ()=>{ localStorage.setItem("yorn_fixMode", fixModeSel.value); });

async function handleBlob(blob, label){
  overlay.classList.add("hidden"); progressText.textContent="";
  hideReady();
  thumb.src = URL.createObjectURL(blob); thumb.classList.remove("hidden");
  setProgress(8,`Decoding ${label}…`);
  baseBitmap = await decodeOriginal(blob);
  setProgress(12,`${label} ready.`);
  const c = renderWorkingCanvas(1024);
  paintBase(c);
  analyzeBtn.disabled=false; enhanceBtn.disabled=false; savePngBtn.disabled=false;
}

fileInput.addEventListener("change", async ()=>{
  if(!fileInput.files.length){ analyzeBtn.disabled=true; enhanceBtn.disabled=true; savePngBtn.disabled=true; return; }
  const f = fileInput.files[0];
  logDiag({ fileName:f.name, type:f.type, size_bytes:f.size });
  await handleBlob(f, "photo");
});

sampleBtn.addEventListener("click", async ()=>{
  const sampleURL="https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1000&auto=format&fit=crop";
  logDiag({ sampleImage: sampleURL });
  const res=await fetch(sampleURL,{cache:"no-store"}); const blob=await res.blob();
  await handleBlob(blob, "sample");
  analyzeFlow(true);
});

enhanceBtn.addEventListener("click", ()=>{
  zoom.value=Math.max(+zoom.value,1.5); zoomLabel.textContent=(+zoom.value).toFixed(2);
  bri.value=Math.max(+bri.value,1.18); briLabel.textContent=(+bri.value).toFixed(2);
  con.value=Math.max(+con.value,1.25); conLabel.textContent=(+con.value).toFixed(2);
  analyzeFlow(true);
});

analyzeBtn.addEventListener("click", ()=> analyzeFlow(false));

savePngBtn.addEventListener("click", ()=>{
  try{
    const url = overlay.toDataURL("image/png");
    const a = Object.assign(document.createElement("a"), { href:url, download:`yorn-${REVISION}.png` });
    document.body.appendChild(a); a.click(); a.remove();
  }catch(e){ logDiag({ savePngError: e && e.message }); }
});

clearLogsBtn.addEventListener("click", ()=>{ diagnostics.textContent = "No diagnostics yet."; });

/* Init */
(function init(){
  if(!("FaceDetector" in window)){
    const opt = [...fixModeSel.options].find(o=>o.value==="native");
    if(opt){ opt.disabled = true; }
    if(fixModeSel.value === "native"){ fixModeSel.value = "blazeonly"; }
  }
  setModeFromStorage();
})();
</script>
</body>
</html>