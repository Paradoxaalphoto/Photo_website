<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>YorN Alpha (Stable Fallback)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;margin:0;padding:16px;background:#f7f7f8;color:#111}
  .row{display:grid;grid-template-columns:1fr auto auto;gap:8px;align-items:end}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:12px;margin-top:12px}
  #progressContainer{height:8px;background:#e5e7eb;border-radius:6px;overflow:hidden;margin-top:8px}
  #progressBar{height:100%;width:0;background:#2563eb;transition:width .25s}
  #overlay{display:block;max-width:100%;margin-top:10px;background:#fff;border:1px solid #e5e7eb;border-radius:8px}
  #thumb{max-width:100%;margin-top:10px;background:#fff;border:1px solid #e5e7eb;border-radius:8px}
  #diagnostics{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;background:#f8fafc;border:1px solid #e5e7eb;border-radius:8px;padding:8px;max-height:260px;overflow:auto}
  button{cursor:pointer}
  .btn{padding:10px 14px;border-radius:8px;border:1px solid #e5e7eb;background:#111;color:#fff}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .btn-secondary{background:#fff;color:#111}
  .controls{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
  label{font-size:12px;color:#374151}
  input[type="range"]{width:100%}
  select, input[type="text"]{width:100%;padding:8px;border:1px solid #e5e7eb;border-radius:8px;background:#fff}
</style>

<!-- TFJS core + optional backends -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@3.21.0/dist/tf-backend-wasm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.21.0/dist/tf-backend-webgl.min.js"></script>

<!-- face-api.js (primary) -->
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

<!-- BlazeFace fallback (UMD via script tag) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
</head>
<body>

<h2>YorN Alpha — Face Analysis</h2>

<div class="card">
  <div class="row">
    <input id="fileInput" type="file" accept="image/*" />
    <button id="sampleBtn" class="btn btn-secondary">Load Sample Image</button>
    <button id="analyzeBtn" class="btn" disabled>Analyze</button>
  </div>

  <div class="controls" style="margin-top:8px">
    <div>
      <label>Backend</label>
      <select id="backendSel">
        <option value="cpu" selected>cpu (most compatible)</option>
        <option value="wasm">wasm</option>
        <option value="webgl">webgl</option>
        <option value="auto">auto (wasm → webgl → cpu)</option>
      </select>
    </div>
    <div>
      <label>Timeout (sec): <span id="timeoutLabel">25</span></label>
      <input id="timeoutSec" type="range" min="8" max="30" step="1" value="25" />
    </div>
    <div>
      <label>Weights override (optional)</label>
      <input id="weightsOverride" type="text" placeholder="https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights" />
    </div>
  </div>

  <div id="progressContainer"><div id="progressBar"></div></div>
  <p id="progressText" style="font-size:12px;color:#4b5563;margin:6px 2px 0 2px;"></p>
</div>

<div class="card">
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
    <div>
      <strong style="font-size:13px">Preview</strong>
      <img id="thumb" class="hidden" alt="Preview" />
      <canvas id="overlay" class="hidden"></canvas>
    </div>
    <div>
      <strong style="font-size:13px">Diagnostics</strong>
      <div id="diagnostics">No diagnostics yet.</div>
    </div>
  </div>
</div>

<script>
/* ---------- UI helpers ---------- */
const $ = id => document.getElementById(id);
const fileInput = $("fileInput"), sampleBtn = $("sampleBtn"), analyzeBtn = $("analyzeBtn");
const overlay = $("overlay"), thumb = $("thumb");
const progressBar = $("progressBar"), progressText = $("progressText");
const diagnostics = $("diagnostics");
const backendSel = $("backendSel"), timeoutSec = $("timeoutSec"), timeoutLabel = $("timeoutLabel");
const weightsOverride = $("weightsOverride");

let WEIGHTS = null, faceapiReady = false, imageFile = null, prepared = null, preparePromise = null, blazeModel = null;

timeoutSec.addEventListener("input", () => timeoutLabel.textContent = timeoutSec.value);

function setProgress(p, t){ progressBar.style.width = (p||0) + "%"; progressText.textContent = t || ""; }
function logDiag(obj){ const now=new Date().toISOString(); const s=typeof obj==="string"?obj:JSON.stringify(obj); diagnostics.textContent = `[${now}] ${s}\n` + diagnostics.textContent; }
function clearDiag(){ diagnostics.textContent = ""; }
function setError(msg){ setProgress(0,""); logDiag({ error: msg }); }

/* ---------- Robust multi-CDN + shard verification (face-api weights) ---------- */
async function fetchJson(url){ const r = await fetch(url, { cache:"no-store" }); if(!r.ok) throw new Error("status "+r.status); return r.json(); }
async function verifyManifestAndShards(base, name){
  const mani = await fetchJson(`${base}/${name}`);
  const shards = (mani.weights||[]).flatMap(w=>w.paths||[]).map(p=>`${base}/${p}`);
  for(const u of shards){ const r = await fetch(u, { cache:"no-store" }); if(!r.ok) throw new Error("shard 404: "+u); }
}
async function pickWeights(){
  if(WEIGHTS){
    await verifyManifestAndShards(WEIGHTS, "tiny_face_detector_model-weights_manifest.json");
    await verifyManifestAndShards(WEIGHTS, "face_landmark_68_model-weights_manifest.json");
    logDiag({ usingWeightsFrom: WEIGHTS, verified:true, source:"override" });
    return;
  }
  const BASES = [
    "https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights",
    "https://unpkg.com/face-api.js@0.22.2/weights",
    "https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights",
    "https://rawcdn.githack.com/justadudewhohacks/face-api.js/0.22.2/weights",
    "https://cdn.jsdelivr.net/gh/vladmandic/face-api/model"
  ];
  for(const b of BASES){
    try{
      await verifyManifestAndShards(b, "tiny_face_detector_model-weights_manifest.json");
      await verifyManifestAndShards(b, "face_landmark_68_model-weights_manifest.json");
      WEIGHTS = b.replace(/\/$/, "");
      logDiag({ usingWeightsFrom: WEIGHTS, verified: true });
      return;
    }catch(e){ logDiag({ cdnAttempt:b, fail: e.message }); }
  }
  throw new Error("No working CDN with complete manifests + shards");
}

/* ---------- Backend selection ---------- */
async function setBackend(){
  if (tf?.wasm?.setWasmPaths) {
    tf.wasm.setWasmPaths("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@3.21.0/dist/");
  }
  const mode = backendSel.value;
  const order = mode==="auto" ? ["wasm","webgl","cpu"] : [mode];
  for(const b of order){
    try{
      await tf.setBackend(b);
      await tf.ready();
      logDiag({ backendSelected: tf.getBackend() });
      return;
    }catch(e){ logDiag({ backendFail:b, msg:e && e.message }); }
  }
  throw new Error("Failed to init any TFJS backend");
}

/* ---------- Image prep (EXIF-aware decode + downscale) ---------- */
async function decodeAndPrepare(file, targetMax=1024){
  if(file.size > 20*1024*1024) throw new Error("Photo too large (>20MB)");
  const opts = { imageOrientation: "from-image" };
  let bmp = await createImageBitmap(file, opts).catch(async ()=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=url; });
    await img.decode?.().catch(()=>{});
    const c = document.createElement("canvas");
    c.width = img.naturalWidth; c.height = img.naturalHeight;
    c.getContext("2d").drawImage(img,0,0);
    URL.revokeObjectURL(url);
    bmp = await createImageBitmap(c);
  });
  const maxSide = Math.max(bmp.width, bmp.height);
  const scale = Math.min(1, targetMax / maxSide);
  const w = Math.max(1, Math.round(bmp.width * scale));
  const h = Math.max(1, Math.round(bmp.height * scale));
  const canvas = Object.assign(document.createElement("canvas"), { width:w, height:h });
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = "high";
  ctx.drawImage(bmp, 0, 0, w, h);
  return { canvas, width:w, height:h };
}

/* ---------- File + sample handlers ---------- */
fileInput.addEventListener("change", async ()=>{
  clearDiag(); setProgress(0,"");
  if(!fileInput.files.length){ analyzeBtn.disabled = true; return; }
  imageFile = fileInput.files[0];
  thumb.src = URL.createObjectURL(imageFile); thumb.classList.remove("hidden");
  analyzeBtn.disabled = true; setProgress(8,"Preparing photo…");
  try{
    preparePromise = decodeAndPrepare(imageFile, 1024);
    prepared = await preparePromise;
    analyzeBtn.disabled = false; setProgress(12,"Photo ready.");
    logDiag({ fileName:imageFile.name, type:imageFile.type, size_bytes:imageFile.size, w:prepared.width, h:prepared.height });
  }catch(e){ setError("Could not prepare photo: "+(e && e.message)); }
});

sampleBtn.addEventListener("click", async ()=>{
  clearDiag(); setProgress(0,"");
  const sampleURL = "https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1000&auto=format&fit=crop";
  logDiag({ sampleImage: sampleURL });
  analyzeBtn.disabled = true; setProgress(8,"Fetching sample…");
  try{
    const res = await fetch(sampleURL, { cache:"no-store" });
    const blob = await res.blob();
    thumb.src = URL.createObjectURL(blob); thumb.classList.remove("hidden");
    preparePromise = decodeAndPrepare(blob, 1024);
    prepared = await preparePromise;
    analyzeBtn.disabled = false; setProgress(12,"Sample ready.");
  }catch(e){ setError("Sample load failed: " + (e && e.message)); }
});

/* ---------- Weights override ---------- */
weightsOverride.addEventListener("change", ()=>{
  const v = weightsOverride.value.trim();
  WEIGHTS = v ? v.replace(/\/$/,"") : null;
  faceapiReady = false;
});

/* ---------- Detection helpers ---------- */
function detectWithTimeout(promise, ms){
  let to; const t = new Promise((_,rej)=> to=setTimeout(()=>rej(new Error("Detection timeout")), ms));
  return Promise.race([promise, t]).finally(()=> clearTimeout(to));
}

async function ensureFaceApi(){
  if(faceapiReady) return;
  setProgress(18,"Verifying weights…"); await pickWeights();
  setProgress(22,"Initializing backend…"); await setBackend();
  setProgress(28,"Loading TinyFaceDetector…"); await faceapi.nets.tinyFaceDetector.loadFromUri(WEIGHTS);
  setProgress(36,"Loading Landmarks…"); await faceapi.nets.faceLandmark68Net.loadFromUri(WEIGHTS);
  await tf.tidy(()=> tf.zeros([1,64,64,3]));  // tiny warmup
  faceapiReady = true; setProgress(44,"Models ready (face-api).");
}

async function detectWithFaceApi(canvas, timeoutMs){
  const sizes = [256, 192, 160, 128];
  for(const s of sizes){
    try{
      setProgress(68, `face-api: detecting (size ${s})…`);
      const opts = new faceapi.TinyFaceDetectorOptions({ inputSize: s, scoreThreshold: 0.2 });
      const det = await detectWithTimeout(faceapi.detectSingleFace(canvas, opts).withFaceLandmarks(), timeoutMs);
      if(det) return { type:"face-api", det, size:s };
    }catch(e){ logDiag({ faceapi_attemptFail:{ size:s, msg:e && e.message } }); await tf.nextFrame(); }
  }
  throw new Error("face-api timeout");
}

async function ensureBlaze(){
  if(blazeModel) return;
  setProgress(52, "Loading BlazeFace…");
  // UMD global is window.blazeface
  if(!window.blazeface) throw new Error("BlazeFace script not loaded");
  blazeModel = await window.blazeface.load();
  logDiag({ fallbackLoaded: "BlazeFace UMD" });
}

async function detectWithBlaze(canvas){
  await ensureBlaze();
  setProgress(70, "BlazeFace: detecting…");
  const t0 = performance.now();
  const faces = await blazeModel.estimateFaces(canvas, false); // returnTensors=false
  const ms = Math.round(performance.now()-t0);
  if(faces && faces.length){
    // faces[0] has topLeft [x,y], bottomRight [x,y]
    const f = faces[0];
    const tl = Array.isArray(f.topLeft) ? f.topLeft : await f.topLeft.array();
    const br = Array.isArray(f.bottomRight) ? f.bottomRight : await f.bottomRight.array();
    const box = { x: tl[0], y: tl[1], width: br[0]-tl[0], height: br[1]-tl[1] };
    return { type:"blazeface", det:{ detection:{ box, score: 0.9 } }, elapsed_ms: ms };
  }
  throw new Error("blaze: no face");
}

function drawResults(canvas, overlay, result){
  const ctx = overlay.getContext("2d");
  overlay.width = canvas.width; overlay.height = canvas.height;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  ctx.drawImage(canvas, 0, 0, overlay.width, overlay.height);

  if(result.type === "face-api"){
    const r = faceapi.resizeResults(result.det, { width: canvas.width, height: canvas.height });
    new faceapi.draw.DrawBox(r.detection.box, { label:`score ${r.detection.score.toFixed(2)} • ${result.size}` }).draw(overlay);
    try{ faceapi.draw.drawFaceLandmarks(overlay, r); }catch(_) {}
  }else{
    const b = result.det.detection.box;
    ctx.strokeStyle = "#22c55e"; ctx.lineWidth = 3;
    ctx.strokeRect(b.x, b.y, b.width, b.height);
    ctx.fillStyle = "#22c55e";
    ctx.font = "12px ui-monospace,monospace";
    ctx.fillText(`BlazeFace`, b.x, Math.max(12, b.y - 4));
  }
  overlay.classList.remove("hidden");
}

/* ---------- Analyze with auto-fallback ---------- */
analyzeBtn.addEventListener("click", async ()=>{
  try{
    if(!prepared && preparePromise) prepared = await preparePromise;
    if(!prepared){ setError("No prepared photo."); return; }

    const timeoutMs = Number(timeoutSec.value) * 1000;
    // 1) Try face-api Tiny
    try{
      await ensureFaceApi();
      const r = await detectWithFaceApi(prepared.canvas, timeoutMs);
      drawResults(prepared.canvas, overlay, r);
      setProgress(100, "Done (face-api).");
      return;
    }catch(e){ logDiag({ primaryFailed: e && e.message }); }

    // 2) Fallback: BlazeFace
    try{
      const r = await detectWithBlaze(prepared.canvas);
      drawResults(prepared.canvas, overlay, r);
      setProgress(100, `Done (fallback BlazeFace in ${r.elapsed_ms}ms).`);
      return;
    }catch(e){
      logDiag({ fallbackFailed: e && e.message });
      setError("No face detected with either engine. Try a closer, front-facing photo.");
    }
  }catch(e){
    setError(e.message || String(e));
  }
});
</script>

</body>
</html>