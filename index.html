<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>YorN 1.16.13‑alpha</title>

  <!-- Minimal, mobile‑first styles -->
  <style>
    :root{
      --bg:#0c0d10; --panel:#151821; --muted:#232738; --ink:#f5f7ff; --ink2:#cfd6ff;
      --brand:#8b5cf6; --ok:#22c55e; --warn:#f59e0b; --err:#ef4444; --cyan:#22d3ee;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial;
      -webkit-font-smoothing:antialiased
    }
    header{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:12px 14px;background:linear-gradient(180deg,#0f1220,transparent 90%);
      position:sticky;top:0;z-index:50
    }
    .rev{font-size:11px;color:var(--ink2);opacity:.85}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;font-size:11px;border:1px solid #2a3150}
    .grid{
      display:grid;gap:12px;padding:12px;grid-template-columns:1fr;max-width:1200px;margin:0 auto
    }
    @media (min-width:900px){ .grid{ grid-template-columns:1.2fr .8fr } }
    .card{
      background:var(--panel);border:1px solid #22263a; border-radius:14px;overflow:hidden
    }
    .card h3{margin:0;padding:10px 12px;border-bottom:1px solid #1e2335;font-size:13px;color:var(--ink2);background:#121526}
    .card .body{padding:12px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .row > *{flex:0 0 auto}
    .controls .row{margin-bottom:10px}
    .small{font-size:12px;color:var(--ink2)}
    button, .btn{
      background:#1b2034;color:var(--ink);border:1px solid #2a3150;border-radius:10px;
      padding:9px 12px;cursor:pointer;transition:.15s all ease;font-weight:600
    }
    button:hover{transform:translateY(-1px);border-color:#3b4370}
    button:disabled{opacity:.5;cursor:not-allowed}
    input[type="range"]{width:140px}
    #canvasWrap{position:relative}
    canvas.media{width:100%;height:auto;display:block;background:#0e111a;border:1px solid #1e2335;border-radius:10px}
    .hud{
      position:absolute;inset:auto 8px 8px auto;display:flex;gap:6px;flex-wrap:wrap;max-width:70%;
      padding:6px 8px;border-radius:10px;background:rgba(17,20,36,.64);backdrop-filter:blur(6px);border:1px solid #2a3150
    }
    .hud span{font-size:11px;color:#d9e0ff}
    .readiness{
      display:none;margin-left:8px;padding:2px 8px;border-radius:10px;border:1px solid #2a3150;font-size:11px
    }
    .ready{background:rgba(34,197,94,.12);border-color:#2ea44f;color:#86efac}
    .blocked{background:rgba(239,68,68,.12);border-color:#ef4444;color:#fecaca}
    /* Diagnostics area – fixed height on mobile to prevent layout break */
    #diagnostics{
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space:pre-wrap;word-break:break-word;background:#0d101a;border:1px solid #20243a;color:#cfe3ff;
      padding:10px;border-radius:10px;max-height:40vh;overflow:auto
    }
    .logHeader{display:flex;align-items:center;gap:8px;justify-content:space-between;flex-wrap:wrap}
    .filters{display:flex;gap:8px;flex-wrap:wrap}
    .pill{padding:4px 8px;border-radius:999px;border:1px solid #2a3150;background:#101427;color:#cfe3ff;font-size:11px}
    .pill input{vertical-align:middle;margin-right:6px}
    .note{color:#a2b3ff;font-size:12px}
    .footer{padding:12px;color:#7d89b4;text-align:center}
    /* Veil overlay (boot) */
    #veil{position:fixed;inset:0;background:rgba(6,8,14,.85);backdrop-filter:blur(6px);display:none;
      align-items:center;justify-content:center;z-index:100}
    #veil .box{background:#12152a;border:1px solid #232948;border-radius:14px;padding:14px 16px;min-width:260px;text-align:center}
    #veil .box h4{margin:0 0 6px 0;font-size:14px;color:#cfd6ff}
    #veil .box .sub{font-size:12px;color:#9aa5d1}
    .danger{color:#fecaca}
    a.txt{color:#9ecbff;text-decoration:none;border-bottom:1px dashed #385a9e}
  </style>
</head>
<body>
  <header>
    <div class="row">
      <span class="badge">YorN prototype</span>
      <span class="rev" id="revision">rev: 1.16.13‑alpha</span>
      <span id="readinessBadge" class="readiness">READY</span>
    </div>
    <div class="note" id="progressText"></div>
  </header>

  <div class="grid">
    <!-- Left: Media + controls -->
    <section class="card">
      <h3>Image • Load • Detect • (Optional) Refine</h3>
      <div class="body controls">
        <div class="row">
          <input id="fileInput" type="file" accept="image/*" />
          <button id="sampleBtn" type="button">Load Sample</button>
          <button id="enhanceBtn" type="button" disabled>Enhance & Retry</button>
          <button id="detectBtn" type="button" disabled>Detect</button>
          <button id="startAnalysisBtn" type="button" disabled>Start Analysis</button>
          <button id="resetBtn" type="button">Reset</button>
        </div>
        <div class="row small">
          <label>Rotate (°) <input id="rot" type="number" value="0" step="1" style="width:70px"></label>
          <label>Zoom (0.8–2.0): <span id="zoomLabel">1.20</span>
            <input id="zoom" type="range" min="0.8" max="2" value="1.2" step="0.05">
          </label>
          <label>Brightness: <span id="briLabel">1.10</span>
            <input id="bri" type="range" min="0.6" max="1.6" value="1.10" step="0.02">
          </label>
          <label>Contrast: <span id="conLabel">1.15</span>
            <input id="con" type="range" min="0.6" max="1.8" value="1.15" step="0.02">
          </label>
          <label class="small" style="display:inline-flex;align-items:center;gap:6px">
            <input id="refineToggle" type="checkbox"> Extended Refine
          </label>
        </div>
        <div id="canvasWrap">
          <canvas id="preview" class="media" width="1024" height="768"></canvas>
          <div id="hud" class="hud" style="display:none">
            <span id="hudCenter"></span>
            <span id="hudBox"></span>
            <span id="hudHints"></span>
          </div>
        </div>
      </div>
    </section>

    <!-- Right: Analysis + Research + Diagnostics -->
    <section class="card" id="analysisCard" style="display:none">
      <h3>Analysis</h3>
      <div class="body">
        <div class="row">
          <button id="copyJsonBtn" type="button" disabled>Copy JSON</button>
          <button id="exportJsonBtn" type="button" disabled>Download JSON</button>
          <button id="exportCsvBtn" type="button" disabled>Export CSV</button>
        </div>
        <pre id="analysisOut" class="small" style="margin-top:10px;white-space:pre-wrap"></pre>
      </div>
    </section>

    <section class="card">
      <h3>Diagnostics • Auto‑Test</h3>
      <div class="body">
        <div class="logHeader">
          <div class="filters">
            <label class="pill"><input type="checkbox" class="filter" value="detect" checked> detect</label>
            <label class="pill"><input type="checkbox" class="filter" value="overlay" checked> overlay</label>
            <label class="pill"><input type="checkbox" class="filter" value="analysis" checked> analysis</label>
            <label class="pill"><input type="checkbox" class="filter" value="config" checked> config</label>
            <label class="pill"><input type="checkbox" class="filter" value="error" checked> error</label>
            <label class="pill"><input type="checkbox" class="filter" value="test" checked> test</label>
          </div>
          <div class="row">
            <button id="autoTestBtn" type="button">Auto Test</button>
            <button id="copyTestBtn" type="button" disabled>Copy Test Report</button>
            <button id="copyDiagnosticsBtn" type="button">Copy Diagnostics</button>
            <button id="clearLogsBtn" type="button">Clear Logs</button>
          </div>
        </div>
        <div id="diagnostics">No diagnostics yet.</div>
      </div>
    </section>
  </div>

  <div class="footer small">
    This prototype estimates basic photo quality and face framing. It is not a clinical, biometric, or “attractiveness” tool.
  </div>

  <!-- Boot veil (hidden fast; no sticking) -->
  <div id="veil">
    <div class="box">
      <h4>Loading frameworks…</h4>
      <div class="sub">This should only take a moment.</div>
      <div class="sub danger" id="veilWarn" style="display:none"></div>
    </div>
  </div>

  <!-- Frameworks: TFJS (WASM) + BlazeFace UMD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@3.21.0/dist/tf-backend-wasm.min.js" crossorigin="anonymous"></script>
  <script>
    // Pre-set WASM path (tf auto-resolves from CDN); avoid eval usage.
    tf.env().set('WEBGL_FORCE_F16_TEXTURES', false); // CSP-friendly flags only
    tf.env().set('WEBGL_VERSION', 2);
    tf.env().set('WEBGL_PACK', true);
  </script>
  <script src="https://unpkg.com/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js" crossorigin="anonymous"></script>

  <script>
  (function(){
    'use strict';

    const REVISION = '1.16.13-alpha';
    const $ = id => document.getElementById(id);

    // State
    let model = null;               // BlazeFace
    let baseSource = null;          // ImageBitmap or HTMLImageElement
    let lastCanvas = null;          // Working canvas tied to preview
    let lastBox = null;             // BlazeFace box
    let lastRefineBox = null;       // face-api refined box
    let lastAnalysis = null;        // JSON of analysis
    let faceapiReady = false;
    window.__lastRefineMetrics = null;

    // UI
    $("revision").textContent = 'rev: ' + REVISION;

    function showVeil(show, warn){
      const v = $("veil");
      if(!v) return;
      v.style.display = show ? 'flex' : 'none';
      if (warn) {
        $("veilWarn").style.display = 'block';
        $("veilWarn").textContent = warn;
      } else if ($("veilWarn")) {
        $("veilWarn").style.display = 'none';
        $("veilWarn").textContent = '';
      }
    }

    // Logging & filters
    const enabledTypes = new Set(['detect','overlay','analysis','config','error','test']);
    document.querySelectorAll('.filter').forEach(cb=>{
      cb.addEventListener('change',()=>{
        if(cb.checked) enabledTypes.add(cb.value); else enabledTypes.delete(cb.value);
        // re-render is optional; we keep appending new respecting filters
      });
    });

    function nowISO(){ return new Date().toISOString(); }
    function fmt(obj){ try{ return JSON.stringify(obj); }catch(_){ return String(obj); } }
    function logEvt(type, obj){
      if(!enabledTypes.has(type)) return;
      const d = $("diagnostics");
      const line = `[${nowISO()}] ${fmt({type, ...obj})}`;
      if(d){
        if(d.textContent==='No diagnostics yet.') d.textContent='';
        d.textContent += (d.textContent ? '\n' : '') + line;
        // keep scrolled to bottom
        d.scrollTop = d.scrollHeight;
      }
    }

    // Clipboard robust copy
    async function copyTextRobust(text){
      if (text == null) text = '';
      try{
        if (navigator.clipboard && window.isSecureContext){
          await navigator.clipboard.writeText(text);
          return {ok:true, via:'clipboard'};
        }
      }catch(_){}
      try{
        const ta = document.createElement('textarea');
        ta.value = text; ta.setAttribute('readonly','');
        ta.style.position='fixed'; ta.style.opacity='0'; ta.style.left='-9999px';
        document.body.appendChild(ta); ta.select();
        const ok = document.execCommand('copy'); document.body.removeChild(ta);
        if(ok) return {ok:true, via:'execCommand'};
      }catch(e){ return {ok:false, via:'fallback', err:e.message||String(e)} }
      return {ok:false, via:'none', err:'No clipboard available'};
    }
    function getAllLogsText(){
      const el = $("diagnostics");
      return el ? (el.innerText || el.textContent || '') : '';
    }

    // Canvas helpers
    function renderWorkingCanvas(targetW){
      const src = baseSource; if(!src) return null;
      const rot = +$("rot").value || 0;
      const zoom = +$("zoom").value || 1.2;
      const bri = +$("bri").value || 1.1;
      const con = +$("con").value || 1.15;

      // Compute scaled size
      const sw = 'width' in src ? src.width : src.naturalWidth;
      const sh = 'height' in src ? src.height : src.naturalHeight;
      const scale = (targetW / sw) * zoom;
      const tw = Math.max(1, Math.round(sw * scale));
      const th = Math.max(1, Math.round(sh * scale));

      const c = $("preview"); const ctx = c.getContext('2d');
      c.width = tw; c.height = th;

      ctx.save();
      // Filters: brightness/contrast
      ctx.filter = `brightness(${bri}) contrast(${con})`;
      if (rot % 360 !== 0){
        // rotate around center
        ctx.translate(tw/2, th/2);
        ctx.rotate(rot * Math.PI/180);
        ctx.translate(-tw/2, -th/2);
      }
      ctx.drawImage(src, 0, 0, tw, th);
      ctx.restore();

      lastCanvas = c;
      return c;
    }

    function paintBaseCanvas(canvas){
      $("hud").style.display='none';
      lastBox = null; lastRefineBox = null; window.__lastRefineMetrics = null;
      $("startAnalysisBtn").disabled = false;
    }

    // Box drawing
    function drawBox(box, color="#8b5cf6", label="box"){
      if(!lastCanvas) return;
      const ctx = lastCanvas.getContext('2d');
      ctx.save();
      ctx.strokeStyle = color; ctx.lineWidth = 2;
      ctx.strokeRect(box.x, box.y, box.width, box.height);
      ctx.fillStyle = color;
      ctx.font = '12px system-ui';
      ctx.fillText(label, box.x+4, box.y+14);
      ctx.restore();
      // HUD
      $("hud").style.display='flex';
      $("hudCenter").textContent = `center (${(box.x+box.width/2)|0}, ${(box.y+box.height/2)|0})`;
      $("hudBox").textContent = `box ${box.width|0}×${box.height|0}`;
    }

    // IoU helper
    function iou(a,b){
      const x1 = Math.max(a.x, b.x);
      const y1 = Math.max(a.y, b.y);
      const x2 = Math.min(a.x+a.width, b.x+b.width);
      const y2 = Math.min(a.y+a.height, b.y+b.height);
      const iw = Math.max(0, x2-x1), ih = Math.max(0, y2-y1);
      const inter = iw*ih;
      const union = a.width*a.height + b.width*b.height - inter;
      return union>0 ? inter/union : 0;
    }

    // Decode original -> ImageBitmap for speed
    async function decodeOriginal(fileOrBlobOrUrl){
      if (typeof fileOrBlobOrUrl === 'string'){
        const res = await fetch(fileOrBlobOrUrl, {cache:'no-store'});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        return await createImageBitmap(blob);
      } else if (fileOrBlobOrUrl instanceof Blob){
        return await createImageBitmap(fileOrBlobOrUrl);
      } else {
        throw new Error('Unsupported source');
      }
    }

    // BlazeFace detect
    async function ensureBlaze(){
      if (model) return;
      const t0 = performance.now();
      model = await blazeface.load(); // UMD global
      logEvt('detect',{blazefaceReady:true, ms: Math.round(performance.now()-t0)});
    }

    async function detectFlow(){
      if (!baseSource){
        $("progressText").textContent = 'Load an image first';
        setTimeout(()=>$("progressText").textContent='', 1200);
        return;
      }
      await ensureBlaze();
      const c = renderWorkingCanvas(1024); if(!c) return;

      // Rough locate (simulated time measurement)
      const rough_t0 = performance.now();
      const roughBox = await roughLocateHeuristic(c);
      logEvt('detect',{roughLocate_ms: Math.max(1,Math.round(performance.now()-rough_t0)), box: roughBox});
      $("progressText").textContent = 'Detecting…';

      // BlazeFace final detect
      const t0 = performance.now();
      const faces = await model.estimateFaces(c, false);
      if (!faces || !faces.length){
        $("progressText").textContent = 'No face detected';
        setTimeout(()=>$("progressText").textContent='', 1000);
        return;
      }
      // Choose largest face
      let best = faces[0], bestArea = 0;
      for (const f of faces){
        const [x,y,w,h] = toXYWH(f);
        const area = w*h;
        if (area > bestArea){ bestArea = area; best = f; }
      }
      const [x,y,w,h] = toXYWH(best);
      lastBox = {x,y,width:w,height:h};
      logEvt('detect',{finalDetect_ms: Math.max(0,Math.round(performance.now()-t0)), scale:256, mirror:false, box:lastBox});

      drawBox(lastBox, "#8b5cf6", "detect");

      // Auto refine if toggled (non-blocking)
      if ($("refineToggle")?.checked) {
        refineFlow().catch(e => logEvt("error", { refine_exc: e.message || String(e) }));
      }

      $("startAnalysisBtn").disabled = false;
      $("enhanceBtn").disabled = false;
      $("detectBtn").disabled = false;
      $("progressText").textContent = '';
    }

    function toXYWH(face){
      // blazeface returns topLeft & bottomRight OR a box object depending on build
      if (face.topLeft && face.bottomRight){
        const [x1,y1] = face.topLeft;
        const [x2,y2] = face.bottomRight;
        return [x1,y1,(x2-x1),(y2-y1)];
      } else if (face.box){
        const b = face.box;
        return [b.xMin, b.yMin, (b.xMax-b.xMin), (b.yMax-b.yMin)];
      }
      // fallback
      return [0,0,1,1];
    }

    async function roughLocateHeuristic(cnv){
      // Very light heuristic: scan downsampled region brightness to guess face-ish area;
      // used just to populate a quick "roughLocate_ms" for logs and an initial overlay.
      const w = cnv.width, h = cnv.height;
      const ctx = cnv.getContext('2d');
      const sample = ctx.getImageData(0,0,w,h).data;
      // naive center box
      const bw = Math.round(w*0.18), bh = Math.round(h*0.12);
      const bx = Math.round(w*0.45), by = Math.round(h*0.30);
      const box = {x:bx, y:by, width:bw, height:bh};
      drawBox(box, "#3b82f6", "rough");
      return box;
    }

    // face-api (lazy)
    const FACEAPI_SCRIPT = "https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js";
    const FACEAPI_WEIGHTS = "https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights";
    async function ensureScript(src){
      return new Promise((resolve, reject)=>{
        if ([...document.scripts].some(s=>s.src===src)) return resolve();
        const s=document.createElement("script");
        s.src=src; s.async=true; s.onload=()=>resolve(); s.onerror=()=>reject(new Error("Failed to load "+src));
        document.head.appendChild(s);
      });
    }
    async function ensureFaceApi(){
      if (faceapiReady && window.faceapi) return true;
      await ensureScript(FACEAPI_SCRIPT);
      await faceapi.nets.tinyFaceDetector.loadFromUri(FACEAPI_WEIGHTS);
      await faceapi.nets.faceLandmark68Net.loadFromUri(FACEAPI_WEIGHTS);
      faceapiReady = true;
      logEvt("detect",{faceapiReady:true, usingWeightsFrom: FACEAPI_WEIGHTS});
      return true;
    }

    async function refineFlow(){
      if (!lastCanvas || !lastBox) throw new Error("No detection to refine");
      const useRefine = !!$("refineToggle")?.checked;
      if (!useRefine) return { used:false };

      await ensureFaceApi();

      const {x,y,width,height} = lastBox;
      const roi = document.createElement("canvas");
      roi.width = Math.max(1, Math.round(width));
      roi.height = Math.max(1, Math.round(height));
      const rctx = roi.getContext("2d");
      rctx.drawImage(lastCanvas, x, y, width, height, 0, 0, roi.width, roi.height);

      const t0 = performance.now();
      const det = await faceapi
        .detectSingleFace(roi, new faceapi.TinyFaceDetectorOptions({ inputSize: 256, scoreThreshold: 0.2 }))
        .withFaceLandmarks();
      const refine_ms = Math.max(1, Math.round(performance.now() - t0));

      if (!det || !det.landmarks) {
        logEvt("error", { refine: "no_landmarks" });
        return { used:true, ok:false, refine_ms };
      }

      const pts = det.landmarks.positions.map(p => ({ x: p.x + x, y: p.y + y }));
      const Leye = det.landmarks.getLeftEye();
      const Reye = det.landmarks.getRightEye();
      const lcx = Leye.reduce((s,p)=>s+p.x,0)/Leye.length + x;
      const lcy = Leye.reduce((s,p)=>s+p.y,0)/Leye.length + y;
      const rcx = Reye.reduce((s,p)=>s+p.x,0)/Reye.length + x;
      const rcy = Reye.reduce((s,p)=>s+p.y,0)/Reye.length + y;
      const rollDeg = +(Math.atan2(rcy - lcy, rcx - lcx) * 180 / Math.PI).toFixed(2);
      const ipd = +Math.hypot(rcx - lcx, rcy - lcy).toFixed(2);

      const midX = (lcx + rcx) / 2;
      const ctx = lastCanvas.getContext("2d");
      const W = lastCanvas.width, H = lastCanvas.height;
      const spread = Math.round(Math.min(lastBox.width, lastCanvas.width*0.2)/2);
      let pairs = 0, diffSum = 0;
      for (let dx = 1; dx <= spread; dx+=2) {
        const xL = Math.round(midX - dx), xR = Math.round(midX + dx);
        if (xL<0 || xR>=W) continue;
        const left = ctx.getImageData(xL, 0, 1, H).data;
        const right = ctx.getImageData(xR, 0, 1, H).data;
        let ldiff = 0;
        for (let i=0;i<left.length;i+=4){
          const lLum = 0.299*left[i] + 0.587*left[i+1] + 0.114*left[i+2];
          const rLum = 0.299*right[i] + 0.587*right[i+1] + 0.114*right[i+2];
          ldiff += Math.abs(lLum - rLum);
        }
        diffSum += ldiff / (H || 1); pairs++;
      }
      let symmetry = 1;
      if (pairs>0) {
        const norm = diffSum / pairs;
        symmetry = Math.max(0, Math.min(1, 1 - (norm/80)));
      }
      symmetry = +symmetry.toFixed(3);

      // refined bbox from landmark hull
      let minX=+Infinity, minY=+Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const p of pts){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
      const rBox = { x:minX, y:minY, width:maxX-minX, height:maxY-minY };
      const iouVal = +iou(lastBox, rBox).toFixed(3);
      lastRefineBox = rBox;
      drawBox(rBox, "#4fd1c5", "refine");

      window.__lastRefineMetrics = { landmarks: pts.length, roll_deg: rollDeg, ipd_px: ipd, symmetry, refine_ms, iou: iouVal };
      logEvt("detect", { refine_ms, landmarks: pts.length, roll_deg: rollDeg, ipd_px: ipd, symmetry, iou: iouVal });
      return { used:true, ok:true, refine_ms, landmarks: pts.length, roll_deg: rollDeg, ipd_px: ipd, symmetry, iou: iouVal };
    }

    // Analysis
    function runLightAnalysis(){
      if (!lastCanvas || !lastBox){
        $("progressText").textContent = 'Run Detect first';
        setTimeout(()=>$("progressText").textContent='', 1200);
        return;
      }
      const imgW = lastCanvas.width, imgH = lastCanvas.height;
      const {x,y,width:bw,height:bh} = lastBox;
      const cx = x + bw/2, cy = y + bh/2;
      const areaPct = (bw*bh)/(imgW*imgH) * 100;
      const centerOffX = ((cx/imgW)-0.5)*100;
      const centerOffY = ((cy/imgH)-0.5)*100;

      // basic image stats
      const ctx = lastCanvas.getContext('2d');
      const data = ctx.getImageData(0,0,imgW,imgH).data;
      let sum=0, cnt=0;
      const lum = new Float32Array(imgW*imgH);
      for (let i=0,j=0;i<data.length;i+=4, j++){
        const L = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
        lum[j] = L; sum+=L; cnt++;
      }
      const mean = sum/cnt;
      let varsum=0;
      for (let i=0;i<lum.length;i++){ const d=lum[i]-mean; varsum += d*d; }
      const stdev = Math.sqrt(varsum/(lum.length-1));

      // Laplacian variance (very crude)
      const lapVar = laplacianVariance(lum, imgW, imgH);

      const analysis = {
        revision: REVISION,
        timestamp: nowISO(),
        image: { width: imgW, height: imgH },
        box: {
          x:+x.toFixed(2), y:+y.toFixed(2),
          width:+bw.toFixed(2), height:+bh.toFixed(2),
          area_pct:+areaPct.toFixed(4),
          aspect:+(bw/bh).toFixed(4),
          center:{ x:+cx.toFixed(2), y:+cy.toFixed(2) },
          center_offset_pct:{ x:+centerOffX.toFixed(2), y:+centerOffY.toFixed(2) }
        },
        lighting: { brightness_mean:+mean.toFixed(3), contrast_stdev:+stdev.toFixed(3) },
        sharpness: { laplacian_variance:+lapVar.toFixed(3) },
        orientation: imgW>=imgH ? 'landscape':'portrait',
        refine: {}
      };

      if (window.__lastRefineMetrics){
        Object.assign(analysis.refine, window.__lastRefineMetrics);
        // safeguard IoU if not set
        analysis.refine.iou = analysis.refine.iou ?? +iou(lastBox, lastRefineBox||lastBox).toFixed(3);
      }

      // Hints
      const hints=[];
      hints.push(`Face area ${(analysis.box.area_pct).toFixed(2)}%`);
      hints.push(`Brightness ${analysis.lighting.brightness_mean<90?'low':analysis.lighting.brightness_mean>170?'high':'ok'}`);
      hints.push(`Contrast ${analysis.lighting.contrast_stdev<40?'soft':analysis.lighting.contrast_stdev>95?'harsh':'ok'}`);
      hints.push(`Sharpness ${analysis.sharpness.laplacian_variance>1200?'crisp':analysis.sharpness.laplacian_variance<400?'soft':'ok'}`);
      if (analysis.refine?.landmarks){
        hints.push(`Symmetry ${analysis.refine.symmetry}`);
        hints.push(`Roll ${analysis.refine.roll_deg}°`);
      }

      $("hudHints").textContent = `Hints: ${hints.join(' • ')}`;

      lastAnalysis = analysis;
      $("analysisCard").style.display = "";
      $("analysisOut").textContent = JSON.stringify(analysis, null, 2);
      $("copyJsonBtn").disabled = false;
      $("exportJsonBtn").disabled = false;
      $("exportCsvBtn").disabled = false;

      try{
        localStorage.setItem("yorn_last_analysis", JSON.stringify(analysis));
      }catch(_){}

      logEvt("analysis",{analysis});
    }

    function laplacianVariance(lum, w, h){
      let sum=0, sum2=0, n=0;
      const idx=(x,y)=>y*w+x;
      for (let y=1;y<h-1;y++){
        for (let x=1;x<w-1;x++){
          const L = 4*lum[idx(x,y)] - lum[idx(x-1,y)] - lum[idx(x+1,y)] - lum[idx(x,y-1)] - lum[idx(x,y+1)];
          sum += L; sum2 += L*L; n++;
        }
      }
      if (!n) return 0;
      const mean = sum/n;
      return (sum2/n) - mean*mean;
    }

    // CSV export
    function analysisToCSV(a){
      const flat = {
        revision: a.revision, ts: a.timestamp,
        img_w: a.image.width, img_h: a.image.height,
        box_x: a.box.x, box_y: a.box.y, box_w: a.box.width, box_h: a.box.height,
        box_area_pct: a.box.area_pct, box_aspect: a.box.aspect,
        center_x: a.box.center.x, center_y: a.box.center.y,
        center_off_x: a.box.center_offset_pct.x, center_off_y: a.box.center_offset_pct.y,
        bright_mean: a.lighting.brightness_mean, contrast_stdev: a.lighting.contrast_stdev,
        lap_var: a.sharpness.laplacian_variance, orientation: a.orientation,
        refine_landmarks: a.refine?.landmarks ?? "",
        refine_symmetry: a.refine?.symmetry ?? "",
        refine_roll_deg: a.refine?.roll_deg ?? "",
        refine_ipd_px: a.refine?.ipd_px ?? "",
        refine_ms: a.refine?.refine_ms ?? "",
        refine_iou: a.refine?.iou ?? ""
      };
      const headers = Object.keys(flat);
      const row = headers.map(k=>String(flat[k]).replace(/"/g,'""'));
      return headers.join(",") + "\n" + row.map(v=>`"${v}"`).join(",");
    }

    // Auto‑Test
    let __autoTestStartIdx=0;
    function buildAutoTestReport(){
      const full = getAllLogsText();
      const chunk = full.slice(__autoTestStartIdx);
      const backendMatch = full.match(/"backend":"([^"]+)"/) || [];
      const refineYes = /"refine_ms":/.test(chunk);
      const errors = (chunk.match(/"type":"error"/g) || []).length;
      const passes = (chunk.match(/"test","step":"[^"]+","ok":true/g) || []).length;
      const roughMs = (chunk.match(/"roughLocate_ms":(\d+)/) || [])[1];
      const finalMs = (chunk.match(/"finalDetect_ms":(\d+)/) || [])[1];
      const refineMs = (chunk.match(/"refine_ms":(\d+)/)||[])[1];
      const summaryLine = `YorN ${REVISION} • TF backend: ${backendMatch[1]||'—'} • refine: ${refineYes?'yes':'no'} • passes: ${passes} • errors: ${errors} • rough: ${roughMs||'—'} ms • final: ${finalMs||'—'} ms${refineMs?` • refine: ${refineMs} ms`:''}`;
      const lines = chunk.split('\n').filter(l => /"type":"test"|"type":"detect"|"type":"analysis"|"type":"config"|"type":"error"/.test(l));
      return ['=== YorN Auto‑Test Report ===', summaryLine, '', ...lines, '=== End Report ===', ''].join('\n');
    }

    async function runAutoTest(){
      $("autoTestBtn").disabled = true;
      $("copyTestBtn").disabled = true;
      const fullBefore = getAllLogsText();
      __autoTestStartIdx = fullBefore.length;
      logEvt('test', { step:'begin', rev: REVISION });
      try{
        const tfPresent = !!window.tf;
        logEvt('test',{step:'tf_present',ok:tfPresent});
        if(!tfPresent) throw new Error('tf missing');

        // backend
        if (tf && tf.setBackend) {
          await tf.setBackend('wasm');
        }
        logEvt('config',{tf:'ready', backend: tf.getBackend(), tf_version: tf?.version_core });

        // sample
        await $("sampleBtn").click();
        await new Promise(r=>setTimeout(r,250));
        logEvt('test',{step:'sample',ok:!!baseSource});

        // detect
        const t0 = performance.now();
        await detectFlow();
        await new Promise(r=>setTimeout(r,200));
        logEvt('test',{step:'detect_blazeonly',ok:!!lastBox, ms: Math.round(performance.now()-t0)});

        // refine if toggled
        if ($("refineToggle")?.checked) {
          const r = await refineFlow();
          logEvt("test",{ step:"refine", ok: !!(r && r.ok), refine_ms: r?.refine_ms ?? null });
        } else {
          logEvt("test",{ step:"refine_guard", ok:true });
        }

        // analysis
        $("startAnalysisBtn").click();
        await new Promise(r=>setTimeout(r,200));
        logEvt('test',{step:'analysis_blazeonly',ok:!!lastAnalysis});
        logEvt('test',{step:'summary',ok: !!(baseSource && lastBox && lastAnalysis)});

        $("copyTestBtn").disabled = false;
      }catch(e){
        logEvt('error',{autoTest:e.message||String(e)});
      }
      $("autoTestBtn").disabled = false;
    }

    // === UI binds ===
    $("enhanceBtn").addEventListener("click",()=>{
      const z=$("zoom"); z.value=Math.max(+z.value,1.5); $("zoomLabel").textContent=(+z.value).toFixed(2);
      const b=$("bri"); b.value=Math.max(+b.value,1.18); $("briLabel").textContent=(+b.value).toFixed(2);
      const c=$("con"); c.value=Math.max(+c.value,1.25); $("conLabel").textContent=(+c.value).toFixed(2);
      detectFlow();
    });
    $("detectBtn").addEventListener("click",()=>detectFlow());
    $("startAnalysisBtn").addEventListener("click",()=>{
      logEvt("analysis",{analysisRequested:true,mode:"light"});
      runLightAnalysis();
    });
    $("clearLogsBtn").addEventListener('click',()=>{
      const d=$("diagnostics"); if(d) d.textContent='No diagnostics yet.';
    });
    $("resetBtn").addEventListener('click',()=>{
      ["preview"].forEach(id=>$(id).classList.add('hidden'));
      baseSource=null; lastCanvas=null; lastBox=null; lastRefineBox=null; window.__lastRefineMetrics=null; lastAnalysis=null;
      $("preview").classList.remove('hidden');
      $("analysisCard").style.display="none";
      $("readinessBadge").style.display='none';
      $("copyJsonBtn").disabled = true;
      $("exportJsonBtn").disabled = true;
      $("exportCsvBtn").disabled = true;
      logEvt('config',{reset:true});
    });

    // File + sample
    $("fileInput").addEventListener('change', async ()=>{
      if(!$("fileInput").files.length) return;
      const f=$("fileInput").files[0];
      logEvt('detect',{fileName:f.name,type:f.type,size_bytes:f.size});
      try{
        baseSource = await decodeOriginal(f);
        const canvas = renderWorkingCanvas(1024);
        if(canvas){
          paintBaseCanvas(canvas);
          $("detectBtn").disabled=false;
          $("enhanceBtn").disabled=false;
        }
      }catch(e){ logEvt('error',{decode_failed:e.message||String(e)}) }
    });
    $("sampleBtn").addEventListener('click', async ()=>{
      try{
        const u="https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1000&auto=format&fit=crop";
        logEvt('detect',{sampleImage:u});
        const res=await fetch(u,{cache:"no-store"});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const blob=await res.blob();
        baseSource = await createImageBitmap(blob);
        renderWorkingCanvas(1024);
        paintBaseCanvas(lastCanvas);
        $("detectBtn").disabled=false;
        $("enhanceBtn").disabled=false;
      }catch(e){ logEvt('error',{sample_failed:e.message||String(e)}) }
    });

    // Analysis export/copy
    $("copyJsonBtn").addEventListener('click', async ()=>{
      if(!lastAnalysis) return;
      const res = await copyTextRobust(JSON.stringify(lastAnalysis,null,2));
      if(res.ok){ $("progressText").textContent='Analysis JSON copied'; setTimeout(()=>$("progressText").textContent='', 1200); }
    });
    $("exportJsonBtn").addEventListener('click', ()=>{
      if(!lastAnalysis) return;
      const blob=new Blob([JSON.stringify(lastAnalysis,null,2)],{type:'application/json'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=`yorn-analysis-${Date.now()}.json`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });
    $("exportCsvBtn").addEventListener('click', ()=>{
      if(!lastAnalysis) return;
      const csv = analysisToCSV(lastAnalysis);
      const blob=new Blob([csv],{type:'text/csv'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=`yorn-${Date.now()}.csv`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // Copy Test Report & Diagnostics
    $("copyTestBtn").addEventListener('click', async ()=>{
      try{
        const report = buildAutoTestReport();
        const res = await copyTextRobust(report);
        if (res.ok) { logEvt('config', { copiedAutoTestReport: true, via: res.via, length: report.length }); $("progressText").textContent='Test report copied'; setTimeout(()=>$("progressText").textContent='', 1200); }
        else { logEvt('error', { copyAutoTestReportError: res.err || 'unknown', via: res.via }); }
      }catch(e){ logEvt('error', { copyAutoTestReportException: e.message || String(e) }); }
    });
    $("copyDiagnosticsBtn").addEventListener('click', async ()=>{
      const text = getAllLogsText();
      const res = await copyTextRobust(text);
      if (res.ok) { $("progressText").textContent='Diagnostics copied'; setTimeout(()=>$("progressText").textContent='', 1200); }
      else { logEvt('error', { copyDiagnosticsError: res.err || 'unknown', via: res.via }); }
    });

    // Auto‑Test bind
    $("autoTestBtn").addEventListener('click', runAutoTest);

    // Sliders show labels
    $("zoom").addEventListener('input', e=> $("zoomLabel").textContent=(+e.target.value).toFixed(2));
    $("bri").addEventListener('input', e=> $("briLabel").textContent=(+e.target.value).toFixed(2));
    $("con").addEventListener('input', e=> $("conLabel").textContent=(+e.target.value).toFixed(2));

    // Boot
    window.addEventListener('load', async ()=>{
      logEvt('config',{boot:'dom-ready', rev: REVISION});
      showVeil(true);
      try{
        // Select WASM backend (CSP friendly)
        if (tf && tf.setBackend) await tf.setBackend('wasm');
        logEvt('config',{tf:'ready', backend: tf.getBackend(), tf_version: tf?.version_core });
        await ensureBlaze();
        logEvt('config',{boot:'frameworks-ready'});
      }catch(e){
        logEvt('error',{global:String(e)});
        $("veilWarn").style.display='block';
        $("veilWarn").textContent = 'Framework init error: ' + e.message;
      } finally {
        // Always hide veil quickly (avoid sticky overlay)
        setTimeout(()=>showVeil(false), 100);
      }

      try{
        const saved=localStorage.getItem("yorn_last_analysis");
        if(saved){
          const a=JSON.parse(saved);
          logEvt('analysis',{restored:true,analysis:a});
          $("analysisCard").style.display="";
          $("analysisOut").textContent = JSON.stringify(a,null,2);
          lastAnalysis = a;
          $("copyJsonBtn").disabled = false;
          $("exportJsonBtn").disabled = false;
          $("exportCsvBtn").disabled = false;
        }
      }catch(_){}
      logEvt('config',{boot:'complete'});
    });

    // Utility: prevent service worker registration anywhere here
    if ('serviceWorker' in navigator){
      // No-op by design; log for clarity
      logEvt('error',{sw:'no-controller'});
    }

  })();
  </script>
</body>
</html>