<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>YorN • 1.16.9-alpha</title>
<style>
  :root{
    --bg:#0b0e12; --panel:#121720; --ink:#e7edf6; --muted:#9fb0c6; --accent:#68d391; --warn:#ffb020; --bad:#ff6b6b; --line:#243043;
    --pad:12px; --radius:14px; --radius-sm:10px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
  .wrap{max-width:980px;margin:0 auto;padding:18px}
  h1{font-size:18px;margin:0 0 12px 0;display:flex;align-items:center;gap:10px}
  .rev{font:600 12px/1 ui-monospace,Menlo,Consolas;background:#0f1420;border:1px solid var(--line);padding:4px 8px;border-radius:999px;color:#9ad;display:flex;align-items:center;gap:6px}
  .badge{font:600 11px/1 ui-monospace,Menlo,Consolas;padding:2px 8px;border-radius:999px;border:1px solid var(--line)}
  .ok{background:#0f1a14;color:#aef2c0;border-color:#163a27}
  .bad{background:#1f1313;color:#ffc7c7;border-color:#3e1b1b}
  .row{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:860px){.row{grid-template-columns:1.2fr .8fr}}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);padding:var(--pad);}
  .card h3{margin:0 0 8px 0;font-size:14px;color:#cfe0fb}
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin:10px 0}
  button,.btn{background:#162030;border:1px solid var(--line);color:var(--ink);padding:8px 12px;border-radius:10px;font-weight:600}
  button:disabled{opacity:.5}
  input[type="range"]{width:160px}
  label.small{font-size:12px;color:var(--muted);margin-right:6px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  canvas, img{max-width:100%;border-radius:12px;display:block}
  .hud{position:relative}
  .hud canvas{position:absolute;inset:0;pointer-events:none}
  #diagnostics{height:240px;overflow:auto;background:#0c1119;border:1px solid var(--line);border-radius:10px;padding:10px;font:12px/1.45 ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap;word-break:break-word}
  .muted{color:var(--muted)}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid var(--line);font:12px ui-monospace,Menlo,Consolas}
  .inline{display:inline-flex;gap:8px;align-items:center}
  .spacer{flex:1}
  .toast{min-height:18px;color:#cce9d8}
</style>
</head>
<body>
  <div class="wrap">
    <h1>
      YorN
      <span class="rev">rev <span id="rev">1.16.9-alpha</span></span>
      <span id="autoBadge" class="badge bad" title="Auto Test hasn’t run yet">AUTO TEST • —</span>
      <span class="spacer"></span>
      <span class="muted">Lightweight face analysis prototype</span>
    </h1>

    <div class="row">
      <div class="card">
        <h3>Image</h3>
        <div class="controls">
          <label class="small">Choose</label>
          <input id="fileInput" type="file" accept="image/*" />
          <button id="sampleBtn" type="button">Load Sample</button>
          <span class="spacer"></span>
          <span id="progressText" class="pill muted">Idle</span>
        </div>
        <div class="grid2">
          <div>
            <div class="hud">
              <canvas id="base" width="0" height="0"></canvas>
              <canvas id="overlay" width="0" height="0"></canvas>
            </div>
          </div>
          <div class="card" style="background:#0e141f">
            <h3>Controls</h3>
            <div class="controls">
              <button id="enhanceBtn" type="button" disabled>Enhance & Retry</button>
              <button id="detectBtn" type="button" disabled>Detect</button>
              <button id="startAnalysisBtn" type="button" disabled>Start Analysis</button>
            </div>
            <div class="controls">
              <label class="small">Rotate (°)</label><input id="rot" type="range" min="-20" max="20" step="1" value="0">
              <label class="small">Zoom</label><input id="zoom" type="range" min="0.8" max="2.0" step="0.05" value="1.20"><span id="zoomLabel" class="small">1.20</span>
            </div>
            <div class="controls">
              <label class="small">Brightness</label><input id="bri" type="range" min="0.6" max="1.6" step="0.02" value="1.10"><span id="briLabel" class="small">1.10</span>
              <label class="small">Contrast</label><input id="con" type="range" min="0.7" max="1.7" step="0.02" value="1.15"><span id="conLabel" class="small">1.15</span>
            </div>
            <div class="controls">
              <button id="autoTestBtn" type="button">Auto Test</button>
              <button id="copyTestBtn" type="button" disabled>Copy Auto Test</button>
              <button id="copyDiagBtn" type="button">Copy Diagnostics</button>
              <button id="clearLogsBtn" type="button">Clear Logs</button>
              <button id="resetBtn" type="button">Reset</button>
            </div>
            <div class="toast" id="toast"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <h3 class="inline">
          Diagnostics
          <span class="pill muted">backend: <span id="backend">—</span></span>
          <span class="pill muted">mem: <span id="mem">—</span></span>
        </h3>
        <div id="diagnostics">No diagnostics yet.</div>

        <div id="analysisCard" class="card" style="margin-top:12px; display:none;">
          <h3>Analysis</h3>
          <div id="analysisSummary" class="muted">—</div>
          <div class="controls">
            <button id="copyJsonBtn" type="button" disabled>Copy Analysis JSON</button>
            <button id="exportJsonBtn" type="button" disabled>Download JSON</button>
          </div>
        </div>

      </div>
    </div>
  </div>

<!-- libs (BlazeFace UMD & minimal helpers) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@3.21.0/dist/tf-backend-wasm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@3.21.0/dist/tf-core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@3.21.0/dist/tf-converter.min.js"></script>
<script>tf.env().set('WEBGL_CPU_FORWARD', true);</script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>

<script>
/* ========= constants / state ========= */
const REVISION = "1.16.9-alpha";
const $ = id => document.getElementById(id);
const diagEl = $("diagnostics");
let baseSource = null;        // ImageBitmap
let lastCanvas = null;        // HTMLCanvasElement
let lastBox = null;           // {x,y,width,height}
let lastRefineBox = null;     // optional refine box for IoU
let blazeModel = null;
let lastAnalysis = null;

/* ========= utils / logging ========= */
function logLine(obj){
  const now = new Date().toISOString();
  diagEl.textContent += (diagEl.textContent ? "\n" : "") + `[${now}] ${JSON.stringify(obj)}`;
  diagEl.scrollTop = diagEl.scrollHeight;
}
function logEvt(type, obj){ logLine({type, ...(obj||{})}); }
function setToast(msg){ $("toast").textContent = msg || ""; if(msg){ setTimeout(()=>$("toast").textContent="", 1600); } }
function setProgress(pct,msg){ $("progressText").textContent = msg || ""; }

/* ========= memory/env probe ========= */
function envProbe(){
  let dm = (navigator.deviceMemory ? navigator.deviceMemory + " GB" : "—");
  let heap = "—";
  try{
    if (performance && performance.memory) {
      const { usedJSHeapSize, jsHeapSizeLimit } = performance.memory;
      heap = (usedJSHeapSize/1048576).toFixed(0)+" / "+(jsHeapSizeLimit/1048576).toFixed(0)+" MB";
    }
  }catch(_){}
  $("mem").textContent = `${dm}${heap!=="—" ? (" • " + heap) : ""}`;
}
envProbe();

/* ========= canvas helpers ========= */
function paintBaseCanvas(canvas){
  const ctx = canvas.getContext("2d");
  ctx.filter = `brightness(${+$("bri").value}) contrast(${+$("con").value})`;
  ctx.save();
  const deg = +$("rot").value;
  if (deg !== 0) {
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.rotate(deg * Math.PI/180);
    ctx.translate(-canvas.width/2, -canvas.height/2);
  }
  ctx.drawImage(baseSource, 0, 0, canvas.width, canvas.height);
  ctx.restore();
  const o = $("overlay");
  o.width = canvas.width; o.height = canvas.height;
  $("base").replaceWith(canvas); canvas.id="base"; lastCanvas = canvas;
  logEvt("overlay",{painted:{w:canvas.width,h:canvas.height}});
}
function renderWorkingCanvas(targetMax=1024){
  if(!baseSource) return null;
  const z = +$("zoom").value || 1.0;
  const w = Math.round(Math.min(targetMax, baseSource.width * z));
  const h = Math.round(w * (baseSource.height / baseSource.width));
  const c = document.createElement("canvas");
  c.width = w; c.height = h;
  return c;
}
function drawBox(box, color="#68d391", label="face"){
  const c = $("overlay");
  const g = c.getContext("2d");
  g.clearRect(0,0,c.width,c.height);
  g.strokeStyle = color; g.lineWidth = 3;
  g.strokeRect(box.x, box.y, box.width, box.height);
  g.fillStyle = color;
  g.font = "12px ui-monospace, Menlo, Consolas";
  g.fillText(`${label}`, box.x+6, Math.max(12, box.y-6));
}

/* ========= detection ========= */
async function ensureBlaze(){
  if (blazeModel) return blazeModel;
  try{
    // prefer WASM to avoid CSP issues
    if (tf && tf.setBackend) {
      await tf.setBackend('wasm');
      await tf.ready();
      $("backend").textContent = "wasm";
      logEvt("config",{tf:"ready", backend:"wasm"});
    }
  }catch(e){
    $("backend").textContent = "—";
    logEvt("error",{tf_init: e.message||String(e)});
  }
  blazeModel = await blazeface.load();
  logEvt("detect",{blazefaceReady:true});
  return blazeModel;
}

async function decodeOriginal(fileOrBlob){
  const blob = fileOrBlob instanceof Blob ? fileOrBlob : new Blob([fileOrBlob]);
  const bmp = await createImageBitmap(blob);
  logEvt("detect",{decode:"createImageBitmap", w:bmp.width, h:bmp.height});
  return bmp;
}

async function detectFlow(){
  if(!baseSource){ setToast("Load a photo first"); return; }
  await ensureBlaze();
  const canvas = lastCanvas || renderWorkingCanvas(1024);
  if (!lastCanvas) paintBaseCanvas(canvas);
  const z = +$("zoom").value || 1.2;
  logEvt("overlay",{autoZoomApplied:z});
  // run Blaze
  const t0 = performance.now();
  const preds = await blazeModel.estimateFaces(canvas, false);
  const dt = Math.round(performance.now() - t0);
  if (!preds || !preds.length){
    setToast("No face found");
    logEvt("detect",{finalDetect_ms:dt, none:true});
    return;
  }
  // choose largest
  let best = preds[0];
  let bestArea = (best.bottomRight[0]-best.topLeft[0])*(best.bottomRight[1]-best.topLeft[1]);
  for(const p of preds){
    const area = (p.bottomRight[0]-p.topLeft[0])*(p.bottomRight[1]-p.topLeft[1]);
    if (area > bestArea){ best=p; bestArea=area; }
  }
  const box = {
    x: best.topLeft[0],
    y: best.topLeft[1],
    width: best.bottomRight[0]-best.topLeft[0],
    height: best.bottomRight[1]-best.topLeft[1]
  };
  lastBox = box;
  drawBox(box, "#68d391", "blaze");
  logEvt("detect",{finalDetect_ms:dt, scale:256, mirror:false, box});
  $("startAnalysisBtn").disabled = false;
}

function iou(a,b){
  const x1 = Math.max(a.x, b.x);
  const y1 = Math.max(a.y, b.y);
  const x2 = Math.min(a.x+a.width, b.x+b.width);
  const y2 = Math.min(a.y+a.height, b.y+b.height);
  const inter = Math.max(0, x2-x1) * Math.max(0, y2-y1);
  const areaA = a.width*a.height, areaB = b.width*b.height;
  const uni = areaA + areaB - inter;
  return uni>0 ? inter/uni : 0;
}

/* ========= lightweight analysis ========= */
function runLightAnalysis(){
  if(!lastCanvas || !lastBox){ setToast("Detect first"); return; }
  // image stats
  const ctx = lastCanvas.getContext("2d");
  const {x,y,width,height} = lastBox;
  const imgW = lastCanvas.width, imgH = lastCanvas.height;
  const data = ctx.getImageData(0,0,imgW,imgH).data;
  let mean=0, n=imgW*imgH, lums=new Float32Array(n);
  for(let i=0, j=0;i<data.length;i+=4, j++){
    const r=data[i], g=data[i+1], b=data[i+2];
    const lum = 0.299*r + 0.587*g + 0.114*b;
    lums[j]=lum; mean+=lum;
  }
  mean/=n;
  let varsum=0;
  for(let j=0;j<n;j++){ const d=lums[j]-mean; varsum+=d*d; }
  const stdev = Math.sqrt(varsum/n);

  // sharpness via Laplacian variance on the FACE crop
  const fc = document.createElement("canvas");
  fc.width = Math.max(1, Math.round(width));
  fc.height = Math.max(1, Math.round(height));
  fc.getContext("2d").drawImage(lastCanvas, x,y,width,height, 0,0, fc.width, fc.height);
  const fd = fc.getContext("2d").getImageData(0,0,fc.width,fc.height).data;
  // grayscale
  const gray = new Float32Array(fc.width*fc.height);
  for(let i=0,j=0;i<fd.length;i+=4,j++){
    gray[j] = 0.299*fd[i] + 0.587*fd[i+1] + 0.114*fd[i+2];
  }
  // simple Laplacian 3x3
  const W=fc.width,H=fc.height;
  let lapVarSum=0, lapMean=0, cnt=0;
  const idx=(xx,yy)=>yy*W+xx;
  for(let yy=1; yy<H-1; yy++){
    for(let xx=1; xx<W-1; xx++){
      const c = 4*gray[idx(xx,yy)]
        - gray[idx(xx-1,yy)] - gray[idx(xx+1,yy)]
        - gray[idx(xx,yy-1)] - gray[idx(xx,yy+1)];
      lapMean += c; lapVarSum += c*c; cnt++;
    }
  }
  lapMean/=Math.max(1,cnt);
  const lapVar = lapVarSum/Math.max(1,cnt) - lapMean*lapMean;

  // optional IoU if refine exists
  let iouVal = null;
  if (lastRefineBox){
    iouVal = +iou(lastBox, lastRefineBox).toFixed(3);
  }

  const analysis = {
    revision: REVISION,
    timestamp: new Date().toISOString(),
    image: { width: lastCanvas.width, height: lastCanvas.height },
    box: {
      x:+lastBox.x.toFixed(2),
      y:+lastBox.y.toFixed(2),
      width:+lastBox.width.toFixed(2),
      height:+lastBox.height.toFixed(2),
      area_pct:+((lastBox.width*lastBox.height)/(lastCanvas.width*lastCanvas.height)*100).toFixed(4),
      aspect:+(lastBox.width/lastBox.height).toFixed(4),
      center:{ x:+(lastBox.x+lastBox.width/2).toFixed(2), y:+(lastBox.y+lastBox.height/2).toFixed(2) },
      center_offset_pct:{
        x:+(((lastBox.x+lastBox.width/2) - lastCanvas.width/2)/lastCanvas.width*100).toFixed(2),
        y:+(((lastBox.y+lastBox.height/2) - lastCanvas.height/2)/lastCanvas.height*100).toFixed(2)
      }
    },
    lighting:{ brightness_mean:+mean.toFixed(3), contrast_stdev:+stdev.toFixed(3) },
    sharpness:{ laplacian_variance:+lapVar.toFixed(3) },
    orientation: lastCanvas.width>=lastCanvas.height ? "landscape" : "portrait",
    refine: { landmarks: 0, iou: iouVal }
  };
  lastAnalysis = analysis;
  localStorage.setItem("yorn_last_analysis", JSON.stringify(analysis));
  $("analysisCard").style.display="";
  $("copyJsonBtn").disabled=false; $("exportJsonBtn").disabled=false;

  // brief textual summary
  const hints=[];
  hints.push(`Face area ${(analysis.box.area_pct).toFixed(2)}%`);
  const br = analysis.lighting.brightness_mean;
  hints.push(`Brightness ${br<90?'low':br>170?'high':'ok'}`);
  const cv = analysis.lighting.contrast_stdev;
  hints.push(`Contrast ${cv<40?'soft':cv>95?'harsh':'ok'}`);
  hints.push(`Sharpness ${analysis.sharpness.laplacian_variance>1200?'crisp':analysis.sharpness.laplacian_variance<400?'soft':'ok'}`);
  if (iouVal!=null) hints.push(`IoU (refine·blaze) ${iouVal}`);

  $("analysisSummary").textContent = hints.join(' • ');
  logEvt("analysis",{analysis});
}

/* ========= copy helpers ========= */
async function copyTextRobust(text){
  if (text==null) text="";
  try{
    if (navigator.clipboard && window.isSecureContext){
      await navigator.clipboard.writeText(text);
      return {ok:true, via:"clipboard"};
    }
  }catch(_){}
  try{
    const ta=document.createElement("textarea");
    ta.value=text; ta.setAttribute("readonly","");
    ta.style.position="fixed"; ta.style.left="-9999px"; ta.style.opacity="0";
    document.body.appendChild(ta); ta.select();
    const ok=document.execCommand("copy");
    document.body.removeChild(ta);
    if (ok) return {ok:true, via:"execCommand"};
  }catch(e){ return {ok:false, via:"fallback", err:e.message||String(e)} }
  return {ok:false, via:"none", err:"No clipboard available"};
}
function getAllLogsText(){ return diagEl ? (diagEl.textContent||diagEl.innerText||"") : ""; }

/* ========= Auto Test & ribbon ========= */
let __autoTestStartIdx = 0;
function buildAutoTestReport(){
  const full = getAllLogsText();
  const chunk = full.slice(__autoTestStartIdx);
  const backend = (full.match(/"backend":"([^"]+)"/)||[])[1] || "—";
  const refineYes = /"iou":/.test(chunk) || /"refine_ms":/.test(chunk);
  const errs = (chunk.match(/"type":"error"/g)||[]).length;
  const passes = (chunk.match(/"step":"[^"]+","ok":true/g)||[]).length;
  const roughMs = (chunk.match(/"roughLocate_ms":(\d+)/)||[])[1] || "—";
  const finalMs = (chunk.match(/"finalDetect_ms":(\d+)/)||[])[1] || "—";
  const head = `YorN ${REVISION} • TF backend: ${backend} • refine: ${refineYes?'yes':'no'} • passes: ${passes} • errors: ${errs} • rough: ${roughMs} ms • final: ${finalMs} ms`;
  const lines = chunk.split('\n').filter(l => /"type":"(test|detect|analysis|config|error)"/.test(l));
  return ['=== YorN Auto‑Test Report ===', head, '', ...lines, '=== End Report ===',''].join('\n');
}
function setAutoBadge(ok, why){
  const b = $("autoBadge");
  b.className = `badge ${ok?'ok':'bad'}`;
  b.textContent = `AUTO TEST • ${ok?'✅ PASSED':'❌ FAILED'}`;
  if (why) b.title = why;
}

async function runAutoTest(){
  $("autoTestBtn").disabled = true;
  $("copyTestBtn").disabled = true;
  const before = getAllLogsText();
  __autoTestStartIdx = before.length;
  setAutoBadge(false, "Running…");
  logEvt("test",{step:"begin", rev:REVISION});
  try{
    const tfPresent = !!window.tf;
    logEvt("test",{step:"tf_present", ok:tfPresent});
    if(!tfPresent){ throw new Error("tf missing"); }

    await $("sampleBtn").click();
    await new Promise(r=>setTimeout(r,300));
    logEvt("test",{step:"sample", ok:!!baseSource});

    const t0 = performance.now();
    await detectFlow();
    const ms = Math.round(performance.now()-t0);
    logEvt("test",{step:"detect_blazeonly", ok:!!lastBox, ms});

    logEvt("test",{step:"refine_guard", ok:true});
    $("startAnalysisBtn").click();
    await new Promise(r=>setTimeout(r,250));
    logEvt("test",{step:"analysis_blazeonly", ok:!!lastAnalysis});

    const ok = !!(baseSource && lastBox && lastAnalysis);
    logEvt("test",{step:"summary", ok});
    setAutoBadge(ok, ok ? "All good" : "Missing pieces");
    $("copyTestBtn").disabled = false;
  }catch(e){
    logEvt("error",{autoTest:e.message||String(e)});
    setAutoBadge(false, e.message||"Auto Test failed");
  }
  $("autoTestBtn").disabled = false;
}

/* ========= UI binds ========= */
$("zoom").addEventListener("input", e => $("zoomLabel").textContent=(+e.target.value).toFixed(2));
$("bri").addEventListener("input", e => $("briLabel").textContent=(+e.target.value).toFixed(2));
$("con").addEventListener("input", e => $("conLabel").textContent=(+e.target.value).toFixed(2));

$("enhanceBtn").addEventListener("click", ()=>{
  const z=$("zoom"); z.value=Math.max(+z.value,1.5); $("zoomLabel").textContent=(+z.value).toFixed(2);
  const b=$("bri"); b.value=Math.max(+b.value,1.18); $("briLabel").textContent=(+b.value).toFixed(2);
  const c=$("con"); c.value=Math.max(+c.value,1.25); $("conLabel").textContent=(+c.value).toFixed(2);
  detectFlow();
});
$("detectBtn").addEventListener("click", detectFlow);
$("startAnalysisBtn").addEventListener("click", ()=>{
  logEvt("analysis",{analysisRequested:true, mode:"light"});
  runLightAnalysis();
});
$("clearLogsBtn").addEventListener("click", ()=>{ diagEl.textContent="No diagnostics yet."; });
$("resetBtn").addEventListener("click", ()=>{
  ["base","overlay"].forEach(id=>{ const el=$(id); if(el){ el.getContext("2d").clearRect(0,0,el.width,el.height); }});
  baseSource=null; lastCanvas=null; lastBox=null; lastRefineBox=null; lastAnalysis=null;
  $("analysisCard").style.display="none";
  $("copyJsonBtn").disabled=true; $("exportJsonBtn").disabled=true;
  $("detectBtn").disabled=true; $("enhanceBtn").disabled=true; $("startAnalysisBtn").disabled=true;
  setToast("Reset");
  logEvt("config",{reset:true});
});
$("fileInput").addEventListener("change", async ()=>{
  if(!$("fileInput").files.length) return;
  const f=$("fileInput").files[0];
  setProgress(10,"Decoding photo…");
  try{
    baseSource = await decodeOriginal(f);
    const c = renderWorkingCanvas(1024);
    paintBaseCanvas(c);
    $("detectBtn").disabled=false; $("enhanceBtn").disabled=false;
    setProgress(12,"Photo ready");
  }catch(e){ logEvt("error",{decode_failed:e.message||String(e)}) }
});
$("sampleBtn").addEventListener("click", async ()=>{
  try{
    setProgress(5,"Fetching sample…");
    const u="https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1000&auto=format&fit=crop";
    const res=await fetch(u,{cache:"no-store"});
    if(!res.ok) throw new Error("HTTP "+res.status);
    const blob=await res.blob();
    baseSource = await decodeOriginal(blob);
    const c = renderWorkingCanvas(1024);
    paintBaseCanvas(c);
    $("detectBtn").disabled=false; $("enhanceBtn").disabled=false;
    logEvt("detect",{sampleImage:u});
  }catch(e){ logEvt("error",{sample_failed:e.message||String(e)}) }
});

/* unified single “Copy Diagnostics” */
$("copyDiagBtn").addEventListener("click", async ()=>{
  const report = buildAutoTestReport();
  const res = await copyTextRobust(report);
  if(res.ok){ setToast("Diagnostics copied"); logEvt("config",{copiedDiagnostics:true, via:res.via}); }
  else { setToast("Copy failed"); logEvt("error",{copyDiagnostics:res.err||"unknown"}) }
});
$("copyTestBtn").addEventListener("click", async ()=>{
  const report = buildAutoTestReport();
  const res = await copyTextRobust(report);
  if(res.ok){ setToast("Auto Test copied"); logEvt("config",{copiedAutoTest:true, via:res.via}); }
  else { setToast("Copy failed"); logEvt("error",{copyAutoTest:res.err||"unknown"}) }
});
$("autoTestBtn").addEventListener("click", runAutoTest);

/* ========= boot ========= */
window.addEventListener("load", ()=>{
  $("rev").textContent = REVISION;
  $("backend").textContent = "…";
  envProbe();
  try{
    const saved = localStorage.getItem("yorn_last_analysis");
    if(saved){
      const a = JSON.parse(saved);
      logEvt("analysis",{restored:true, analysis:a});
      $("analysisCard").style.display="";
      $("copyJsonBtn").disabled=false; $("exportJsonBtn").disabled=false;
    }
  }catch(_){}
  logEvt("config",{boot:"dom-ready", rev:REVISION});
  // tf backend ready event is logged in ensureBlaze(); run a gentle init
  (async () => {
    try{
      await ensureBlaze();
      logEvt("config",{boot:"frameworks-ready"});
    }catch(e){
      logEvt("error",{boot_frameworks:e.message||String(e)});
    }
  })();
  logEvt("config",{boot:"complete"});
});
/* export JSON & copy JSON */
$("copyJsonBtn").addEventListener("click", async ()=>{
  if(!lastAnalysis) return;
  const res = await copyTextRobust(JSON.stringify(lastAnalysis,null,2));
  if(res.ok) setToast("Analysis JSON copied");
});
$("exportJsonBtn").addEventListener("click", ()=>{
  if(!lastAnalysis) return;
  const blob=new Blob([JSON.stringify(lastAnalysis,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download=`yorn-analysis-${Date.now()}.json`;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});
</script>
</body>
</html>