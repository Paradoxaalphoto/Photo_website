<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>YorN Alpha — Visual Rough Box + Final Detect</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;margin:0;padding:16px;background:#0b1220;color:#E6EAF2}
  .row{display:grid;grid-template-columns:1fr auto auto auto auto;gap:8px;align-items:end}
  .card{background:#0f172a;border:1px solid #233046;border-radius:12px;padding:12px;margin-top:12px}
  #progressContainer{height:8px;background:#1e293b;border-radius:6px;overflow:hidden;margin-top:8px}
  #progressBar{height:100%;width:0;background:#38bdf8;transition:width .25s}
  #overlay{display:block;max-width:100%;margin-top:10px;background:#0b1220;border:1px solid #233046;border-radius:8px}
  #thumb{max-width:100%;margin-top:10px;background:#0b1220;border:1px solid #233046;border-radius:8px}
  #diagnostics{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;background:#0b1220;border:1px solid #233046;border-radius:8px;padding:8px;max-height:300px;overflow:auto}
  button{cursor:pointer}
  .btn{padding:10px 14px;border-radius:8px;border:1px solid #233046;background:#1f2937;color:#E6EAF2}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .btn-secondary{background:#0b1220}
  .controls{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
  label{font-size:12px;color:#A9B4C8}
  input[type="range"], input[type="number"]{width:100%}
  input[type="number"], input[type="range"]{padding:6px;border:1px solid #233046;border-radius:8px;background:#0b1220;color:#E6EAF2}
</style>

<!-- Load TFJS first -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<!-- BlazeFace (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
<!-- face-api.js (fallback if needed later) -->
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
</head>
<body>

<h2>YorN Alpha — Face Analysis</h2>

<div class="card">
  <div class="row">
    <input id="fileInput" type="file" accept="image/*" />
    <button id="sampleBtn" class="btn btn-secondary">Load Sample Image</button>
    <button id="enhanceBtn" class="btn btn-secondary" disabled>Auto‑Enhance & Retry</button>
    <button id="analyzeBtn" class="btn" disabled>Analyze</button>
    <button id="savePngBtn" class="btn btn-secondary" disabled>Save Debug Snapshot</button>
  </div>

  <div class="controls" style="margin-top:8px">
    <div>
      <label>Rotate (°)</label>
      <input id="rotDeg" type="number" step="90" value="0" />
    </div>
    <div>
      <label>Zoom (0.8–2.0): <span id="zoomLabel">1.2</span></label>
      <input id="zoom" type="range" min="0.8" max="2.0" step="0.05" value="1.2" />
    </div>
    <div>
      <label>Brightness: <span id="briLabel">1.10</span></label>
      <input id="bri" type="range" min="0.8" max="1.4" step="0.02" value="1.10" />
    </div>
    <div>
      <label>Contrast: <span id="conLabel">1.15</span></label>
      <input id="con" type="range" min="0.8" max="1.6" step="0.02" value="1.15" />
    </div>
  </div>

  <div id="progressContainer"><div id="progressBar"></div></div>
  <p id="progressText" style="font-size:12px;color:#A9B4C8;margin:6px 2px 0 2px;"></p>
</div>

<div class="card">
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
    <div>
      <strong style="font-size:13px">Preview</strong>
      <img id="thumb" class="hidden" alt="Preview" />
      <canvas id="overlay" class="hidden"></canvas>
    </div>
    <div>
      <strong style="font-size:13px">Diagnostics</strong>
      <div id="diagnostics">No diagnostics yet.</div>
    </div>
  </div>
</div>

<script>
/* ---------- Helpers ---------- */
const $ = id => document.getElementById(id);
const fileInput = $("fileInput"), sampleBtn = $("sampleBtn"), analyzeBtn = $("analyzeBtn"), enhanceBtn = $("enhanceBtn"), savePngBtn = $("savePngBtn");
const overlay = $("overlay"), thumb = $("thumb");
const progressBar = $("progressBar"), progressText = $("progressText");
const diagnostics = $("diagnostics");
const rotDeg = $("rotDeg"), zoom = $("zoom"), zoomLabel = $("zoomLabel"), bri = $("bri"), briLabel = $("briLabel"), con = $("con"), conLabel = $("conLabel");

let baseBitmap = null, workCanvas = null, blazeModel = null, faceApiReady = false;

function setProgress(p,t){ progressBar.style.width=(p||0)+'%'; progressText.textContent=t||''; }
function logDiag(obj){ const now=new Date().toISOString(); const txt=typeof obj==='string'?obj:JSON.stringify(obj); diagnostics.textContent=`[${now}] ${txt}\n`+diagnostics.textContent; }
function setError(msg){ setProgress(0,""); logDiag({ error: msg }); }
function ensureWorkCanvas(){ if(!workCanvas){ workCanvas = document.createElement("canvas"); } return workCanvas; }
function drawLabelBox(canvas, box, color, label){
  const ctx = overlay.getContext("2d");
  overlay.width = canvas.width; overlay.height = canvas.height;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  ctx.drawImage(canvas, 0, 0, overlay.width, overlay.height);
  ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.strokeRect(box.x, box.y, box.width, box.height);
  ctx.fillStyle = color; ctx.font = "12px ui-monospace,monospace";
  ctx.fillText(label, box.x, Math.max(12, box.y-4));
  overlay.classList.remove("hidden");
}

/* ---------- Decode ---------- */
async function decodeOriginal(fileOrBlob){
  const bmp = await createImageBitmap(fileOrBlob).catch(async ()=>{
    const url = URL.createObjectURL(fileOrBlob);
    const img = new Image(); await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=url; });
    const c = document.createElement("canvas"); c.width=img.naturalWidth; c.height=img.naturalHeight; c.getContext("2d").drawImage(img,0,0);
    URL.revokeObjectURL(url); return createImageBitmap(c);
  });
  return bmp;
}

/* ---------- Render with controls ---------- */
function renderWorkingCanvas(targetMax=1024, centerBox=null){
  if(!baseBitmap) return null;
  const angle=(parseInt(rotDeg.value,10)||0)%360;
  let z=parseFloat(zoom.value)||1.0;
  const br=parseFloat(bri.value)||1.0, cr=parseFloat(con.value)||1.0;

  const maxSide=Math.max(baseBitmap.width, baseBitmap.height);
  const scale0=Math.min(1, targetMax/maxSide);
  const w0=Math.max(1, Math.round(baseBitmap.width*scale0));
  const h0=Math.max(1, Math.round(baseBitmap.height*scale0));

  let cx=baseBitmap.width/2, cy=baseBitmap.height/2;
  if(centerBox){
    cx=centerBox.x+centerBox.width/2; cy=centerBox.y+centerBox.height/2;
    const zx=(w0/(centerBox.width*scale0))*0.9, zy=(h0/(centerBox.height*scale0))*0.9;
    z=Math.max(z, Math.min(zx, zy, 1.8));
    logDiag({ autoZoomApplied: z.toFixed(2) });
  }

  const dstW=w0, dstH=h0;
  const srcW=Math.round(dstW/(scale0*z));
  const srcH=Math.round(dstH/(scale0*z));
  const sx=Math.max(0, Math.round(cx-srcW/2));
  const sy=Math.max(0, Math.round(cy-srcH/2));

  const c=ensureWorkCanvas();
  if((angle%180)===0){ c.width=dstW; c.height=dstH; } else { c.width=dstH; c.height=dstW; }

  const ctx=c.getContext("2d");
  ctx.save();
  ctx.clearRect(0,0,c.width,c.height);
  ctx.translate(c.width/2, c.height/2);
  ctx.rotate(angle*Math.PI/180);
  ctx.filter=`brightness(${br}) contrast(${cr})`;
  ctx.drawImage(baseBitmap, sx, sy, srcW, srcH, -dstW/2, -dstH/2, dstW, dstH);
  ctx.restore();

  return c;
}

/* ---------- BlazeFace primary ---------- */
async function ensureBlaze(){
  if(blazeModel) return;
  if(!window.blazeface) throw new Error("BlazeFace script not loaded");
  blazeModel = await window.blazeface.load();
  logDiag({ blazefaceReady:true });
}
async function roughLocate(canvas){
  const tinyW=160, tinyH=Math.round(tinyW*(canvas.height/canvas.width));
  const tmp=Object.assign(document.createElement("canvas"),{width:tinyW,height:tinyH});
  tmp.getContext("2d").drawImage(canvas,0,0,tinyW,tinyH);
  const t0=performance.now();
  const faces=await blazeModel.estimateFaces(tmp,false);
  const ms=Math.round(performance.now()-t0);
  if(faces && faces.length){
    const f=faces[0];
    const tl=Array.isArray(f.topLeft)?f.topLeft:await f.topLeft.array();
    const br=Array.isArray(f.bottomRight)?f.bottomRight:await f.bottomRight.array();
    const sx=canvas.width/tinyW, sy=canvas.height/tinyH;
    const box={x:tl[0]*sx, y:tl[1]*sy, width:(br[0]-tl[0])*sx, height:(br[1]-tl[1])*sy};
    logDiag({ roughLocate_ms:ms, box });
    return box;
  }
  logDiag({ roughLocate_ms:ms, box:null });
  return null;
}
async function detectBlaze(canvas){
  const t0=performance.now();
  const faces=await blazeModel.estimateFaces(canvas,false);
  const ms=Math.round(performance.now()-t0);
  if(faces && faces.length){
    const f=faces[0];
    const tl=Array.isArray(f.topLeft)?f.topLeft:await f.topLeft.array();
    const br=Array.isArray(f.bottomRight)?f.bottomRight:await f.bottomRight.array();
    const box={x:tl[0], y:tl[1], width:(br[0]-tl[0]), height:(br[1]-tl[1])};
    logDiag({ finalDetect_ms:ms, box });
    return { elapsed_ms:ms, box };
  }
  logDiag({ finalDetect:"no face" });
  return null;
}

/* ---------- face-api fallback (kept, but probably not needed now) ---------- */
let FA_WEIGHTS=null;
async function pickWeights(){
  if(FA_WEIGHTS) return FA_WEIGHTS;
  const bases=[
    "https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights",
    "https://unpkg.com/face-api.js@0.22.2/weights",
    "https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights",
    "https://rawcdn.githack.com/justadudewhohacks/face-api.js/0.22.2/weights",
    "https://cdn.jsdelivr.net/gh/vladmandic/face-api/model"
  ];
  for(const b of bases){ try{ FA_WEIGHTS=b.replace(/\/$/,""); logDiag({ usingWeightsFrom:FA_WEIGHTS }); return FA_WEIGHTS; }catch(_){ } }
  throw new Error("No weights base found");
}
async function ensureFaceApi(){
  if(faceApiReady) return;
  const base=await pickWeights();
  await faceapi.nets.tinyFaceDetector.loadFromUri(base);
  await faceapi.nets.faceLandmark68Net.loadFromUri(base);
  faceApiReady=true; logDiag({ faceapiReady:true });
}

/* ---------- Flow ---------- */
async function analyzeFlow(auto=false){
  try{
    if(!baseBitmap){ setError("No image decoded."); return; }
    setProgress(10, auto ? "Auto-analyzing…" : "Analyzing…");
    await ensureBlaze();

    // Render with current settings
    let canvas = renderWorkingCanvas(1024);

    // 1) Rough box → draw immediately (cyan)
    const rough = await roughLocate(canvas);
    if(rough){
      drawLabelBox(canvas, rough, "#06b6d4", "rough"); // cyan rough box
      // Re-render with auto-zoom centered on rough box
      canvas = renderWorkingCanvas(1024, rough);
    }

    // 2) Final BlazeFace detect → draw green
    const det = await detectBlaze(canvas);
    if(det){
      drawLabelBox(canvas, det.box, "#22c55e", `BlazeFace • ${det.elapsed_ms}ms`);
      setProgress(100, "Done (BlazeFace).");
      return;
    }

    // 3) Optional fallback (face-api tiny)
    await ensureFaceApi();
    const sizes=[256,192,160,128];
    for(const s of sizes){
      try{
        const opts=new faceapi.TinyFaceDetectorOptions({ inputSize:s, scoreThreshold:0.2 });
        const r=await faceapi.detectSingleFace(canvas, opts).withFaceLandmarks();
        if(r){
          const rr=faceapi.resizeResults(r,{width:canvas.width,height:canvas.height});
          drawLabelBox(canvas, rr.detection.box, "#f59e0b", `face-api • ${s}`);
          setProgress(100, "Done (face-api).");
          return;
        }
      }catch(e){ logDiag({ faceapi_attemptFail:{ size:s, msg:e && e.message } }); }
    }

    setError("No face detected. Try rotate or increase Zoom, then Analyze.");
  }catch(e){ setError(e.message || String(e)); }
}

/* ---------- Events ---------- */
zoom.addEventListener("input", ()=>{ zoomLabel.textContent=(+zoom.value).toFixed(2); if(baseBitmap){ renderWorkingCanvas(); }});
bri.addEventListener("input", ()=>{ briLabel.textContent=(+bri.value).toFixed(2); if(baseBitmap){ renderWorkingCanvas(); }});
con.addEventListener("input", ()=>{ conLabel.textContent=(+con.value).toFixed(2); if(baseBitmap){ renderWorkingCanvas(); }});
rotDeg.addEventListener("change", ()=>{ if(baseBitmap){ renderWorkingCanvas(); }});

fileInput.addEventListener("change", async ()=>{
  overlay.classList.add("hidden"); progressText.textContent="";
  if(!fileInput.files.length){ analyzeBtn.disabled=true; enhanceBtn.disabled=true; savePngBtn.disabled=true; return; }
  const f = fileInput.files[0];
  thumb.src = URL.createObjectURL(f); thumb.classList.remove("hidden");
  setProgress(8,"Decoding…");
  baseBitmap = await decodeOriginal(f);
  setProgress(12,"Ready. Adjust if needed, then Analyze.");
  renderWorkingCanvas(1024);
  analyzeBtn.disabled = false; enhanceBtn.disabled = false; savePngBtn.disabled = false;
  logDiag({ fileName:f.name, type:f.type, size_bytes:f.size, w:baseBitmap.width, h:baseBitmap.height });
});

sampleBtn.addEventListener("click", async ()=>{
  overlay.classList.add("hidden"); progressText.textContent="";
  const sampleURL="https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1000&auto=format&fit=crop";
  logDiag({ sampleImage: sampleURL });
  const res=await fetch(sampleURL,{cache:"no-store"}); const blob=await res.blob();
  thumb.src=URL.createObjectURL(blob); thumb.classList.remove("hidden");
  setProgress(8,"Decoding sample…");
  baseBitmap=await decodeOriginal(blob);
  setProgress(12,"Sample ready. Running analyze…");
  renderWorkingCanvas(1024);
  analyzeBtn.disabled=false; enhanceBtn.disabled=false; savePngBtn.disabled=false;
  analyzeFlow(true);
});

enhanceBtn.addEventListener("click", ()=>{
  zoom.value=Math.max(+zoom.value,1.5); zoomLabel.textContent=(+zoom.value).toFixed(2);
  bri.value=Math.max(+bri.value,1.18); briLabel.textContent=(+bri.value).toFixed(2);
  con.value=Math.max(+con.value,1.25); conLabel.textContent=(+con.value).toFixed(2);
  analyzeFlow(true);
});

analyzeBtn.addEventListener("click", ()=> analyzeFlow(false));

savePngBtn.addEventListener("click", ()=>{
  try{
    const url = overlay.toDataURL("image/png");
    const a = Object.assign(document.createElement("a"), { href:url, download:"yorn-debug.png" });
    document.body.appendChild(a); a.click(); a.remove();
  }catch(e){ logDiag({ savePngError: e && e.message }); }
});
</script>
</body>
</html>