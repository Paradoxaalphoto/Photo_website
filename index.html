<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"
/>
<title>YorN 1.17.5-alpha</title>
<style>
  :root {
    --bg:#0b0f14; --card:#121821; --muted:#778196; --ink:#e7ecf3; --accent:#62d0ff;
    --ok:#2ecc71; --warn:#f39c12; --bad:#ff5c5c;
  }
  html,body {margin:0;padding:0;background:var(--bg);color:var(--ink);font:400 15px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap {max-width:960px;margin:0 auto;padding:14px;}
  h1 {font-size:18px;margin:0 0 10px 0;letter-spacing:.2px}
  .row {display:flex;gap:10px;flex-wrap:wrap}
  .card {background:var(--card);border-radius:12px;padding:12px;flex:1 1 300px;min-width:280px}
  .controls {display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .controls button, .controls input[type="file"]::file-selector-button {
    background:#1a2330;color:var(--ink);border:1px solid #273348;border-radius:10px;padding:8px 12px;cursor:pointer
  }
  .controls button[disabled] {opacity:.45;cursor:not-allowed}
  .badge {display:none; padding:3px 8px;border-radius:999px;font-size:12px;border:1px solid #2c394a;color:#cfd7e6}
  .badge.ready {background:rgba(46,204,113,.12); border-color:#2ecc71; color:#aef3c7}
  .badge.blocked {background:rgba(255,92,92,.12); border-color:#ff5c5c; color:#ffb3b3}
  canvas, .stage {width:100%;max-height:55vh;background:#0f141c;border-radius:10px;display:block}
  .hud {display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:8px}
  .tiny {font-size:12px;color:var(--muted)}
  .kv {display:grid;grid-template-columns:auto 1fr;gap:6px 10px;font-size:13px}
  .log {white-space:pre-wrap;word-break:break-word;max-height:240px;overflow:auto;background:#0e141c;padding:10px;border-radius:10px;border:1px solid #233042}
  .progress {min-height:18px;color:#bcd0e8}
  .veil {position:fixed;inset:0;background:rgba(11,15,20,.6);display:none;align-items:center;justify-content:center;z-index:9999}
  .veil.show {display:flex}
  .chip {padding:4px 8px;border:1px solid #2c394a;border-radius:999px;font-size:12px}
  .num {font-variant-numeric:tabular-nums}
  .inputs {display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .inputs label {display:flex;align-items:center;gap:6px;font-size:13px;color:#c7d2e2;background:#0f141c;border:1px solid #233042;padding:6px 8px;border-radius:8px}
  .inputs input[type="range"], .inputs input[type="number"] {accent-color:var(--accent)}
  @media (max-width:480px){
    .row {flex-direction:column}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <div class="card" style="flex:2 1 420px">
      <div class="hud">
        <h1>YorN <span id="rev">1.17.5-alpha</span></h1>
        <span id="readinessBadge" class="badge">READY</span>
      </div>

      <div class="controls" style="margin:8px 0 10px">
        <input id="fileInput" type="file" accept="image/*" />
        <button id="sampleBtn" type="button">Load Sample</button>
        <button id="detectBtn" type="button" disabled>Detect</button>
        <button id="startAnalysisBtn" type="button" disabled>Start Analysis</button>
        <button id="autoTestBtn" type="button">Auto‑Test</button>
        <button id="copyTestBtn" type="button" disabled>Copy Test Report</button>
      </div>

      <canvas id="stage" class="stage" width="1024" height="683"></canvas>

      <div class="inputs">
        <label>Rotate (°)
          <input id="rot" type="number" step="1" value="0" style="width:64px">
        </label>
        <label>Zoom (0.8–2.0):
          <input id="zoom" type="range" min="0.8" max="2.0" step="0.01" value="1.20">
          <span id="zoomLabel" class="num">1.20</span>
        </label>
        <label>Brightness:
          <input id="bri" type="range" min="0.8" max="1.6" step="0.01" value="1.10">
          <span id="briLabel" class="num">1.10</span>
        </label>
        <label>Contrast:
          <input id="con" type="range" min="0.8" max="1.6" step="0.01" value="1.15">
          <span id="conLabel" class="num">1.15</span>
        </label>
        <button id="enhanceBtn" type="button" disabled>Enhance & Retry</button>
        <button id="resetBtn" type="button">Reset</button>
      </div>

      <div class="hud" style="margin-top:10px">
        <div class="tiny">
          <span class="chip">TF: <span id="tfChip">—</span></span>
          <span class="chip">v<span id="tfVer">—</span></span>
          <span class="chip">Session: <span id="sessStats" class="num">0 detects • 0 analyses</span></span>
        </div>
        <div class="progress" id="progressText"></div>
      </div>
    </div>

    <div class="card" style="flex:1 1 300px">
      <div class="hud">
        <strong>Diagnostics</strong>
        <div>
          <button id="copyDiagBtn" type="button">Copy Diagnostics</button>
          <button id="clearLogsBtn" type="button">Clear</button>
        </div>
      </div>
      <div id="diagnostics" class="log">No diagnostics yet.</div>
    </div>
  </div>

  <div id="analysisCard" class="card" style="margin-top:10px; display:none">
    <div class="hud"><strong>Analysis</strong>
      <div>
        <button id="copySummaryBtn" type="button">Copy Summary</button>
        <button id="copyJsonBtn" type="button">Copy JSON</button>
        <button id="exportJsonBtn" type="button">Download JSON</button>
      </div>
    </div>
    <div class="kv" id="analysisKv"></div>
  </div>
</div>

<div id="veil" class="veil"><div style="background:#0f141c;border:1px solid #223042;padding:14px 16px;border-radius:10px">
  Working… (watchdog armed)
</div></div>

<!-- Frameworks -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>

<script>
(() => {
  "use strict";

  /* ===== Globals ===== */
  const REVISION = "1.17.5-alpha";
  const $ = id => document.getElementById(id);
  const stage = $("stage");
  const ctx = stage.getContext("2d", {willReadFrequently:true});
  let baseBitmap = null;
  let faceModel = null;
  let lastBox = null;
  let lastAnalysis = null;
  let isBusy = false;
  let tfVersion = "—";
  let __autoTestStartIdx = 0;

  const session = {
    detects: 0,
    detectTimes: [],
    analyses: 0
  };

  /* ===== Utils ===== */
  function setBusy(v) {
    isBusy = !!v;
    $("veil").classList.toggle("show", isBusy);
    // Disable action buttons while busy
    ["detectBtn","startAnalysisBtn","autoTestBtn","enhanceBtn"].forEach(id=>{
      const b=$(id); if (b) b.disabled = !!v;
    });
  }

  function logEvt(type, obj = {}) {
    const line = JSON.stringify({ time: new Date().toISOString(), type, ...obj });
    const box = $("diagnostics");
    if (box.textContent === "No diagnostics yet.") box.textContent = "";
    box.textContent += (box.textContent ? "\n" : "") + line;
    box.scrollTop = box.scrollHeight;
  }

  function getAllLogsText() {
    const el = $("diagnostics");
    return el ? (el.innerText || el.textContent || "") : "";
  }

  function setProgress(pctText, msg) {
    $("progressText").textContent = msg || "";
  }

  async function copyTextRobust(text) {
    if (text == null) text = "";
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return { ok:true, via:"clipboard" };
      }
    } catch (_) {}
    try {
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly","");
      ta.style.position="fixed"; ta.style.opacity="0"; ta.style.left="-9999px";
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      if (ok) return { ok:true, via:"execCommand" };
    } catch (e) {
      return { ok:false, via:"fallback", err:e.message || String(e) };
    }
    return { ok:false, via:"none", err:"No clipboard available" };
  }

  function safeBackend() {
    try { return (window.tf && typeof tf.getBackend === "function") ? (tf.getBackend() || "—") : "—"; }
    catch { return "—"; }
  }

  function updateTfBadges() {
    $("tfChip").textContent = safeBackend();
    $("tfVer").textContent = String(tfVersion || "—");
  }

  function updateSessionStats() {
    const avg = session.detectTimes.length ? Math.round(session.detectTimes.reduce((a,b)=>a+b,0)/session.detectTimes.length) : "—";
    $("sessStats").textContent = `${session.detects} detects • ${session.analyses} analyses`;
    logEvt("config",{ session:`${session.detects} detects • ${session.analyses} analyses`, avg_detect_ms: avg });
  }

  function drawOverlay(box) {
    // repaint base first
    paintBase();
    // draw face box
    ctx.save();
    ctx.strokeStyle = "#62d0ff";
    ctx.lineWidth = 3;
    ctx.strokeRect(box.x, box.y, box.width, box.height);
    ctx.restore();
  }

  /* ===== Image decode & paint ===== */
  async function decodeBitmapFromBlob(blob) {
    const bmp = await createImageBitmap(blob);
    return bmp;
  }

  function paintBase() {
    if (!baseBitmap) return;
    const rot = parseFloat($("rot").value || "0") * Math.PI/180;
    const zoom = parseFloat($("zoom").value || "1");
    const bri = parseFloat($("bri").value || "1");
    const con = parseFloat($("con").value || "1");

    // draw into stage
    ctx.save();
    ctx.clearRect(0,0,stage.width,stage.height);
    ctx.filter = `brightness(${bri}) contrast(${con})`;
    ctx.translate(stage.width/2, stage.height/2);
    ctx.rotate(rot);
    const dw = stage.width * zoom, dh = stage.height * zoom;
    ctx.drawImage(baseBitmap, -dw/2, -dh/2, dw, dh);
    ctx.restore();
    logEvt("overlay",{ painted:{ w: stage.width, h: stage.height }});
  }

  /* ===== TF / Model ===== */
  async function initTF() {
    if (!window.tf) {
      logEvt("error",{ tf_init:"tf not present" });
      throw new Error("tf missing");
    }
    // backend is selected lazily by tfjs; do nothing if already ready
    await tf.ready();
    tfVersion = tf?.version_core || tf?.version?.tfjs || tfVersion || "—";
    updateTfBadges();
    // optional warmup
    try {
      const t0 = performance.now();
      await tf.setBackend(safeBackend() || "webgl");
      await tf.ready();
      logEvt("config",{ warmup:"ok", backend:safeBackend(), ms: Math.round(performance.now()-t0) });
    } catch (e) {
      logEvt("error",{ warmup:e.message || String(e) });
    }
    updateTfBadges();
  }

  async function loadModel() {
    if (faceModel) return;
    try {
      faceModel = await blazeface.load();
      logEvt("detect",{ blazefaceReady:true });
    } catch (e) {
      logEvt("error",{ blazeface_failed:e.message || String(e) });
      throw e;
    }
  }

  /* ===== Detection with watchdog & fallback ===== */
  async function detectOnce() {
    if (!baseBitmap) return null;

    await initTF();
    await loadModel();

    const runPredict = async () => {
      return await tf.tidy(async () => {
        const input = tf.browser.fromPixels(stage);
        // BlazeFace UMD expects {returnTensors:false}
        const preds = await faceModel.estimateFaces(input, false);
        if (!preds || !preds.length) return null;
        const p = preds[0];
        const [x1,y1] = p.topLeft;
        const [x2,y2] = p.bottomRight;
        return { x:x1, y:y1, width: x2-x1, height: y2-y1 };
      });
    };

    const timed = (ms, fn) => new Promise((resolve, reject) => {
      let done = false;
      const t = setTimeout(() => { if(!done){ done=true; reject(new Error("detect_timeout")); }}, ms);
      fn().then(v => { if(!done){ done=true; clearTimeout(t); resolve(v); }})
          .catch(e => { if(!done){ done=true; clearTimeout(t); reject(e); }});
    });

    const t0 = performance.now();
    try {
      let box = await timed(3000, runPredict);
      if (!box) {
        logEvt("error",{ detect:"no_face" });
        return null;
      }
      const dt = Math.round(performance.now() - t0);
      lastBox = box;
      session.detects += 1;
      session.detectTimes.push(dt);
      drawOverlay(box);
      logEvt("detect",{ roughLocate_ms:dt, finalDetect_ms:dt, box });
      updateSessionStats();
      return box;
    } catch (e) {
      // auto fallback: webgl -> wasm once
      const cur = safeBackend();
      if (e && e.message === "detect_timeout" && cur === "webgl") {
        logEvt("error",{ detect_timeout:true, backend:cur, fallback:"wasm_retry" });
        try {
          await tf.setBackend("wasm");
          await tf.ready();
          tfVersion = tf?.version_core || tf?.version?.tfjs || tfVersion || "—";
          faceModel = null; // reload for wasm
          await loadModel();

          const t1 = performance.now();
          const box = await timed(3000, runPredict);
          if (box) {
            const dt = Math.round(performance.now() - t1);
            lastBox = box;
            session.detects += 1;
            session.detectTimes.push(dt);
            drawOverlay(box);
            logEvt("detect",{ roughLocate_ms:dt, finalDetect_ms:dt, box });
            updateSessionStats();
            return box;
          } else {
            logEvt("error",{ detect:"no_face_after_fallback" });
            return null;
          }
        } catch (e2) {
          logEvt("error",{ detect_fallback_failed: e2.message || String(e2) });
          return null;
        }
      } else {
        logEvt("error",{ detect_exception: e.message || String(e) });
        return null;
      }
    }
  }

  /* ===== Analysis ===== */
  function computeAnalysis() {
    if (!lastBox || !baseBitmap) return null;
    const w = stage.width, h = stage.height;
    const b = lastBox;
    const area_pct = (b.width*b.height)/(w*h)*100;
    const center = { x: b.x + b.width/2, y: b.y + b.height/2 };
    const center_offset_pct = {
      x: ((center.x - w/2) / (w/2)) * 100,
      y: ((center.y - h/2) / (h/2)) * 100
    };

    // quick luminance stats
    const img = ctx.getImageData(0,0,w,h);
    let sum=0, n=img.data.length/4, vals=[];
    for (let i=0;i<img.data.length;i+=4){
      const Y = 0.2126*img.data[i] + 0.7152*img.data[i+1] + 0.0722*img.data[i+2];
      vals.push(Y); sum += Y;
    }
    const mean = sum/n;
    let v=0; for (let i=0;i<vals.length;i++){ const d=vals[i]-mean; v += d*d; }
    const contrast = Math.sqrt(v/n);

    // Laplacian variance proxy
    // (Cheap: sample every few pixels)
    let sharp=0, m=0;
    const step=4;
    for (let y=1;y<h-1;y+=step){
      for (let x=1;x<w-1;x+=step){
        const idx = (y*w + x)*4;
        const c = img.data[idx];
        const l = img.data[idx-4], r = img.data[idx+4];
        const t = img.data[idx-4*w], bt = img.data[idx+4*w];
        const lap = (4*c - l - r - t - bt);
        sharp += lap*lap; m++;
      }
    }
    const lapVar = m ? sharp/m : 0;

    const result = {
      revision: REVISION,
      timestamp: new Date().toISOString(),
      image: { width:w, height:h },
      box: {
        x: +b.x.toFixed(2), y:+b.y.toFixed(2),
        width:+b.width.toFixed(2), height:+b.height.toFixed(2),
        area_pct:+area_pct.toFixed(4),
        center:{ x:+center.x.toFixed(2), y:+center.y.toFixed(2) },
        center_offset_pct:{ x:+center_offset_pct.x.toFixed(2), y:+center_offset_pct.y.toFixed(2) }
      },
      lighting: {
        brightness_mean:+mean.toFixed(3),
        contrast_stdev:+contrast.toFixed(3)
      },
      sharpness: { laplacian_variance:+lapVar.toFixed(3) },
      orientation: w>=h ? "landscape" : "portrait",
      tf: {
        backend: safeBackend(),
        version: (typeof tfVersion === 'string' && tfVersion) ? tfVersion : (tf?.version_core || tf?.version?.tfjs || "—")
      },
      refine: {}
    };

    lastAnalysis = result;
    session.analyses += 1;
    updateSessionStats();
    renderAnalysis(result);
    return result;
  }

  function renderAnalysis(a) {
    $("analysisCard").style.display = "";
    const kv = $("analysisKv");
    kv.innerHTML = `
      <div>Revision</div><div>${a.revision}</div>
      <div>When</div><div>${new Date(a.timestamp).toLocaleString()}</div>
      <div>Backend</div><div>${a.tf.backend} v${a.tf.version}</div>
      <div>Image</div><div>${a.image.width}×${a.image.height}</div>
      <div>Face area</div><div>${a.box.area_pct.toFixed(2)} %</div>
      <div>Center offset</div><div>X ${a.box.center_offset_pct.x.toFixed(1)} %, Y ${a.box.center_offset_pct.y.toFixed(1)} %</div>
      <div>Brightness</div><div>${a.lighting.brightness_mean.toFixed(1)}</div>
      <div>Contrast σ</div><div>${a.lighting.contrast_stdev.toFixed(1)}</div>
      <div>Sharpness (LapVar)</div><div>${a.sharpness.laplacian_variance.toFixed(0)}</div>
      <div>Orientation</div><div>${a.orientation}</div>
    `;
  }

  /* ===== Sample & file helpers ===== */
  async function loadSample() {
    try {
      const url = "https://images.unsplash.com/photo-1502685104226-ee32379fefbe?q=80&w=1024&auto=format&fit=crop";
      const res = await fetch(url, { cache:"no-store" });
      if (!res.ok) throw new Error("HTTP "+res.status);
      const blob = await res.blob();
      baseBitmap = await decodeBitmapFromBlob(blob);
      paintBase();
      $("detectBtn").disabled = false;
      $("enhanceBtn").disabled = false;
      logEvt("detect",{ sampleImage:url });
      return true;
    } catch (e) {
      logEvt("error",{ sample_failed:e.message || String(e) });
      return false;
    }
  }

  /* ===== Auto-Test (always frees UI) ===== */
  function buildAutoTestReport() {
    const full = getAllLogsText();
    const start = __autoTestStartIdx || 0;
    const chunk = full.slice(start);

    const backend = safeBackend();
    const passes = (chunk.match(/"step":"[^"]+","ok":true/g) || []).length;
    const errors = (chunk.match(/"type":"error"/g) || []).length;
    const roughMs = (chunk.match(/"roughLocate_ms":(\d+)/) || [])[1];
    const finalMs = (chunk.match(/"finalDetect_ms":(\d+)/) || [])[1];

    const summary = `YorN ${REVISION} • TF backend: ${backend} • refine: ${lastAnalysis && lastAnalysis.refine ? 'yes':'no'} • passes: ${passes} • errors: ${errors} • rough: ${roughMs||'—'} ms • final: ${finalMs||'—'} ms`;
    const lines = chunk.split('\n').filter(l => /"type":"test"|"type":"detect"|"type":"analysis"|"type":"config"|"type":"error"/.test(l));
    return ['=== YorN Auto‑Test Report ===', summary, '', ...lines, '=== End Report ===',''].join('\n');
  }

  async function runAutoTest() {
    if (isBusy) return;
    setBusy(true);
    const fullBefore = getAllLogsText();
    __autoTestStartIdx = fullBefore.length;
    logEvt("test",{step:"begin",rev:REVISION});

    try {
      const okS = await loadSample();
      logEvt("test",{step:"sample",ok:!!okS});
      if (!okS) throw new Error("sample_failed");

      const box = await detectOnce();
      logEvt("test",{step:"detect",ok:!!box});
      if (!box) throw new Error("detect_failed");

      const a = computeAnalysis();
      logEvt("test",{step:"analysis",ok:!!a});

      const ok = !!(baseBitmap && lastBox && lastAnalysis);
      const badge = $("readinessBadge");
      if (badge) {
        badge.style.display='inline-block';
        badge.className = ok ? 'badge ready' : 'badge blocked';
        badge.textContent = ok ? 'READY' : 'BLOCKED';
      }
      logEvt("test",{step:"summary",ok});
      $("copyTestBtn").disabled = false;
      setProgress('', 'Auto‑Test complete');
      setTimeout(()=>setProgress('',''), 1200);
    } catch(e) {
      logEvt("error",{ autoTest: e.message || String(e) });
      $("copyTestBtn").disabled = false;
      setProgress('', 'Auto‑Test failed');
      setTimeout(()=>setProgress('',''), 1500);
    } finally {
      setBusy(false);
    }
  }

  /* ===== UI binds ===== */
  $("zoom").addEventListener("input", (e)=>{ $("zoomLabel").textContent = (+e.target.value).toFixed(2); paintBase(); });
  $("bri").addEventListener("input", (e)=>{ $("briLabel").textContent = (+e.target.value).toFixed(2); paintBase(); });
  $("con").addEventListener("input", (e)=>{ $("conLabel").textContent = (+e.target.value).toFixed(2); paintBase(); });
  $("rot").addEventListener("change", paintBase);

  $("enhanceBtn").addEventListener("click", ()=>{
    const z=$("zoom"); z.value = Math.max(+z.value, 1.5); $("zoomLabel").textContent=(+z.value).toFixed(2);
    const b=$("bri"); b.value = Math.max(+b.value, 1.18); $("briLabel").textContent=(+b.value).toFixed(2);
    const c=$("con"); c.value = Math.max(+c.value, 1.25); $("conLabel").textContent=(+c.value).toFixed(2);
    paintBase();
    detectOnce();
    logEvt("config",{ enhance:"applied", zoom:+z.value, bri:+b.value, con:+c.value });
  });

  $("detectBtn").addEventListener("click", async ()=>{
    setBusy(true);
    try { await detectOnce(); } finally { setBusy(false); }
  });

  $("startAnalysisBtn").addEventListener("click", ()=>{
    logEvt("analysis",{ analysisRequested:true, mode:"light" });
    const a = computeAnalysis();
    if (a) setProgress('', 'Analysis ready');
  });

  $("resetBtn").addEventListener("click", ()=>{
    baseBitmap = null; faceModel = null; lastBox = null; lastAnalysis = null;
    session.detects = 0; session.detectTimes = []; session.analyses = 0;
    ctx.clearRect(0,0,stage.width,stage.height);
    $("detectBtn").disabled = true;
    $("enhanceBtn").disabled = true;
    $("startAnalysisBtn").disabled = true;
    $("analysisCard").style.display = "none";
    $("readinessBadge").style.display = "none";
    setProgress('','');
    updateSessionStats();
    logEvt("config",{ reset:true });
  });

  $("fileInput").addEventListener("change", async ()=>{
    if (!$("fileInput").files.length) return;
    const f = $("fileInput").files[0];
    try {
      baseBitmap = await decodeBitmapFromBlob(f);
      paintBase();
      $("detectBtn").disabled = false;
      $("enhanceBtn").disabled = false;
      $("startAnalysisBtn").disabled = false;
      logEvt("detect",{ file:f.name, w:baseBitmap.width, h:baseBitmap.height });
    } catch (e) {
      logEvt("error",{ decode_failed:e.message || String(e) });
    }
  });

  $("sampleBtn").addEventListener("click", async ()=>{ await loadSample(); $("startAnalysisBtn").disabled = false; });

  $("autoTestBtn").addEventListener("click", runAutoTest);

  $("copyTestBtn").addEventListener("click", async ()=>{
    try {
      const report = buildAutoTestReport();
      const res = await copyTextRobust(report);
      if (res.ok) {
        logEvt("config",{ copiedAutoTestReport:true, via:res.via, length:report.length });
        setProgress('', 'Test result copied');
        setTimeout(()=>setProgress('',''), 1200);
      } else {
        logEvt("error",{ copyAutoTestReportError: res.err || 'unknown', via:res.via });
      }
    } catch(e) {
      logEvt("error",{ copyAutoTestReportException: e.message || String(e) });
    }
  });

  $("copyDiagBtn").addEventListener("click", async ()=>{
    const txt = getAllLogsText();
    const res = await copyTextRobust(txt);
    if (res.ok) {
      setProgress('', 'Diagnostics copied');
      setTimeout(()=>setProgress('',''), 1200);
      logEvt("config",{ copyDiagnostics:true });
    } else {
      logEvt("error",{ copyDiagnosticsFailed:res.err || 'unknown' });
    }
  });

  $("clearLogsBtn").addEventListener("click", ()=>{
    $("diagnostics").textContent = "No diagnostics yet.";
  });

  $("copySummaryBtn").addEventListener("click", async ()=>{
    if (!lastAnalysis) return;
    const a = lastAnalysis;
    const tfb = (a.tf && a.tf.backend) ? a.tf.backend : safeBackend();
    const tfv = (a.tf && a.tf.version) ? a.tf.version : (tf?.version_core || tf?.version?.tfjs || "—");
    const lines = [
      `YorN ${a.revision} — ${new Date(a.timestamp).toLocaleString()}`,
      `Backend: ${tfb} v${tfv}`,
      `Image: ${a.image.width}×${a.image.height}, Face area: ${a.box.area_pct.toFixed(2)}%`,
      `Center offset: X ${a.box.center_offset_pct.x.toFixed(1)}%, Y ${a.box.center_offset_pct.y.toFixed(1)}%`,
      `Brightness: ${a.lighting.brightness_mean.toFixed(1)}, Contrast σ: ${a.lighting.contrast_stdev.toFixed(1)}, Sharpness (LapVar): ${a.sharpness.laplacian_variance.toFixed(0)}`
    ].join("\n");
    const r = await copyTextRobust(lines);
    $("progressText").textContent = r.ok ? "Summary copied" : "Copy failed";
    setTimeout(()=>{$("progressText").textContent="";},1200);
  });

  $("copyJsonBtn").addEventListener("click", async ()=>{
    if (!lastAnalysis) return;
    const r = await copyTextRobust(JSON.stringify(lastAnalysis,null,2));
    $("progressText").textContent = r.ok ? "Analysis JSON copied" : "Copy failed";
    setTimeout(()=>{$("progressText").textContent="";},1200);
  });

  $("exportJsonBtn").addEventListener("click", ()=>{
    if (!lastAnalysis) return;
    const blob = new Blob([JSON.stringify(lastAnalysis,null,2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `yorn-analysis-${Date.now()}.json`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  /* ===== Boot ===== */
  window.addEventListener("load", async ()=>{
    $("rev").textContent = REVISION;
    try {
      await initTF();
      logEvt("config",{ tf_ready:true, backend:safeBackend(), tf_version: tfVersion });
      updateTfBadges();
      logEvt("config",{ boot:"dom-ready", rev:REVISION });
      logEvt("config",{ boot:"complete" });
    } catch (e) {
      logEvt("error",{ tf_init: e.message || String(e) });
    }
  });

})();
</script>
</body>
</html>